
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ClientProfile
 * 
 */
export type ClientProfile = $Result.DefaultSelection<Prisma.$ClientProfilePayload>
/**
 * Model ClientFeedback
 * 
 */
export type ClientFeedback = $Result.DefaultSelection<Prisma.$ClientFeedbackPayload>
/**
 * Model EmailLog
 * 
 */
export type EmailLog = $Result.DefaultSelection<Prisma.$EmailLogPayload>
/**
 * Model Note
 * 
 */
export type Note = $Result.DefaultSelection<Prisma.$NotePayload>
/**
 * Model Assignment
 * 
 */
export type Assignment = $Result.DefaultSelection<Prisma.$AssignmentPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model ServiceCategory
 * 
 */
export type ServiceCategory = $Result.DefaultSelection<Prisma.$ServiceCategoryPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Package
 * 
 */
export type Package = $Result.DefaultSelection<Prisma.$PackagePayload>
/**
 * Model PackageService
 * 
 */
export type PackageService = $Result.DefaultSelection<Prisma.$PackageServicePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Availability
 * 
 */
export type Availability = $Result.DefaultSelection<Prisma.$AvailabilityPayload>
/**
 * Model GiftCard
 * 
 */
export type GiftCard = $Result.DefaultSelection<Prisma.$GiftCardPayload>
/**
 * Model GymMembership
 * 
 */
export type GymMembership = $Result.DefaultSelection<Prisma.$GymMembershipPayload>
/**
 * Model GymSubscription
 * 
 */
export type GymSubscription = $Result.DefaultSelection<Prisma.$GymSubscriptionPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Promotion
 * 
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model ServicePromotion
 * 
 */
export type ServicePromotion = $Result.DefaultSelection<Prisma.$ServicePromotionPayload>
/**
 * Model PackagePromotion
 * 
 */
export type PackagePromotion = $Result.DefaultSelection<Prisma.$PackagePromotionPayload>
/**
 * Model ProductPromotion
 * 
 */
export type ProductPromotion = $Result.DefaultSelection<Prisma.$ProductPromotionPayload>
/**
 * Model BookingStatusHistory
 * 
 */
export type BookingStatusHistory = $Result.DefaultSelection<Prisma.$BookingStatusHistoryPayload>
/**
 * Model WorkingSchedule
 * 
 */
export type WorkingSchedule = $Result.DefaultSelection<Prisma.$WorkingSchedulePayload>
/**
 * Model BreakPeriod
 * 
 */
export type BreakPeriod = $Result.DefaultSelection<Prisma.$BreakPeriodPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model SystemSettings
 * 
 */
export type SystemSettings = $Result.DefaultSelection<Prisma.$SystemSettingsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SECRETAIRE: 'SECRETAIRE',
  MASSOTHERAPEUTE: 'MASSOTHERAPEUTE',
  ESTHETICIENNE: 'ESTHETICIENNE',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const Gender: {
  HOMME: 'HOMME',
  FEMME: 'FEMME',
  AUTRE: 'AUTRE'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const ServiceType: {
  MASSOTHERAPIE: 'MASSOTHERAPIE',
  ESTHETIQUE: 'ESTHETIQUE'
};

export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType]


export const PaymentStatus: {
  PENDING: 'PENDING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  CANCELLED: 'CANCELLED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const BookingType: {
  SERVICE: 'SERVICE',
  PACKAGE: 'PACKAGE',
  THERMAL: 'THERMAL'
};

export type BookingType = (typeof BookingType)[keyof typeof BookingType]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CLIENT_ARRIVED: 'CLIENT_ARRIVED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  NO_SHOW: 'NO_SHOW',
  CANCELLED: 'CANCELLED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const OrderStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  SHIPPED: 'SHIPPED',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const DiscountType: {
  PERCENTAGE: 'PERCENTAGE',
  FIXED_AMOUNT: 'FIXED_AMOUNT'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]


export const NotificationType: {
  BOOKING_REMINDER: 'BOOKING_REMINDER',
  BOOKING_CONFIRMED: 'BOOKING_CONFIRMED',
  BOOKING_CANCELLED: 'BOOKING_CANCELLED',
  BOOKING_UPDATED: 'BOOKING_UPDATED',
  BOOKING_ASSIGNED: 'BOOKING_ASSIGNED'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type ServiceType = $Enums.ServiceType

export const ServiceType: typeof $Enums.ServiceType

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type BookingType = $Enums.BookingType

export const BookingType: typeof $Enums.BookingType

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.clientProfile`: Exposes CRUD operations for the **ClientProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientProfiles
    * const clientProfiles = await prisma.clientProfile.findMany()
    * ```
    */
  get clientProfile(): Prisma.ClientProfileDelegate<ExtArgs>;

  /**
   * `prisma.clientFeedback`: Exposes CRUD operations for the **ClientFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientFeedbacks
    * const clientFeedbacks = await prisma.clientFeedback.findMany()
    * ```
    */
  get clientFeedback(): Prisma.ClientFeedbackDelegate<ExtArgs>;

  /**
   * `prisma.emailLog`: Exposes CRUD operations for the **EmailLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailLogs
    * const emailLogs = await prisma.emailLog.findMany()
    * ```
    */
  get emailLog(): Prisma.EmailLogDelegate<ExtArgs>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.NoteDelegate<ExtArgs>;

  /**
   * `prisma.assignment`: Exposes CRUD operations for the **Assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.AssignmentDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.serviceCategory`: Exposes CRUD operations for the **ServiceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCategories
    * const serviceCategories = await prisma.serviceCategory.findMany()
    * ```
    */
  get serviceCategory(): Prisma.ServiceCategoryDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.package`: Exposes CRUD operations for the **Package** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Packages
    * const packages = await prisma.package.findMany()
    * ```
    */
  get package(): Prisma.PackageDelegate<ExtArgs>;

  /**
   * `prisma.packageService`: Exposes CRUD operations for the **PackageService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PackageServices
    * const packageServices = await prisma.packageService.findMany()
    * ```
    */
  get packageService(): Prisma.PackageServiceDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.availability`: Exposes CRUD operations for the **Availability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Availabilities
    * const availabilities = await prisma.availability.findMany()
    * ```
    */
  get availability(): Prisma.AvailabilityDelegate<ExtArgs>;

  /**
   * `prisma.giftCard`: Exposes CRUD operations for the **GiftCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GiftCards
    * const giftCards = await prisma.giftCard.findMany()
    * ```
    */
  get giftCard(): Prisma.GiftCardDelegate<ExtArgs>;

  /**
   * `prisma.gymMembership`: Exposes CRUD operations for the **GymMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GymMemberships
    * const gymMemberships = await prisma.gymMembership.findMany()
    * ```
    */
  get gymMembership(): Prisma.GymMembershipDelegate<ExtArgs>;

  /**
   * `prisma.gymSubscription`: Exposes CRUD operations for the **GymSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GymSubscriptions
    * const gymSubscriptions = await prisma.gymSubscription.findMany()
    * ```
    */
  get gymSubscription(): Prisma.GymSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs>;

  /**
   * `prisma.servicePromotion`: Exposes CRUD operations for the **ServicePromotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicePromotions
    * const servicePromotions = await prisma.servicePromotion.findMany()
    * ```
    */
  get servicePromotion(): Prisma.ServicePromotionDelegate<ExtArgs>;

  /**
   * `prisma.packagePromotion`: Exposes CRUD operations for the **PackagePromotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PackagePromotions
    * const packagePromotions = await prisma.packagePromotion.findMany()
    * ```
    */
  get packagePromotion(): Prisma.PackagePromotionDelegate<ExtArgs>;

  /**
   * `prisma.productPromotion`: Exposes CRUD operations for the **ProductPromotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductPromotions
    * const productPromotions = await prisma.productPromotion.findMany()
    * ```
    */
  get productPromotion(): Prisma.ProductPromotionDelegate<ExtArgs>;

  /**
   * `prisma.bookingStatusHistory`: Exposes CRUD operations for the **BookingStatusHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingStatusHistories
    * const bookingStatusHistories = await prisma.bookingStatusHistory.findMany()
    * ```
    */
  get bookingStatusHistory(): Prisma.BookingStatusHistoryDelegate<ExtArgs>;

  /**
   * `prisma.workingSchedule`: Exposes CRUD operations for the **WorkingSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkingSchedules
    * const workingSchedules = await prisma.workingSchedule.findMany()
    * ```
    */
  get workingSchedule(): Prisma.WorkingScheduleDelegate<ExtArgs>;

  /**
   * `prisma.breakPeriod`: Exposes CRUD operations for the **BreakPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BreakPeriods
    * const breakPeriods = await prisma.breakPeriod.findMany()
    * ```
    */
  get breakPeriod(): Prisma.BreakPeriodDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.systemSettings`: Exposes CRUD operations for the **SystemSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSettings.findMany()
    * ```
    */
  get systemSettings(): Prisma.SystemSettingsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ClientProfile: 'ClientProfile',
    ClientFeedback: 'ClientFeedback',
    EmailLog: 'EmailLog',
    Note: 'Note',
    Assignment: 'Assignment',
    Review: 'Review',
    ServiceCategory: 'ServiceCategory',
    Service: 'Service',
    Package: 'Package',
    PackageService: 'PackageService',
    Payment: 'Payment',
    Booking: 'Booking',
    Availability: 'Availability',
    GiftCard: 'GiftCard',
    GymMembership: 'GymMembership',
    GymSubscription: 'GymSubscription',
    Product: 'Product',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Promotion: 'Promotion',
    ServicePromotion: 'ServicePromotion',
    PackagePromotion: 'PackagePromotion',
    ProductPromotion: 'ProductPromotion',
    BookingStatusHistory: 'BookingStatusHistory',
    WorkingSchedule: 'WorkingSchedule',
    BreakPeriod: 'BreakPeriod',
    Notification: 'Notification',
    SystemSettings: 'SystemSettings'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "clientProfile" | "clientFeedback" | "emailLog" | "note" | "assignment" | "review" | "serviceCategory" | "service" | "package" | "packageService" | "payment" | "booking" | "availability" | "giftCard" | "gymMembership" | "gymSubscription" | "product" | "order" | "orderItem" | "promotion" | "servicePromotion" | "packagePromotion" | "productPromotion" | "bookingStatusHistory" | "workingSchedule" | "breakPeriod" | "notification" | "systemSettings"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ClientProfile: {
        payload: Prisma.$ClientProfilePayload<ExtArgs>
        fields: Prisma.ClientProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          findFirst: {
            args: Prisma.ClientProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          findMany: {
            args: Prisma.ClientProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>[]
          }
          create: {
            args: Prisma.ClientProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          createMany: {
            args: Prisma.ClientProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>[]
          }
          delete: {
            args: Prisma.ClientProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          update: {
            args: Prisma.ClientProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          deleteMany: {
            args: Prisma.ClientProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          aggregate: {
            args: Prisma.ClientProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientProfile>
          }
          groupBy: {
            args: Prisma.ClientProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ClientProfileCountAggregateOutputType> | number
          }
        }
      }
      ClientFeedback: {
        payload: Prisma.$ClientFeedbackPayload<ExtArgs>
        fields: Prisma.ClientFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientFeedbackPayload>
          }
          findFirst: {
            args: Prisma.ClientFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientFeedbackPayload>
          }
          findMany: {
            args: Prisma.ClientFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientFeedbackPayload>[]
          }
          create: {
            args: Prisma.ClientFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientFeedbackPayload>
          }
          createMany: {
            args: Prisma.ClientFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientFeedbackPayload>[]
          }
          delete: {
            args: Prisma.ClientFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientFeedbackPayload>
          }
          update: {
            args: Prisma.ClientFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.ClientFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientFeedbackPayload>
          }
          aggregate: {
            args: Prisma.ClientFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientFeedback>
          }
          groupBy: {
            args: Prisma.ClientFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<ClientFeedbackCountAggregateOutputType> | number
          }
        }
      }
      EmailLog: {
        payload: Prisma.$EmailLogPayload<ExtArgs>
        fields: Prisma.EmailLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          findFirst: {
            args: Prisma.EmailLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          findMany: {
            args: Prisma.EmailLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>[]
          }
          create: {
            args: Prisma.EmailLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          createMany: {
            args: Prisma.EmailLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>[]
          }
          delete: {
            args: Prisma.EmailLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          update: {
            args: Prisma.EmailLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          deleteMany: {
            args: Prisma.EmailLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          aggregate: {
            args: Prisma.EmailLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailLog>
          }
          groupBy: {
            args: Prisma.EmailLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailLogCountArgs<ExtArgs>
            result: $Utils.Optional<EmailLogCountAggregateOutputType> | number
          }
        }
      }
      Note: {
        payload: Prisma.$NotePayload<ExtArgs>
        fields: Prisma.NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findFirst: {
            args: Prisma.NoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findMany: {
            args: Prisma.NoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          create: {
            args: Prisma.NoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          createMany: {
            args: Prisma.NoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          delete: {
            args: Prisma.NoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          update: {
            args: Prisma.NoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          deleteMany: {
            args: Prisma.NoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote>
          }
          groupBy: {
            args: Prisma.NoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteCountArgs<ExtArgs>
            result: $Utils.Optional<NoteCountAggregateOutputType> | number
          }
        }
      }
      Assignment: {
        payload: Prisma.$AssignmentPayload<ExtArgs>
        fields: Prisma.AssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findFirst: {
            args: Prisma.AssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findMany: {
            args: Prisma.AssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          create: {
            args: Prisma.AssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          createMany: {
            args: Prisma.AssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          delete: {
            args: Prisma.AssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          update: {
            args: Prisma.AssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.AssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      ServiceCategory: {
        payload: Prisma.$ServiceCategoryPayload<ExtArgs>
        fields: Prisma.ServiceCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findFirst: {
            args: Prisma.ServiceCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          findMany: {
            args: Prisma.ServiceCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          create: {
            args: Prisma.ServiceCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          createMany: {
            args: Prisma.ServiceCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>[]
          }
          delete: {
            args: Prisma.ServiceCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          update: {
            args: Prisma.ServiceCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCategoryPayload>
          }
          aggregate: {
            args: Prisma.ServiceCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCategory>
          }
          groupBy: {
            args: Prisma.ServiceCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCategoryCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Package: {
        payload: Prisma.$PackagePayload<ExtArgs>
        fields: Prisma.PackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          findFirst: {
            args: Prisma.PackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          findMany: {
            args: Prisma.PackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          create: {
            args: Prisma.PackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          createMany: {
            args: Prisma.PackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          delete: {
            args: Prisma.PackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          update: {
            args: Prisma.PackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          deleteMany: {
            args: Prisma.PackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          aggregate: {
            args: Prisma.PackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackage>
          }
          groupBy: {
            args: Prisma.PackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageCountArgs<ExtArgs>
            result: $Utils.Optional<PackageCountAggregateOutputType> | number
          }
        }
      }
      PackageService: {
        payload: Prisma.$PackageServicePayload<ExtArgs>
        fields: Prisma.PackageServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageServicePayload>
          }
          findFirst: {
            args: Prisma.PackageServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageServicePayload>
          }
          findMany: {
            args: Prisma.PackageServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageServicePayload>[]
          }
          create: {
            args: Prisma.PackageServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageServicePayload>
          }
          createMany: {
            args: Prisma.PackageServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackageServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageServicePayload>[]
          }
          delete: {
            args: Prisma.PackageServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageServicePayload>
          }
          update: {
            args: Prisma.PackageServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageServicePayload>
          }
          deleteMany: {
            args: Prisma.PackageServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PackageServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageServicePayload>
          }
          aggregate: {
            args: Prisma.PackageServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackageService>
          }
          groupBy: {
            args: Prisma.PackageServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageServiceCountArgs<ExtArgs>
            result: $Utils.Optional<PackageServiceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Availability: {
        payload: Prisma.$AvailabilityPayload<ExtArgs>
        fields: Prisma.AvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          findFirst: {
            args: Prisma.AvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          findMany: {
            args: Prisma.AvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          create: {
            args: Prisma.AvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          createMany: {
            args: Prisma.AvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvailabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          delete: {
            args: Prisma.AvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          update: {
            args: Prisma.AvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.AvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          aggregate: {
            args: Prisma.AvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvailability>
          }
          groupBy: {
            args: Prisma.AvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityCountAggregateOutputType> | number
          }
        }
      }
      GiftCard: {
        payload: Prisma.$GiftCardPayload<ExtArgs>
        fields: Prisma.GiftCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GiftCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GiftCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>
          }
          findFirst: {
            args: Prisma.GiftCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GiftCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>
          }
          findMany: {
            args: Prisma.GiftCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>[]
          }
          create: {
            args: Prisma.GiftCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>
          }
          createMany: {
            args: Prisma.GiftCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GiftCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>[]
          }
          delete: {
            args: Prisma.GiftCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>
          }
          update: {
            args: Prisma.GiftCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>
          }
          deleteMany: {
            args: Prisma.GiftCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GiftCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GiftCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>
          }
          aggregate: {
            args: Prisma.GiftCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGiftCard>
          }
          groupBy: {
            args: Prisma.GiftCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<GiftCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.GiftCardCountArgs<ExtArgs>
            result: $Utils.Optional<GiftCardCountAggregateOutputType> | number
          }
        }
      }
      GymMembership: {
        payload: Prisma.$GymMembershipPayload<ExtArgs>
        fields: Prisma.GymMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GymMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GymMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>
          }
          findFirst: {
            args: Prisma.GymMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GymMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>
          }
          findMany: {
            args: Prisma.GymMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>[]
          }
          create: {
            args: Prisma.GymMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>
          }
          createMany: {
            args: Prisma.GymMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GymMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>[]
          }
          delete: {
            args: Prisma.GymMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>
          }
          update: {
            args: Prisma.GymMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>
          }
          deleteMany: {
            args: Prisma.GymMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GymMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GymMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymMembershipPayload>
          }
          aggregate: {
            args: Prisma.GymMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGymMembership>
          }
          groupBy: {
            args: Prisma.GymMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<GymMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.GymMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<GymMembershipCountAggregateOutputType> | number
          }
        }
      }
      GymSubscription: {
        payload: Prisma.$GymSubscriptionPayload<ExtArgs>
        fields: Prisma.GymSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GymSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GymSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.GymSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GymSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>
          }
          findMany: {
            args: Prisma.GymSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>[]
          }
          create: {
            args: Prisma.GymSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>
          }
          createMany: {
            args: Prisma.GymSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GymSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.GymSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>
          }
          update: {
            args: Prisma.GymSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.GymSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GymSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GymSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GymSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.GymSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGymSubscription>
          }
          groupBy: {
            args: Prisma.GymSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GymSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GymSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<GymSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      ServicePromotion: {
        payload: Prisma.$ServicePromotionPayload<ExtArgs>
        fields: Prisma.ServicePromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicePromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicePromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePromotionPayload>
          }
          findFirst: {
            args: Prisma.ServicePromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicePromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePromotionPayload>
          }
          findMany: {
            args: Prisma.ServicePromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePromotionPayload>[]
          }
          create: {
            args: Prisma.ServicePromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePromotionPayload>
          }
          createMany: {
            args: Prisma.ServicePromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicePromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePromotionPayload>[]
          }
          delete: {
            args: Prisma.ServicePromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePromotionPayload>
          }
          update: {
            args: Prisma.ServicePromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePromotionPayload>
          }
          deleteMany: {
            args: Prisma.ServicePromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicePromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServicePromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePromotionPayload>
          }
          aggregate: {
            args: Prisma.ServicePromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicePromotion>
          }
          groupBy: {
            args: Prisma.ServicePromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicePromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicePromotionCountArgs<ExtArgs>
            result: $Utils.Optional<ServicePromotionCountAggregateOutputType> | number
          }
        }
      }
      PackagePromotion: {
        payload: Prisma.$PackagePromotionPayload<ExtArgs>
        fields: Prisma.PackagePromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackagePromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackagePromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePromotionPayload>
          }
          findFirst: {
            args: Prisma.PackagePromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackagePromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePromotionPayload>
          }
          findMany: {
            args: Prisma.PackagePromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePromotionPayload>[]
          }
          create: {
            args: Prisma.PackagePromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePromotionPayload>
          }
          createMany: {
            args: Prisma.PackagePromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackagePromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePromotionPayload>[]
          }
          delete: {
            args: Prisma.PackagePromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePromotionPayload>
          }
          update: {
            args: Prisma.PackagePromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePromotionPayload>
          }
          deleteMany: {
            args: Prisma.PackagePromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackagePromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PackagePromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePromotionPayload>
          }
          aggregate: {
            args: Prisma.PackagePromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackagePromotion>
          }
          groupBy: {
            args: Prisma.PackagePromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackagePromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackagePromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PackagePromotionCountAggregateOutputType> | number
          }
        }
      }
      ProductPromotion: {
        payload: Prisma.$ProductPromotionPayload<ExtArgs>
        fields: Prisma.ProductPromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductPromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductPromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPromotionPayload>
          }
          findFirst: {
            args: Prisma.ProductPromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductPromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPromotionPayload>
          }
          findMany: {
            args: Prisma.ProductPromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPromotionPayload>[]
          }
          create: {
            args: Prisma.ProductPromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPromotionPayload>
          }
          createMany: {
            args: Prisma.ProductPromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductPromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPromotionPayload>[]
          }
          delete: {
            args: Prisma.ProductPromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPromotionPayload>
          }
          update: {
            args: Prisma.ProductPromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPromotionPayload>
          }
          deleteMany: {
            args: Prisma.ProductPromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductPromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductPromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPromotionPayload>
          }
          aggregate: {
            args: Prisma.ProductPromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductPromotion>
          }
          groupBy: {
            args: Prisma.ProductPromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductPromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductPromotionCountArgs<ExtArgs>
            result: $Utils.Optional<ProductPromotionCountAggregateOutputType> | number
          }
        }
      }
      BookingStatusHistory: {
        payload: Prisma.$BookingStatusHistoryPayload<ExtArgs>
        fields: Prisma.BookingStatusHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingStatusHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingStatusHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusHistoryPayload>
          }
          findFirst: {
            args: Prisma.BookingStatusHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingStatusHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusHistoryPayload>
          }
          findMany: {
            args: Prisma.BookingStatusHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusHistoryPayload>[]
          }
          create: {
            args: Prisma.BookingStatusHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusHistoryPayload>
          }
          createMany: {
            args: Prisma.BookingStatusHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingStatusHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusHistoryPayload>[]
          }
          delete: {
            args: Prisma.BookingStatusHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusHistoryPayload>
          }
          update: {
            args: Prisma.BookingStatusHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusHistoryPayload>
          }
          deleteMany: {
            args: Prisma.BookingStatusHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingStatusHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingStatusHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStatusHistoryPayload>
          }
          aggregate: {
            args: Prisma.BookingStatusHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingStatusHistory>
          }
          groupBy: {
            args: Prisma.BookingStatusHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingStatusHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingStatusHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<BookingStatusHistoryCountAggregateOutputType> | number
          }
        }
      }
      WorkingSchedule: {
        payload: Prisma.$WorkingSchedulePayload<ExtArgs>
        fields: Prisma.WorkingScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkingScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkingScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingSchedulePayload>
          }
          findFirst: {
            args: Prisma.WorkingScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkingScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingSchedulePayload>
          }
          findMany: {
            args: Prisma.WorkingScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingSchedulePayload>[]
          }
          create: {
            args: Prisma.WorkingScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingSchedulePayload>
          }
          createMany: {
            args: Prisma.WorkingScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkingScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingSchedulePayload>[]
          }
          delete: {
            args: Prisma.WorkingScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingSchedulePayload>
          }
          update: {
            args: Prisma.WorkingScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingSchedulePayload>
          }
          deleteMany: {
            args: Prisma.WorkingScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkingScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkingScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingSchedulePayload>
          }
          aggregate: {
            args: Prisma.WorkingScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkingSchedule>
          }
          groupBy: {
            args: Prisma.WorkingScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkingScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkingScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<WorkingScheduleCountAggregateOutputType> | number
          }
        }
      }
      BreakPeriod: {
        payload: Prisma.$BreakPeriodPayload<ExtArgs>
        fields: Prisma.BreakPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BreakPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BreakPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPeriodPayload>
          }
          findFirst: {
            args: Prisma.BreakPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BreakPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPeriodPayload>
          }
          findMany: {
            args: Prisma.BreakPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPeriodPayload>[]
          }
          create: {
            args: Prisma.BreakPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPeriodPayload>
          }
          createMany: {
            args: Prisma.BreakPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BreakPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPeriodPayload>[]
          }
          delete: {
            args: Prisma.BreakPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPeriodPayload>
          }
          update: {
            args: Prisma.BreakPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPeriodPayload>
          }
          deleteMany: {
            args: Prisma.BreakPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BreakPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BreakPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakPeriodPayload>
          }
          aggregate: {
            args: Prisma.BreakPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBreakPeriod>
          }
          groupBy: {
            args: Prisma.BreakPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<BreakPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.BreakPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<BreakPeriodCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      SystemSettings: {
        payload: Prisma.$SystemSettingsPayload<ExtArgs>
        fields: Prisma.SystemSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findMany: {
            args: Prisma.SystemSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          create: {
            args: Prisma.SystemSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          createMany: {
            args: Prisma.SystemSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          update: {
            args: Prisma.SystemSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSettings>
          }
          groupBy: {
            args: Prisma.SystemSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notesCreated: number
    assignedClients: number
    reviewsReceived: number
    bookingsAsProfessional: number
    bookingsCreated: number
    availabilities: number
    workingSchedules: number
    breaks: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notesCreated?: boolean | UserCountOutputTypeCountNotesCreatedArgs
    assignedClients?: boolean | UserCountOutputTypeCountAssignedClientsArgs
    reviewsReceived?: boolean | UserCountOutputTypeCountReviewsReceivedArgs
    bookingsAsProfessional?: boolean | UserCountOutputTypeCountBookingsAsProfessionalArgs
    bookingsCreated?: boolean | UserCountOutputTypeCountBookingsCreatedArgs
    availabilities?: boolean | UserCountOutputTypeCountAvailabilitiesArgs
    workingSchedules?: boolean | UserCountOutputTypeCountWorkingSchedulesArgs
    breaks?: boolean | UserCountOutputTypeCountBreaksArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsAsProfessionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAvailabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkingSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkingScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBreaksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreakPeriodWhereInput
  }


  /**
   * Count Type ClientProfileCountOutputType
   */

  export type ClientProfileCountOutputType = {
    notes: number
    assignments: number
  }

  export type ClientProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | ClientProfileCountOutputTypeCountNotesArgs
    assignments?: boolean | ClientProfileCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfileCountOutputType
     */
    select?: ClientProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }


  /**
   * Count Type ServiceCategoryCountOutputType
   */

  export type ServiceCategoryCountOutputType = {
    services: number
  }

  export type ServiceCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceCategoryCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategoryCountOutputType
     */
    select?: ServiceCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCategoryCountOutputType without action
   */
  export type ServiceCategoryCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    bookings: number
    packageServices: number
    promotions: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ServiceCountOutputTypeCountBookingsArgs
    packageServices?: boolean | ServiceCountOutputTypeCountPackageServicesArgs
    promotions?: boolean | ServiceCountOutputTypeCountPromotionsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountPackageServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePromotionWhereInput
  }


  /**
   * Count Type PackageCountOutputType
   */

  export type PackageCountOutputType = {
    services: number
    bookings: number
    promotions: number
  }

  export type PackageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | PackageCountOutputTypeCountServicesArgs
    bookings?: boolean | PackageCountOutputTypeCountBookingsArgs
    promotions?: boolean | PackageCountOutputTypeCountPromotionsArgs
  }

  // Custom InputTypes
  /**
   * PackageCountOutputType without action
   */
  export type PackageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCountOutputType
     */
    select?: PackageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PackageCountOutputType without action
   */
  export type PackageCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageServiceWhereInput
  }

  /**
   * PackageCountOutputType without action
   */
  export type PackageCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * PackageCountOutputType without action
   */
  export type PackageCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackagePromotionWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    statusHistory: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    statusHistory?: boolean | BookingCountOutputTypeCountStatusHistoryArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingStatusHistoryWhereInput
  }


  /**
   * Count Type GiftCardCountOutputType
   */

  export type GiftCardCountOutputType = {
    usedInBookings: number
  }

  export type GiftCardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usedInBookings?: boolean | GiftCardCountOutputTypeCountUsedInBookingsArgs
  }

  // Custom InputTypes
  /**
   * GiftCardCountOutputType without action
   */
  export type GiftCardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCardCountOutputType
     */
    select?: GiftCardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GiftCardCountOutputType without action
   */
  export type GiftCardCountOutputTypeCountUsedInBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type GymMembershipCountOutputType
   */

  export type GymMembershipCountOutputType = {
    subscriptions: number
  }

  export type GymMembershipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | GymMembershipCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * GymMembershipCountOutputType without action
   */
  export type GymMembershipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembershipCountOutputType
     */
    select?: GymMembershipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GymMembershipCountOutputType without action
   */
  export type GymMembershipCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymSubscriptionWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    orderItems: number
    promotions: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    promotions?: boolean | ProductCountOutputTypeCountPromotionsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductPromotionWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type PromotionCountOutputType
   */

  export type PromotionCountOutputType = {
    services: number
    packages: number
    products: number
  }

  export type PromotionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | PromotionCountOutputTypeCountServicesArgs
    packages?: boolean | PromotionCountOutputTypeCountPackagesArgs
    products?: boolean | PromotionCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCountOutputType
     */
    select?: PromotionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePromotionWhereInput
  }

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackagePromotionWhereInput
  }

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductPromotionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    telephone: string | null
    password: string | null
    role: $Enums.UserRole | null
    nom: string | null
    prenom: string | null
    photoUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    telephone: string | null
    password: string | null
    role: $Enums.UserRole | null
    nom: string | null
    prenom: string | null
    photoUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    telephone: number
    password: number
    role: number
    nom: number
    prenom: number
    photoUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    telephone?: true
    password?: true
    role?: true
    nom?: true
    prenom?: true
    photoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    telephone?: true
    password?: true
    role?: true
    nom?: true
    prenom?: true
    photoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    telephone?: true
    password?: true
    role?: true
    nom?: true
    prenom?: true
    photoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom: string | null
    prenom: string | null
    photoUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    telephone?: boolean
    password?: boolean
    role?: boolean
    nom?: boolean
    prenom?: boolean
    photoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notesCreated?: boolean | User$notesCreatedArgs<ExtArgs>
    assignedClients?: boolean | User$assignedClientsArgs<ExtArgs>
    reviewsReceived?: boolean | User$reviewsReceivedArgs<ExtArgs>
    bookingsAsProfessional?: boolean | User$bookingsAsProfessionalArgs<ExtArgs>
    bookingsCreated?: boolean | User$bookingsCreatedArgs<ExtArgs>
    availabilities?: boolean | User$availabilitiesArgs<ExtArgs>
    workingSchedules?: boolean | User$workingSchedulesArgs<ExtArgs>
    breaks?: boolean | User$breaksArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    telephone?: boolean
    password?: boolean
    role?: boolean
    nom?: boolean
    prenom?: boolean
    photoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    telephone?: boolean
    password?: boolean
    role?: boolean
    nom?: boolean
    prenom?: boolean
    photoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notesCreated?: boolean | User$notesCreatedArgs<ExtArgs>
    assignedClients?: boolean | User$assignedClientsArgs<ExtArgs>
    reviewsReceived?: boolean | User$reviewsReceivedArgs<ExtArgs>
    bookingsAsProfessional?: boolean | User$bookingsAsProfessionalArgs<ExtArgs>
    bookingsCreated?: boolean | User$bookingsCreatedArgs<ExtArgs>
    availabilities?: boolean | User$availabilitiesArgs<ExtArgs>
    workingSchedules?: boolean | User$workingSchedulesArgs<ExtArgs>
    breaks?: boolean | User$breaksArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      notesCreated: Prisma.$NotePayload<ExtArgs>[]
      assignedClients: Prisma.$AssignmentPayload<ExtArgs>[]
      reviewsReceived: Prisma.$ReviewPayload<ExtArgs>[]
      bookingsAsProfessional: Prisma.$BookingPayload<ExtArgs>[]
      bookingsCreated: Prisma.$BookingPayload<ExtArgs>[]
      availabilities: Prisma.$AvailabilityPayload<ExtArgs>[]
      workingSchedules: Prisma.$WorkingSchedulePayload<ExtArgs>[]
      breaks: Prisma.$BreakPeriodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      telephone: string
      password: string
      role: $Enums.UserRole
      nom: string | null
      prenom: string | null
      photoUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notesCreated<T extends User$notesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$notesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany"> | Null>
    assignedClients<T extends User$assignedClientsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    reviewsReceived<T extends User$reviewsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    bookingsAsProfessional<T extends User$bookingsAsProfessionalArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsAsProfessionalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    bookingsCreated<T extends User$bookingsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    availabilities<T extends User$availabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$availabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany"> | Null>
    workingSchedules<T extends User$workingSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, User$workingSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    breaks<T extends User$breaksArgs<ExtArgs> = {}>(args?: Subset<T, User$breaksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakPeriodPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly telephone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly nom: FieldRef<"User", 'String'>
    readonly prenom: FieldRef<"User", 'String'>
    readonly photoUrl: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.notesCreated
   */
  export type User$notesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * User.assignedClients
   */
  export type User$assignedClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * User.reviewsReceived
   */
  export type User$reviewsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.bookingsAsProfessional
   */
  export type User$bookingsAsProfessionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.bookingsCreated
   */
  export type User$bookingsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.availabilities
   */
  export type User$availabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    cursor?: AvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * User.workingSchedules
   */
  export type User$workingSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingSchedule
     */
    select?: WorkingScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingScheduleInclude<ExtArgs> | null
    where?: WorkingScheduleWhereInput
    orderBy?: WorkingScheduleOrderByWithRelationInput | WorkingScheduleOrderByWithRelationInput[]
    cursor?: WorkingScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkingScheduleScalarFieldEnum | WorkingScheduleScalarFieldEnum[]
  }

  /**
   * User.breaks
   */
  export type User$breaksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakPeriod
     */
    select?: BreakPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakPeriodInclude<ExtArgs> | null
    where?: BreakPeriodWhereInput
    orderBy?: BreakPeriodOrderByWithRelationInput | BreakPeriodOrderByWithRelationInput[]
    cursor?: BreakPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreakPeriodScalarFieldEnum | BreakPeriodScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ClientProfile
   */

  export type AggregateClientProfile = {
    _count: ClientProfileCountAggregateOutputType | null
    _avg: ClientProfileAvgAggregateOutputType | null
    _sum: ClientProfileSumAggregateOutputType | null
    _min: ClientProfileMinAggregateOutputType | null
    _max: ClientProfileMaxAggregateOutputType | null
  }

  export type ClientProfileAvgAggregateOutputType = {
    feedbackEmailsSent: number | null
    promoEmailsSent: number | null
  }

  export type ClientProfileSumAggregateOutputType = {
    feedbackEmailsSent: number | null
    promoEmailsSent: number | null
  }

  export type ClientProfileMinAggregateOutputType = {
    id: string | null
    nom: string | null
    prenom: string | null
    adresse: string | null
    ville: string | null
    codePostal: string | null
    telMaison: string | null
    telBureau: string | null
    telCellulaire: string | null
    courriel: string | null
    dateNaissance: Date | null
    occupation: string | null
    gender: $Enums.Gender | null
    serviceType: $Enums.ServiceType | null
    assuranceCouvert: boolean | null
    autreMaladie: boolean | null
    autreMaladieDetails: string | null
    raisonConsultation: string | null
    diagnosticMedical: boolean | null
    diagnosticMedicalDetails: string | null
    medicaments: boolean | null
    medicamentsDetails: string | null
    accidents: boolean | null
    accidentsDetails: string | null
    operationsChirurgicales: boolean | null
    operationsChirurgicalesDetails: string | null
    traitementsActuels: string | null
    problemesCardiaques: boolean | null
    problemesCardiaquesDetails: string | null
    maladiesGraves: boolean | null
    maladiesGravesDetails: string | null
    ortheses: boolean | null
    orthesesDetails: string | null
    allergies: boolean | null
    allergiesDetails: string | null
    raideurs: boolean | null
    arthrose: boolean | null
    hernieDiscale: boolean | null
    oedeme: boolean | null
    tendinite: boolean | null
    mauxDeTete: boolean | null
    flatulence: boolean | null
    troublesCirculatoires: boolean | null
    hypothyroidie: boolean | null
    diabete: boolean | null
    stresse: boolean | null
    premenopause: boolean | null
    douleurMusculaire: boolean | null
    fibromyalgie: boolean | null
    rhumatisme: boolean | null
    sciatique: boolean | null
    bursite: boolean | null
    migraine: boolean | null
    diarrhee: boolean | null
    phlebite: boolean | null
    hypertension: boolean | null
    hypoglycemie: boolean | null
    burnOut: boolean | null
    menopause: boolean | null
    inflammationAigue: boolean | null
    arteriosclerose: boolean | null
    osteoporose: boolean | null
    mauxDeDos: boolean | null
    fatigueDesJambes: boolean | null
    troublesDigestifs: boolean | null
    constipation: boolean | null
    hyperthyroidie: boolean | null
    hypotension: boolean | null
    insomnie: boolean | null
    depressionNerveuse: boolean | null
    autres: string | null
    lastVisitDate: Date | null
    lastEmailSent: Date | null
    feedbackEmailsSent: number | null
    promoEmailsSent: number | null
    etatPeau: string | null
    etatPores: string | null
    coucheCornee: string | null
    irrigationSanguine: string | null
    impuretes: string | null
    sensibiliteCutanee: string | null
    fumeur: string | null
    niveauStress: string | null
    expositionSoleil: string | null
    protectionSolaire: string | null
    suffisanceEau: string | null
    travailExterieur: string | null
    bainChauds: string | null
    routineSoins: string | null
    changementsRecents: string | null
    preferencePeau: string | null
    diagnosticVisuelNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientProfileMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    prenom: string | null
    adresse: string | null
    ville: string | null
    codePostal: string | null
    telMaison: string | null
    telBureau: string | null
    telCellulaire: string | null
    courriel: string | null
    dateNaissance: Date | null
    occupation: string | null
    gender: $Enums.Gender | null
    serviceType: $Enums.ServiceType | null
    assuranceCouvert: boolean | null
    autreMaladie: boolean | null
    autreMaladieDetails: string | null
    raisonConsultation: string | null
    diagnosticMedical: boolean | null
    diagnosticMedicalDetails: string | null
    medicaments: boolean | null
    medicamentsDetails: string | null
    accidents: boolean | null
    accidentsDetails: string | null
    operationsChirurgicales: boolean | null
    operationsChirurgicalesDetails: string | null
    traitementsActuels: string | null
    problemesCardiaques: boolean | null
    problemesCardiaquesDetails: string | null
    maladiesGraves: boolean | null
    maladiesGravesDetails: string | null
    ortheses: boolean | null
    orthesesDetails: string | null
    allergies: boolean | null
    allergiesDetails: string | null
    raideurs: boolean | null
    arthrose: boolean | null
    hernieDiscale: boolean | null
    oedeme: boolean | null
    tendinite: boolean | null
    mauxDeTete: boolean | null
    flatulence: boolean | null
    troublesCirculatoires: boolean | null
    hypothyroidie: boolean | null
    diabete: boolean | null
    stresse: boolean | null
    premenopause: boolean | null
    douleurMusculaire: boolean | null
    fibromyalgie: boolean | null
    rhumatisme: boolean | null
    sciatique: boolean | null
    bursite: boolean | null
    migraine: boolean | null
    diarrhee: boolean | null
    phlebite: boolean | null
    hypertension: boolean | null
    hypoglycemie: boolean | null
    burnOut: boolean | null
    menopause: boolean | null
    inflammationAigue: boolean | null
    arteriosclerose: boolean | null
    osteoporose: boolean | null
    mauxDeDos: boolean | null
    fatigueDesJambes: boolean | null
    troublesDigestifs: boolean | null
    constipation: boolean | null
    hyperthyroidie: boolean | null
    hypotension: boolean | null
    insomnie: boolean | null
    depressionNerveuse: boolean | null
    autres: string | null
    lastVisitDate: Date | null
    lastEmailSent: Date | null
    feedbackEmailsSent: number | null
    promoEmailsSent: number | null
    etatPeau: string | null
    etatPores: string | null
    coucheCornee: string | null
    irrigationSanguine: string | null
    impuretes: string | null
    sensibiliteCutanee: string | null
    fumeur: string | null
    niveauStress: string | null
    expositionSoleil: string | null
    protectionSolaire: string | null
    suffisanceEau: string | null
    travailExterieur: string | null
    bainChauds: string | null
    routineSoins: string | null
    changementsRecents: string | null
    preferencePeau: string | null
    diagnosticVisuelNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientProfileCountAggregateOutputType = {
    id: number
    nom: number
    prenom: number
    adresse: number
    ville: number
    codePostal: number
    telMaison: number
    telBureau: number
    telCellulaire: number
    courriel: number
    dateNaissance: number
    occupation: number
    gender: number
    serviceType: number
    assuranceCouvert: number
    autreMaladie: number
    autreMaladieDetails: number
    raisonConsultation: number
    diagnosticMedical: number
    diagnosticMedicalDetails: number
    medicaments: number
    medicamentsDetails: number
    accidents: number
    accidentsDetails: number
    operationsChirurgicales: number
    operationsChirurgicalesDetails: number
    traitementsActuels: number
    problemesCardiaques: number
    problemesCardiaquesDetails: number
    maladiesGraves: number
    maladiesGravesDetails: number
    ortheses: number
    orthesesDetails: number
    allergies: number
    allergiesDetails: number
    raideurs: number
    arthrose: number
    hernieDiscale: number
    oedeme: number
    tendinite: number
    mauxDeTete: number
    flatulence: number
    troublesCirculatoires: number
    hypothyroidie: number
    diabete: number
    stresse: number
    premenopause: number
    douleurMusculaire: number
    fibromyalgie: number
    rhumatisme: number
    sciatique: number
    bursite: number
    migraine: number
    diarrhee: number
    phlebite: number
    hypertension: number
    hypoglycemie: number
    burnOut: number
    menopause: number
    inflammationAigue: number
    arteriosclerose: number
    osteoporose: number
    mauxDeDos: number
    fatigueDesJambes: number
    troublesDigestifs: number
    constipation: number
    hyperthyroidie: number
    hypotension: number
    insomnie: number
    depressionNerveuse: number
    autres: number
    lastVisitDate: number
    lastEmailSent: number
    feedbackEmailsSent: number
    promoEmailsSent: number
    zonesDouleur: number
    etatPeau: number
    etatPores: number
    coucheCornee: number
    irrigationSanguine: number
    impuretes: number
    sensibiliteCutanee: number
    fumeur: number
    niveauStress: number
    expositionSoleil: number
    protectionSolaire: number
    suffisanceEau: number
    travailExterieur: number
    bainChauds: number
    routineSoins: number
    changementsRecents: number
    preferencePeau: number
    diagnosticVisuelNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientProfileAvgAggregateInputType = {
    feedbackEmailsSent?: true
    promoEmailsSent?: true
  }

  export type ClientProfileSumAggregateInputType = {
    feedbackEmailsSent?: true
    promoEmailsSent?: true
  }

  export type ClientProfileMinAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    adresse?: true
    ville?: true
    codePostal?: true
    telMaison?: true
    telBureau?: true
    telCellulaire?: true
    courriel?: true
    dateNaissance?: true
    occupation?: true
    gender?: true
    serviceType?: true
    assuranceCouvert?: true
    autreMaladie?: true
    autreMaladieDetails?: true
    raisonConsultation?: true
    diagnosticMedical?: true
    diagnosticMedicalDetails?: true
    medicaments?: true
    medicamentsDetails?: true
    accidents?: true
    accidentsDetails?: true
    operationsChirurgicales?: true
    operationsChirurgicalesDetails?: true
    traitementsActuels?: true
    problemesCardiaques?: true
    problemesCardiaquesDetails?: true
    maladiesGraves?: true
    maladiesGravesDetails?: true
    ortheses?: true
    orthesesDetails?: true
    allergies?: true
    allergiesDetails?: true
    raideurs?: true
    arthrose?: true
    hernieDiscale?: true
    oedeme?: true
    tendinite?: true
    mauxDeTete?: true
    flatulence?: true
    troublesCirculatoires?: true
    hypothyroidie?: true
    diabete?: true
    stresse?: true
    premenopause?: true
    douleurMusculaire?: true
    fibromyalgie?: true
    rhumatisme?: true
    sciatique?: true
    bursite?: true
    migraine?: true
    diarrhee?: true
    phlebite?: true
    hypertension?: true
    hypoglycemie?: true
    burnOut?: true
    menopause?: true
    inflammationAigue?: true
    arteriosclerose?: true
    osteoporose?: true
    mauxDeDos?: true
    fatigueDesJambes?: true
    troublesDigestifs?: true
    constipation?: true
    hyperthyroidie?: true
    hypotension?: true
    insomnie?: true
    depressionNerveuse?: true
    autres?: true
    lastVisitDate?: true
    lastEmailSent?: true
    feedbackEmailsSent?: true
    promoEmailsSent?: true
    etatPeau?: true
    etatPores?: true
    coucheCornee?: true
    irrigationSanguine?: true
    impuretes?: true
    sensibiliteCutanee?: true
    fumeur?: true
    niveauStress?: true
    expositionSoleil?: true
    protectionSolaire?: true
    suffisanceEau?: true
    travailExterieur?: true
    bainChauds?: true
    routineSoins?: true
    changementsRecents?: true
    preferencePeau?: true
    diagnosticVisuelNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientProfileMaxAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    adresse?: true
    ville?: true
    codePostal?: true
    telMaison?: true
    telBureau?: true
    telCellulaire?: true
    courriel?: true
    dateNaissance?: true
    occupation?: true
    gender?: true
    serviceType?: true
    assuranceCouvert?: true
    autreMaladie?: true
    autreMaladieDetails?: true
    raisonConsultation?: true
    diagnosticMedical?: true
    diagnosticMedicalDetails?: true
    medicaments?: true
    medicamentsDetails?: true
    accidents?: true
    accidentsDetails?: true
    operationsChirurgicales?: true
    operationsChirurgicalesDetails?: true
    traitementsActuels?: true
    problemesCardiaques?: true
    problemesCardiaquesDetails?: true
    maladiesGraves?: true
    maladiesGravesDetails?: true
    ortheses?: true
    orthesesDetails?: true
    allergies?: true
    allergiesDetails?: true
    raideurs?: true
    arthrose?: true
    hernieDiscale?: true
    oedeme?: true
    tendinite?: true
    mauxDeTete?: true
    flatulence?: true
    troublesCirculatoires?: true
    hypothyroidie?: true
    diabete?: true
    stresse?: true
    premenopause?: true
    douleurMusculaire?: true
    fibromyalgie?: true
    rhumatisme?: true
    sciatique?: true
    bursite?: true
    migraine?: true
    diarrhee?: true
    phlebite?: true
    hypertension?: true
    hypoglycemie?: true
    burnOut?: true
    menopause?: true
    inflammationAigue?: true
    arteriosclerose?: true
    osteoporose?: true
    mauxDeDos?: true
    fatigueDesJambes?: true
    troublesDigestifs?: true
    constipation?: true
    hyperthyroidie?: true
    hypotension?: true
    insomnie?: true
    depressionNerveuse?: true
    autres?: true
    lastVisitDate?: true
    lastEmailSent?: true
    feedbackEmailsSent?: true
    promoEmailsSent?: true
    etatPeau?: true
    etatPores?: true
    coucheCornee?: true
    irrigationSanguine?: true
    impuretes?: true
    sensibiliteCutanee?: true
    fumeur?: true
    niveauStress?: true
    expositionSoleil?: true
    protectionSolaire?: true
    suffisanceEau?: true
    travailExterieur?: true
    bainChauds?: true
    routineSoins?: true
    changementsRecents?: true
    preferencePeau?: true
    diagnosticVisuelNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientProfileCountAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    adresse?: true
    ville?: true
    codePostal?: true
    telMaison?: true
    telBureau?: true
    telCellulaire?: true
    courriel?: true
    dateNaissance?: true
    occupation?: true
    gender?: true
    serviceType?: true
    assuranceCouvert?: true
    autreMaladie?: true
    autreMaladieDetails?: true
    raisonConsultation?: true
    diagnosticMedical?: true
    diagnosticMedicalDetails?: true
    medicaments?: true
    medicamentsDetails?: true
    accidents?: true
    accidentsDetails?: true
    operationsChirurgicales?: true
    operationsChirurgicalesDetails?: true
    traitementsActuels?: true
    problemesCardiaques?: true
    problemesCardiaquesDetails?: true
    maladiesGraves?: true
    maladiesGravesDetails?: true
    ortheses?: true
    orthesesDetails?: true
    allergies?: true
    allergiesDetails?: true
    raideurs?: true
    arthrose?: true
    hernieDiscale?: true
    oedeme?: true
    tendinite?: true
    mauxDeTete?: true
    flatulence?: true
    troublesCirculatoires?: true
    hypothyroidie?: true
    diabete?: true
    stresse?: true
    premenopause?: true
    douleurMusculaire?: true
    fibromyalgie?: true
    rhumatisme?: true
    sciatique?: true
    bursite?: true
    migraine?: true
    diarrhee?: true
    phlebite?: true
    hypertension?: true
    hypoglycemie?: true
    burnOut?: true
    menopause?: true
    inflammationAigue?: true
    arteriosclerose?: true
    osteoporose?: true
    mauxDeDos?: true
    fatigueDesJambes?: true
    troublesDigestifs?: true
    constipation?: true
    hyperthyroidie?: true
    hypotension?: true
    insomnie?: true
    depressionNerveuse?: true
    autres?: true
    lastVisitDate?: true
    lastEmailSent?: true
    feedbackEmailsSent?: true
    promoEmailsSent?: true
    zonesDouleur?: true
    etatPeau?: true
    etatPores?: true
    coucheCornee?: true
    irrigationSanguine?: true
    impuretes?: true
    sensibiliteCutanee?: true
    fumeur?: true
    niveauStress?: true
    expositionSoleil?: true
    protectionSolaire?: true
    suffisanceEau?: true
    travailExterieur?: true
    bainChauds?: true
    routineSoins?: true
    changementsRecents?: true
    preferencePeau?: true
    diagnosticVisuelNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientProfile to aggregate.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientProfiles
    **/
    _count?: true | ClientProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientProfileMaxAggregateInputType
  }

  export type GetClientProfileAggregateType<T extends ClientProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateClientProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientProfile[P]>
      : GetScalarType<T[P], AggregateClientProfile[P]>
  }




  export type ClientProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientProfileWhereInput
    orderBy?: ClientProfileOrderByWithAggregationInput | ClientProfileOrderByWithAggregationInput[]
    by: ClientProfileScalarFieldEnum[] | ClientProfileScalarFieldEnum
    having?: ClientProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientProfileCountAggregateInputType | true
    _avg?: ClientProfileAvgAggregateInputType
    _sum?: ClientProfileSumAggregateInputType
    _min?: ClientProfileMinAggregateInputType
    _max?: ClientProfileMaxAggregateInputType
  }

  export type ClientProfileGroupByOutputType = {
    id: string
    nom: string
    prenom: string
    adresse: string
    ville: string
    codePostal: string
    telMaison: string | null
    telBureau: string | null
    telCellulaire: string
    courriel: string
    dateNaissance: Date
    occupation: string | null
    gender: $Enums.Gender
    serviceType: $Enums.ServiceType
    assuranceCouvert: boolean
    autreMaladie: boolean | null
    autreMaladieDetails: string | null
    raisonConsultation: string | null
    diagnosticMedical: boolean | null
    diagnosticMedicalDetails: string | null
    medicaments: boolean | null
    medicamentsDetails: string | null
    accidents: boolean | null
    accidentsDetails: string | null
    operationsChirurgicales: boolean | null
    operationsChirurgicalesDetails: string | null
    traitementsActuels: string | null
    problemesCardiaques: boolean
    problemesCardiaquesDetails: string | null
    maladiesGraves: boolean
    maladiesGravesDetails: string | null
    ortheses: boolean
    orthesesDetails: string | null
    allergies: boolean
    allergiesDetails: string | null
    raideurs: boolean
    arthrose: boolean
    hernieDiscale: boolean
    oedeme: boolean
    tendinite: boolean
    mauxDeTete: boolean
    flatulence: boolean
    troublesCirculatoires: boolean
    hypothyroidie: boolean
    diabete: boolean
    stresse: boolean
    premenopause: boolean
    douleurMusculaire: boolean
    fibromyalgie: boolean
    rhumatisme: boolean
    sciatique: boolean
    bursite: boolean
    migraine: boolean
    diarrhee: boolean
    phlebite: boolean
    hypertension: boolean
    hypoglycemie: boolean
    burnOut: boolean
    menopause: boolean
    inflammationAigue: boolean
    arteriosclerose: boolean
    osteoporose: boolean
    mauxDeDos: boolean
    fatigueDesJambes: boolean
    troublesDigestifs: boolean
    constipation: boolean
    hyperthyroidie: boolean
    hypotension: boolean
    insomnie: boolean
    depressionNerveuse: boolean
    autres: string | null
    lastVisitDate: Date | null
    lastEmailSent: Date | null
    feedbackEmailsSent: number
    promoEmailsSent: number
    zonesDouleur: string[]
    etatPeau: string | null
    etatPores: string | null
    coucheCornee: string | null
    irrigationSanguine: string | null
    impuretes: string | null
    sensibiliteCutanee: string | null
    fumeur: string | null
    niveauStress: string | null
    expositionSoleil: string | null
    protectionSolaire: string | null
    suffisanceEau: string | null
    travailExterieur: string | null
    bainChauds: string | null
    routineSoins: string | null
    changementsRecents: string | null
    preferencePeau: string | null
    diagnosticVisuelNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClientProfileCountAggregateOutputType | null
    _avg: ClientProfileAvgAggregateOutputType | null
    _sum: ClientProfileSumAggregateOutputType | null
    _min: ClientProfileMinAggregateOutputType | null
    _max: ClientProfileMaxAggregateOutputType | null
  }

  type GetClientProfileGroupByPayload<T extends ClientProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ClientProfileGroupByOutputType[P]>
        }
      >
    >


  export type ClientProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    adresse?: boolean
    ville?: boolean
    codePostal?: boolean
    telMaison?: boolean
    telBureau?: boolean
    telCellulaire?: boolean
    courriel?: boolean
    dateNaissance?: boolean
    occupation?: boolean
    gender?: boolean
    serviceType?: boolean
    assuranceCouvert?: boolean
    autreMaladie?: boolean
    autreMaladieDetails?: boolean
    raisonConsultation?: boolean
    diagnosticMedical?: boolean
    diagnosticMedicalDetails?: boolean
    medicaments?: boolean
    medicamentsDetails?: boolean
    accidents?: boolean
    accidentsDetails?: boolean
    operationsChirurgicales?: boolean
    operationsChirurgicalesDetails?: boolean
    traitementsActuels?: boolean
    problemesCardiaques?: boolean
    problemesCardiaquesDetails?: boolean
    maladiesGraves?: boolean
    maladiesGravesDetails?: boolean
    ortheses?: boolean
    orthesesDetails?: boolean
    allergies?: boolean
    allergiesDetails?: boolean
    raideurs?: boolean
    arthrose?: boolean
    hernieDiscale?: boolean
    oedeme?: boolean
    tendinite?: boolean
    mauxDeTete?: boolean
    flatulence?: boolean
    troublesCirculatoires?: boolean
    hypothyroidie?: boolean
    diabete?: boolean
    stresse?: boolean
    premenopause?: boolean
    douleurMusculaire?: boolean
    fibromyalgie?: boolean
    rhumatisme?: boolean
    sciatique?: boolean
    bursite?: boolean
    migraine?: boolean
    diarrhee?: boolean
    phlebite?: boolean
    hypertension?: boolean
    hypoglycemie?: boolean
    burnOut?: boolean
    menopause?: boolean
    inflammationAigue?: boolean
    arteriosclerose?: boolean
    osteoporose?: boolean
    mauxDeDos?: boolean
    fatigueDesJambes?: boolean
    troublesDigestifs?: boolean
    constipation?: boolean
    hyperthyroidie?: boolean
    hypotension?: boolean
    insomnie?: boolean
    depressionNerveuse?: boolean
    autres?: boolean
    lastVisitDate?: boolean
    lastEmailSent?: boolean
    feedbackEmailsSent?: boolean
    promoEmailsSent?: boolean
    zonesDouleur?: boolean
    etatPeau?: boolean
    etatPores?: boolean
    coucheCornee?: boolean
    irrigationSanguine?: boolean
    impuretes?: boolean
    sensibiliteCutanee?: boolean
    fumeur?: boolean
    niveauStress?: boolean
    expositionSoleil?: boolean
    protectionSolaire?: boolean
    suffisanceEau?: boolean
    travailExterieur?: boolean
    bainChauds?: boolean
    routineSoins?: boolean
    changementsRecents?: boolean
    preferencePeau?: boolean
    diagnosticVisuelNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notes?: boolean | ClientProfile$notesArgs<ExtArgs>
    assignments?: boolean | ClientProfile$assignmentsArgs<ExtArgs>
    _count?: boolean | ClientProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientProfile"]>

  export type ClientProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    prenom?: boolean
    adresse?: boolean
    ville?: boolean
    codePostal?: boolean
    telMaison?: boolean
    telBureau?: boolean
    telCellulaire?: boolean
    courriel?: boolean
    dateNaissance?: boolean
    occupation?: boolean
    gender?: boolean
    serviceType?: boolean
    assuranceCouvert?: boolean
    autreMaladie?: boolean
    autreMaladieDetails?: boolean
    raisonConsultation?: boolean
    diagnosticMedical?: boolean
    diagnosticMedicalDetails?: boolean
    medicaments?: boolean
    medicamentsDetails?: boolean
    accidents?: boolean
    accidentsDetails?: boolean
    operationsChirurgicales?: boolean
    operationsChirurgicalesDetails?: boolean
    traitementsActuels?: boolean
    problemesCardiaques?: boolean
    problemesCardiaquesDetails?: boolean
    maladiesGraves?: boolean
    maladiesGravesDetails?: boolean
    ortheses?: boolean
    orthesesDetails?: boolean
    allergies?: boolean
    allergiesDetails?: boolean
    raideurs?: boolean
    arthrose?: boolean
    hernieDiscale?: boolean
    oedeme?: boolean
    tendinite?: boolean
    mauxDeTete?: boolean
    flatulence?: boolean
    troublesCirculatoires?: boolean
    hypothyroidie?: boolean
    diabete?: boolean
    stresse?: boolean
    premenopause?: boolean
    douleurMusculaire?: boolean
    fibromyalgie?: boolean
    rhumatisme?: boolean
    sciatique?: boolean
    bursite?: boolean
    migraine?: boolean
    diarrhee?: boolean
    phlebite?: boolean
    hypertension?: boolean
    hypoglycemie?: boolean
    burnOut?: boolean
    menopause?: boolean
    inflammationAigue?: boolean
    arteriosclerose?: boolean
    osteoporose?: boolean
    mauxDeDos?: boolean
    fatigueDesJambes?: boolean
    troublesDigestifs?: boolean
    constipation?: boolean
    hyperthyroidie?: boolean
    hypotension?: boolean
    insomnie?: boolean
    depressionNerveuse?: boolean
    autres?: boolean
    lastVisitDate?: boolean
    lastEmailSent?: boolean
    feedbackEmailsSent?: boolean
    promoEmailsSent?: boolean
    zonesDouleur?: boolean
    etatPeau?: boolean
    etatPores?: boolean
    coucheCornee?: boolean
    irrigationSanguine?: boolean
    impuretes?: boolean
    sensibiliteCutanee?: boolean
    fumeur?: boolean
    niveauStress?: boolean
    expositionSoleil?: boolean
    protectionSolaire?: boolean
    suffisanceEau?: boolean
    travailExterieur?: boolean
    bainChauds?: boolean
    routineSoins?: boolean
    changementsRecents?: boolean
    preferencePeau?: boolean
    diagnosticVisuelNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["clientProfile"]>

  export type ClientProfileSelectScalar = {
    id?: boolean
    nom?: boolean
    prenom?: boolean
    adresse?: boolean
    ville?: boolean
    codePostal?: boolean
    telMaison?: boolean
    telBureau?: boolean
    telCellulaire?: boolean
    courriel?: boolean
    dateNaissance?: boolean
    occupation?: boolean
    gender?: boolean
    serviceType?: boolean
    assuranceCouvert?: boolean
    autreMaladie?: boolean
    autreMaladieDetails?: boolean
    raisonConsultation?: boolean
    diagnosticMedical?: boolean
    diagnosticMedicalDetails?: boolean
    medicaments?: boolean
    medicamentsDetails?: boolean
    accidents?: boolean
    accidentsDetails?: boolean
    operationsChirurgicales?: boolean
    operationsChirurgicalesDetails?: boolean
    traitementsActuels?: boolean
    problemesCardiaques?: boolean
    problemesCardiaquesDetails?: boolean
    maladiesGraves?: boolean
    maladiesGravesDetails?: boolean
    ortheses?: boolean
    orthesesDetails?: boolean
    allergies?: boolean
    allergiesDetails?: boolean
    raideurs?: boolean
    arthrose?: boolean
    hernieDiscale?: boolean
    oedeme?: boolean
    tendinite?: boolean
    mauxDeTete?: boolean
    flatulence?: boolean
    troublesCirculatoires?: boolean
    hypothyroidie?: boolean
    diabete?: boolean
    stresse?: boolean
    premenopause?: boolean
    douleurMusculaire?: boolean
    fibromyalgie?: boolean
    rhumatisme?: boolean
    sciatique?: boolean
    bursite?: boolean
    migraine?: boolean
    diarrhee?: boolean
    phlebite?: boolean
    hypertension?: boolean
    hypoglycemie?: boolean
    burnOut?: boolean
    menopause?: boolean
    inflammationAigue?: boolean
    arteriosclerose?: boolean
    osteoporose?: boolean
    mauxDeDos?: boolean
    fatigueDesJambes?: boolean
    troublesDigestifs?: boolean
    constipation?: boolean
    hyperthyroidie?: boolean
    hypotension?: boolean
    insomnie?: boolean
    depressionNerveuse?: boolean
    autres?: boolean
    lastVisitDate?: boolean
    lastEmailSent?: boolean
    feedbackEmailsSent?: boolean
    promoEmailsSent?: boolean
    zonesDouleur?: boolean
    etatPeau?: boolean
    etatPores?: boolean
    coucheCornee?: boolean
    irrigationSanguine?: boolean
    impuretes?: boolean
    sensibiliteCutanee?: boolean
    fumeur?: boolean
    niveauStress?: boolean
    expositionSoleil?: boolean
    protectionSolaire?: boolean
    suffisanceEau?: boolean
    travailExterieur?: boolean
    bainChauds?: boolean
    routineSoins?: boolean
    changementsRecents?: boolean
    preferencePeau?: boolean
    diagnosticVisuelNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | ClientProfile$notesArgs<ExtArgs>
    assignments?: boolean | ClientProfile$assignmentsArgs<ExtArgs>
    _count?: boolean | ClientProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientProfile"
    objects: {
      notes: Prisma.$NotePayload<ExtArgs>[]
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      prenom: string
      adresse: string
      ville: string
      codePostal: string
      telMaison: string | null
      telBureau: string | null
      telCellulaire: string
      courriel: string
      dateNaissance: Date
      occupation: string | null
      gender: $Enums.Gender
      serviceType: $Enums.ServiceType
      assuranceCouvert: boolean
      autreMaladie: boolean | null
      autreMaladieDetails: string | null
      raisonConsultation: string | null
      diagnosticMedical: boolean | null
      diagnosticMedicalDetails: string | null
      medicaments: boolean | null
      medicamentsDetails: string | null
      accidents: boolean | null
      accidentsDetails: string | null
      operationsChirurgicales: boolean | null
      operationsChirurgicalesDetails: string | null
      traitementsActuels: string | null
      problemesCardiaques: boolean
      problemesCardiaquesDetails: string | null
      maladiesGraves: boolean
      maladiesGravesDetails: string | null
      ortheses: boolean
      orthesesDetails: string | null
      allergies: boolean
      allergiesDetails: string | null
      raideurs: boolean
      arthrose: boolean
      hernieDiscale: boolean
      oedeme: boolean
      tendinite: boolean
      mauxDeTete: boolean
      flatulence: boolean
      troublesCirculatoires: boolean
      hypothyroidie: boolean
      diabete: boolean
      stresse: boolean
      premenopause: boolean
      douleurMusculaire: boolean
      fibromyalgie: boolean
      rhumatisme: boolean
      sciatique: boolean
      bursite: boolean
      migraine: boolean
      diarrhee: boolean
      phlebite: boolean
      hypertension: boolean
      hypoglycemie: boolean
      burnOut: boolean
      menopause: boolean
      inflammationAigue: boolean
      arteriosclerose: boolean
      osteoporose: boolean
      mauxDeDos: boolean
      fatigueDesJambes: boolean
      troublesDigestifs: boolean
      constipation: boolean
      hyperthyroidie: boolean
      hypotension: boolean
      insomnie: boolean
      depressionNerveuse: boolean
      autres: string | null
      lastVisitDate: Date | null
      lastEmailSent: Date | null
      feedbackEmailsSent: number
      promoEmailsSent: number
      zonesDouleur: string[]
      etatPeau: string | null
      etatPores: string | null
      coucheCornee: string | null
      irrigationSanguine: string | null
      impuretes: string | null
      sensibiliteCutanee: string | null
      fumeur: string | null
      niveauStress: string | null
      expositionSoleil: string | null
      protectionSolaire: string | null
      suffisanceEau: string | null
      travailExterieur: string | null
      bainChauds: string | null
      routineSoins: string | null
      changementsRecents: string | null
      preferencePeau: string | null
      diagnosticVisuelNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientProfile"]>
    composites: {}
  }

  type ClientProfileGetPayload<S extends boolean | null | undefined | ClientProfileDefaultArgs> = $Result.GetResult<Prisma.$ClientProfilePayload, S>

  type ClientProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientProfileCountAggregateInputType | true
    }

  export interface ClientProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientProfile'], meta: { name: 'ClientProfile' } }
    /**
     * Find zero or one ClientProfile that matches the filter.
     * @param {ClientProfileFindUniqueArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientProfileFindUniqueArgs>(args: SelectSubset<T, ClientProfileFindUniqueArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClientProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientProfileFindUniqueOrThrowArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClientProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindFirstArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientProfileFindFirstArgs>(args?: SelectSubset<T, ClientProfileFindFirstArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClientProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindFirstOrThrowArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClientProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientProfiles
     * const clientProfiles = await prisma.clientProfile.findMany()
     * 
     * // Get first 10 ClientProfiles
     * const clientProfiles = await prisma.clientProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientProfileWithIdOnly = await prisma.clientProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientProfileFindManyArgs>(args?: SelectSubset<T, ClientProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClientProfile.
     * @param {ClientProfileCreateArgs} args - Arguments to create a ClientProfile.
     * @example
     * // Create one ClientProfile
     * const ClientProfile = await prisma.clientProfile.create({
     *   data: {
     *     // ... data to create a ClientProfile
     *   }
     * })
     * 
     */
    create<T extends ClientProfileCreateArgs>(args: SelectSubset<T, ClientProfileCreateArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClientProfiles.
     * @param {ClientProfileCreateManyArgs} args - Arguments to create many ClientProfiles.
     * @example
     * // Create many ClientProfiles
     * const clientProfile = await prisma.clientProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientProfileCreateManyArgs>(args?: SelectSubset<T, ClientProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientProfiles and returns the data saved in the database.
     * @param {ClientProfileCreateManyAndReturnArgs} args - Arguments to create many ClientProfiles.
     * @example
     * // Create many ClientProfiles
     * const clientProfile = await prisma.clientProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientProfiles and only return the `id`
     * const clientProfileWithIdOnly = await prisma.clientProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClientProfile.
     * @param {ClientProfileDeleteArgs} args - Arguments to delete one ClientProfile.
     * @example
     * // Delete one ClientProfile
     * const ClientProfile = await prisma.clientProfile.delete({
     *   where: {
     *     // ... filter to delete one ClientProfile
     *   }
     * })
     * 
     */
    delete<T extends ClientProfileDeleteArgs>(args: SelectSubset<T, ClientProfileDeleteArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClientProfile.
     * @param {ClientProfileUpdateArgs} args - Arguments to update one ClientProfile.
     * @example
     * // Update one ClientProfile
     * const clientProfile = await prisma.clientProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientProfileUpdateArgs>(args: SelectSubset<T, ClientProfileUpdateArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClientProfiles.
     * @param {ClientProfileDeleteManyArgs} args - Arguments to filter ClientProfiles to delete.
     * @example
     * // Delete a few ClientProfiles
     * const { count } = await prisma.clientProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientProfileDeleteManyArgs>(args?: SelectSubset<T, ClientProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientProfiles
     * const clientProfile = await prisma.clientProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientProfileUpdateManyArgs>(args: SelectSubset<T, ClientProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientProfile.
     * @param {ClientProfileUpsertArgs} args - Arguments to update or create a ClientProfile.
     * @example
     * // Update or create a ClientProfile
     * const clientProfile = await prisma.clientProfile.upsert({
     *   create: {
     *     // ... data to create a ClientProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientProfile we want to update
     *   }
     * })
     */
    upsert<T extends ClientProfileUpsertArgs>(args: SelectSubset<T, ClientProfileUpsertArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileCountArgs} args - Arguments to filter ClientProfiles to count.
     * @example
     * // Count the number of ClientProfiles
     * const count = await prisma.clientProfile.count({
     *   where: {
     *     // ... the filter for the ClientProfiles we want to count
     *   }
     * })
    **/
    count<T extends ClientProfileCountArgs>(
      args?: Subset<T, ClientProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientProfileAggregateArgs>(args: Subset<T, ClientProfileAggregateArgs>): Prisma.PrismaPromise<GetClientProfileAggregateType<T>>

    /**
     * Group by ClientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientProfileGroupByArgs['orderBy'] }
        : { orderBy?: ClientProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientProfile model
   */
  readonly fields: ClientProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notes<T extends ClientProfile$notesArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany"> | Null>
    assignments<T extends ClientProfile$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientProfile model
   */ 
  interface ClientProfileFieldRefs {
    readonly id: FieldRef<"ClientProfile", 'String'>
    readonly nom: FieldRef<"ClientProfile", 'String'>
    readonly prenom: FieldRef<"ClientProfile", 'String'>
    readonly adresse: FieldRef<"ClientProfile", 'String'>
    readonly ville: FieldRef<"ClientProfile", 'String'>
    readonly codePostal: FieldRef<"ClientProfile", 'String'>
    readonly telMaison: FieldRef<"ClientProfile", 'String'>
    readonly telBureau: FieldRef<"ClientProfile", 'String'>
    readonly telCellulaire: FieldRef<"ClientProfile", 'String'>
    readonly courriel: FieldRef<"ClientProfile", 'String'>
    readonly dateNaissance: FieldRef<"ClientProfile", 'DateTime'>
    readonly occupation: FieldRef<"ClientProfile", 'String'>
    readonly gender: FieldRef<"ClientProfile", 'Gender'>
    readonly serviceType: FieldRef<"ClientProfile", 'ServiceType'>
    readonly assuranceCouvert: FieldRef<"ClientProfile", 'Boolean'>
    readonly autreMaladie: FieldRef<"ClientProfile", 'Boolean'>
    readonly autreMaladieDetails: FieldRef<"ClientProfile", 'String'>
    readonly raisonConsultation: FieldRef<"ClientProfile", 'String'>
    readonly diagnosticMedical: FieldRef<"ClientProfile", 'Boolean'>
    readonly diagnosticMedicalDetails: FieldRef<"ClientProfile", 'String'>
    readonly medicaments: FieldRef<"ClientProfile", 'Boolean'>
    readonly medicamentsDetails: FieldRef<"ClientProfile", 'String'>
    readonly accidents: FieldRef<"ClientProfile", 'Boolean'>
    readonly accidentsDetails: FieldRef<"ClientProfile", 'String'>
    readonly operationsChirurgicales: FieldRef<"ClientProfile", 'Boolean'>
    readonly operationsChirurgicalesDetails: FieldRef<"ClientProfile", 'String'>
    readonly traitementsActuels: FieldRef<"ClientProfile", 'String'>
    readonly problemesCardiaques: FieldRef<"ClientProfile", 'Boolean'>
    readonly problemesCardiaquesDetails: FieldRef<"ClientProfile", 'String'>
    readonly maladiesGraves: FieldRef<"ClientProfile", 'Boolean'>
    readonly maladiesGravesDetails: FieldRef<"ClientProfile", 'String'>
    readonly ortheses: FieldRef<"ClientProfile", 'Boolean'>
    readonly orthesesDetails: FieldRef<"ClientProfile", 'String'>
    readonly allergies: FieldRef<"ClientProfile", 'Boolean'>
    readonly allergiesDetails: FieldRef<"ClientProfile", 'String'>
    readonly raideurs: FieldRef<"ClientProfile", 'Boolean'>
    readonly arthrose: FieldRef<"ClientProfile", 'Boolean'>
    readonly hernieDiscale: FieldRef<"ClientProfile", 'Boolean'>
    readonly oedeme: FieldRef<"ClientProfile", 'Boolean'>
    readonly tendinite: FieldRef<"ClientProfile", 'Boolean'>
    readonly mauxDeTete: FieldRef<"ClientProfile", 'Boolean'>
    readonly flatulence: FieldRef<"ClientProfile", 'Boolean'>
    readonly troublesCirculatoires: FieldRef<"ClientProfile", 'Boolean'>
    readonly hypothyroidie: FieldRef<"ClientProfile", 'Boolean'>
    readonly diabete: FieldRef<"ClientProfile", 'Boolean'>
    readonly stresse: FieldRef<"ClientProfile", 'Boolean'>
    readonly premenopause: FieldRef<"ClientProfile", 'Boolean'>
    readonly douleurMusculaire: FieldRef<"ClientProfile", 'Boolean'>
    readonly fibromyalgie: FieldRef<"ClientProfile", 'Boolean'>
    readonly rhumatisme: FieldRef<"ClientProfile", 'Boolean'>
    readonly sciatique: FieldRef<"ClientProfile", 'Boolean'>
    readonly bursite: FieldRef<"ClientProfile", 'Boolean'>
    readonly migraine: FieldRef<"ClientProfile", 'Boolean'>
    readonly diarrhee: FieldRef<"ClientProfile", 'Boolean'>
    readonly phlebite: FieldRef<"ClientProfile", 'Boolean'>
    readonly hypertension: FieldRef<"ClientProfile", 'Boolean'>
    readonly hypoglycemie: FieldRef<"ClientProfile", 'Boolean'>
    readonly burnOut: FieldRef<"ClientProfile", 'Boolean'>
    readonly menopause: FieldRef<"ClientProfile", 'Boolean'>
    readonly inflammationAigue: FieldRef<"ClientProfile", 'Boolean'>
    readonly arteriosclerose: FieldRef<"ClientProfile", 'Boolean'>
    readonly osteoporose: FieldRef<"ClientProfile", 'Boolean'>
    readonly mauxDeDos: FieldRef<"ClientProfile", 'Boolean'>
    readonly fatigueDesJambes: FieldRef<"ClientProfile", 'Boolean'>
    readonly troublesDigestifs: FieldRef<"ClientProfile", 'Boolean'>
    readonly constipation: FieldRef<"ClientProfile", 'Boolean'>
    readonly hyperthyroidie: FieldRef<"ClientProfile", 'Boolean'>
    readonly hypotension: FieldRef<"ClientProfile", 'Boolean'>
    readonly insomnie: FieldRef<"ClientProfile", 'Boolean'>
    readonly depressionNerveuse: FieldRef<"ClientProfile", 'Boolean'>
    readonly autres: FieldRef<"ClientProfile", 'String'>
    readonly lastVisitDate: FieldRef<"ClientProfile", 'DateTime'>
    readonly lastEmailSent: FieldRef<"ClientProfile", 'DateTime'>
    readonly feedbackEmailsSent: FieldRef<"ClientProfile", 'Int'>
    readonly promoEmailsSent: FieldRef<"ClientProfile", 'Int'>
    readonly zonesDouleur: FieldRef<"ClientProfile", 'String[]'>
    readonly etatPeau: FieldRef<"ClientProfile", 'String'>
    readonly etatPores: FieldRef<"ClientProfile", 'String'>
    readonly coucheCornee: FieldRef<"ClientProfile", 'String'>
    readonly irrigationSanguine: FieldRef<"ClientProfile", 'String'>
    readonly impuretes: FieldRef<"ClientProfile", 'String'>
    readonly sensibiliteCutanee: FieldRef<"ClientProfile", 'String'>
    readonly fumeur: FieldRef<"ClientProfile", 'String'>
    readonly niveauStress: FieldRef<"ClientProfile", 'String'>
    readonly expositionSoleil: FieldRef<"ClientProfile", 'String'>
    readonly protectionSolaire: FieldRef<"ClientProfile", 'String'>
    readonly suffisanceEau: FieldRef<"ClientProfile", 'String'>
    readonly travailExterieur: FieldRef<"ClientProfile", 'String'>
    readonly bainChauds: FieldRef<"ClientProfile", 'String'>
    readonly routineSoins: FieldRef<"ClientProfile", 'String'>
    readonly changementsRecents: FieldRef<"ClientProfile", 'String'>
    readonly preferencePeau: FieldRef<"ClientProfile", 'String'>
    readonly diagnosticVisuelNotes: FieldRef<"ClientProfile", 'String'>
    readonly createdAt: FieldRef<"ClientProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientProfile findUnique
   */
  export type ClientProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile findUniqueOrThrow
   */
  export type ClientProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile findFirst
   */
  export type ClientProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientProfiles.
     */
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile findFirstOrThrow
   */
  export type ClientProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientProfiles.
     */
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile findMany
   */
  export type ClientProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfiles to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile create
   */
  export type ClientProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientProfile.
     */
    data: XOR<ClientProfileCreateInput, ClientProfileUncheckedCreateInput>
  }

  /**
   * ClientProfile createMany
   */
  export type ClientProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientProfiles.
     */
    data: ClientProfileCreateManyInput | ClientProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientProfile createManyAndReturn
   */
  export type ClientProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClientProfiles.
     */
    data: ClientProfileCreateManyInput | ClientProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientProfile update
   */
  export type ClientProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientProfile.
     */
    data: XOR<ClientProfileUpdateInput, ClientProfileUncheckedUpdateInput>
    /**
     * Choose, which ClientProfile to update.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile updateMany
   */
  export type ClientProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientProfiles.
     */
    data: XOR<ClientProfileUpdateManyMutationInput, ClientProfileUncheckedUpdateManyInput>
    /**
     * Filter which ClientProfiles to update
     */
    where?: ClientProfileWhereInput
  }

  /**
   * ClientProfile upsert
   */
  export type ClientProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientProfile to update in case it exists.
     */
    where: ClientProfileWhereUniqueInput
    /**
     * In case the ClientProfile found by the `where` argument doesn't exist, create a new ClientProfile with this data.
     */
    create: XOR<ClientProfileCreateInput, ClientProfileUncheckedCreateInput>
    /**
     * In case the ClientProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientProfileUpdateInput, ClientProfileUncheckedUpdateInput>
  }

  /**
   * ClientProfile delete
   */
  export type ClientProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter which ClientProfile to delete.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile deleteMany
   */
  export type ClientProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientProfiles to delete
     */
    where?: ClientProfileWhereInput
  }

  /**
   * ClientProfile.notes
   */
  export type ClientProfile$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * ClientProfile.assignments
   */
  export type ClientProfile$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * ClientProfile without action
   */
  export type ClientProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
  }


  /**
   * Model ClientFeedback
   */

  export type AggregateClientFeedback = {
    _count: ClientFeedbackCountAggregateOutputType | null
    _avg: ClientFeedbackAvgAggregateOutputType | null
    _sum: ClientFeedbackSumAggregateOutputType | null
    _min: ClientFeedbackMinAggregateOutputType | null
    _max: ClientFeedbackMaxAggregateOutputType | null
  }

  export type ClientFeedbackAvgAggregateOutputType = {
    rating: number | null
  }

  export type ClientFeedbackSumAggregateOutputType = {
    rating: number | null
  }

  export type ClientFeedbackMinAggregateOutputType = {
    id: string | null
    token: string | null
    noteId: string | null
    clientEmail: string | null
    clientName: string | null
    rating: number | null
    comment: string | null
    wouldReturn: boolean | null
    wouldRecommend: boolean | null
    hasResponded: boolean | null
    respondedAt: Date | null
    createdAt: Date | null
  }

  export type ClientFeedbackMaxAggregateOutputType = {
    id: string | null
    token: string | null
    noteId: string | null
    clientEmail: string | null
    clientName: string | null
    rating: number | null
    comment: string | null
    wouldReturn: boolean | null
    wouldRecommend: boolean | null
    hasResponded: boolean | null
    respondedAt: Date | null
    createdAt: Date | null
  }

  export type ClientFeedbackCountAggregateOutputType = {
    id: number
    token: number
    noteId: number
    clientEmail: number
    clientName: number
    rating: number
    comment: number
    wouldReturn: number
    wouldRecommend: number
    hasResponded: number
    respondedAt: number
    createdAt: number
    _all: number
  }


  export type ClientFeedbackAvgAggregateInputType = {
    rating?: true
  }

  export type ClientFeedbackSumAggregateInputType = {
    rating?: true
  }

  export type ClientFeedbackMinAggregateInputType = {
    id?: true
    token?: true
    noteId?: true
    clientEmail?: true
    clientName?: true
    rating?: true
    comment?: true
    wouldReturn?: true
    wouldRecommend?: true
    hasResponded?: true
    respondedAt?: true
    createdAt?: true
  }

  export type ClientFeedbackMaxAggregateInputType = {
    id?: true
    token?: true
    noteId?: true
    clientEmail?: true
    clientName?: true
    rating?: true
    comment?: true
    wouldReturn?: true
    wouldRecommend?: true
    hasResponded?: true
    respondedAt?: true
    createdAt?: true
  }

  export type ClientFeedbackCountAggregateInputType = {
    id?: true
    token?: true
    noteId?: true
    clientEmail?: true
    clientName?: true
    rating?: true
    comment?: true
    wouldReturn?: true
    wouldRecommend?: true
    hasResponded?: true
    respondedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ClientFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientFeedback to aggregate.
     */
    where?: ClientFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientFeedbacks to fetch.
     */
    orderBy?: ClientFeedbackOrderByWithRelationInput | ClientFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientFeedbacks
    **/
    _count?: true | ClientFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientFeedbackMaxAggregateInputType
  }

  export type GetClientFeedbackAggregateType<T extends ClientFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateClientFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientFeedback[P]>
      : GetScalarType<T[P], AggregateClientFeedback[P]>
  }




  export type ClientFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientFeedbackWhereInput
    orderBy?: ClientFeedbackOrderByWithAggregationInput | ClientFeedbackOrderByWithAggregationInput[]
    by: ClientFeedbackScalarFieldEnum[] | ClientFeedbackScalarFieldEnum
    having?: ClientFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientFeedbackCountAggregateInputType | true
    _avg?: ClientFeedbackAvgAggregateInputType
    _sum?: ClientFeedbackSumAggregateInputType
    _min?: ClientFeedbackMinAggregateInputType
    _max?: ClientFeedbackMaxAggregateInputType
  }

  export type ClientFeedbackGroupByOutputType = {
    id: string
    token: string
    noteId: string
    clientEmail: string | null
    clientName: string | null
    rating: number | null
    comment: string | null
    wouldReturn: boolean | null
    wouldRecommend: boolean | null
    hasResponded: boolean
    respondedAt: Date | null
    createdAt: Date
    _count: ClientFeedbackCountAggregateOutputType | null
    _avg: ClientFeedbackAvgAggregateOutputType | null
    _sum: ClientFeedbackSumAggregateOutputType | null
    _min: ClientFeedbackMinAggregateOutputType | null
    _max: ClientFeedbackMaxAggregateOutputType | null
  }

  type GetClientFeedbackGroupByPayload<T extends ClientFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], ClientFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type ClientFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    noteId?: boolean
    clientEmail?: boolean
    clientName?: boolean
    rating?: boolean
    comment?: boolean
    wouldReturn?: boolean
    wouldRecommend?: boolean
    hasResponded?: boolean
    respondedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["clientFeedback"]>

  export type ClientFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    noteId?: boolean
    clientEmail?: boolean
    clientName?: boolean
    rating?: boolean
    comment?: boolean
    wouldReturn?: boolean
    wouldRecommend?: boolean
    hasResponded?: boolean
    respondedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["clientFeedback"]>

  export type ClientFeedbackSelectScalar = {
    id?: boolean
    token?: boolean
    noteId?: boolean
    clientEmail?: boolean
    clientName?: boolean
    rating?: boolean
    comment?: boolean
    wouldReturn?: boolean
    wouldRecommend?: boolean
    hasResponded?: boolean
    respondedAt?: boolean
    createdAt?: boolean
  }


  export type $ClientFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientFeedback"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      noteId: string
      clientEmail: string | null
      clientName: string | null
      rating: number | null
      comment: string | null
      wouldReturn: boolean | null
      wouldRecommend: boolean | null
      hasResponded: boolean
      respondedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["clientFeedback"]>
    composites: {}
  }

  type ClientFeedbackGetPayload<S extends boolean | null | undefined | ClientFeedbackDefaultArgs> = $Result.GetResult<Prisma.$ClientFeedbackPayload, S>

  type ClientFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientFeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientFeedbackCountAggregateInputType | true
    }

  export interface ClientFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientFeedback'], meta: { name: 'ClientFeedback' } }
    /**
     * Find zero or one ClientFeedback that matches the filter.
     * @param {ClientFeedbackFindUniqueArgs} args - Arguments to find a ClientFeedback
     * @example
     * // Get one ClientFeedback
     * const clientFeedback = await prisma.clientFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFeedbackFindUniqueArgs>(args: SelectSubset<T, ClientFeedbackFindUniqueArgs<ExtArgs>>): Prisma__ClientFeedbackClient<$Result.GetResult<Prisma.$ClientFeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClientFeedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientFeedbackFindUniqueOrThrowArgs} args - Arguments to find a ClientFeedback
     * @example
     * // Get one ClientFeedback
     * const clientFeedback = await prisma.clientFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientFeedbackClient<$Result.GetResult<Prisma.$ClientFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClientFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFeedbackFindFirstArgs} args - Arguments to find a ClientFeedback
     * @example
     * // Get one ClientFeedback
     * const clientFeedback = await prisma.clientFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFeedbackFindFirstArgs>(args?: SelectSubset<T, ClientFeedbackFindFirstArgs<ExtArgs>>): Prisma__ClientFeedbackClient<$Result.GetResult<Prisma.$ClientFeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClientFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFeedbackFindFirstOrThrowArgs} args - Arguments to find a ClientFeedback
     * @example
     * // Get one ClientFeedback
     * const clientFeedback = await prisma.clientFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientFeedbackClient<$Result.GetResult<Prisma.$ClientFeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClientFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientFeedbacks
     * const clientFeedbacks = await prisma.clientFeedback.findMany()
     * 
     * // Get first 10 ClientFeedbacks
     * const clientFeedbacks = await prisma.clientFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientFeedbackWithIdOnly = await prisma.clientFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFeedbackFindManyArgs>(args?: SelectSubset<T, ClientFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientFeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClientFeedback.
     * @param {ClientFeedbackCreateArgs} args - Arguments to create a ClientFeedback.
     * @example
     * // Create one ClientFeedback
     * const ClientFeedback = await prisma.clientFeedback.create({
     *   data: {
     *     // ... data to create a ClientFeedback
     *   }
     * })
     * 
     */
    create<T extends ClientFeedbackCreateArgs>(args: SelectSubset<T, ClientFeedbackCreateArgs<ExtArgs>>): Prisma__ClientFeedbackClient<$Result.GetResult<Prisma.$ClientFeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClientFeedbacks.
     * @param {ClientFeedbackCreateManyArgs} args - Arguments to create many ClientFeedbacks.
     * @example
     * // Create many ClientFeedbacks
     * const clientFeedback = await prisma.clientFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientFeedbackCreateManyArgs>(args?: SelectSubset<T, ClientFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientFeedbacks and returns the data saved in the database.
     * @param {ClientFeedbackCreateManyAndReturnArgs} args - Arguments to create many ClientFeedbacks.
     * @example
     * // Create many ClientFeedbacks
     * const clientFeedback = await prisma.clientFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientFeedbacks and only return the `id`
     * const clientFeedbackWithIdOnly = await prisma.clientFeedback.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientFeedbackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClientFeedback.
     * @param {ClientFeedbackDeleteArgs} args - Arguments to delete one ClientFeedback.
     * @example
     * // Delete one ClientFeedback
     * const ClientFeedback = await prisma.clientFeedback.delete({
     *   where: {
     *     // ... filter to delete one ClientFeedback
     *   }
     * })
     * 
     */
    delete<T extends ClientFeedbackDeleteArgs>(args: SelectSubset<T, ClientFeedbackDeleteArgs<ExtArgs>>): Prisma__ClientFeedbackClient<$Result.GetResult<Prisma.$ClientFeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClientFeedback.
     * @param {ClientFeedbackUpdateArgs} args - Arguments to update one ClientFeedback.
     * @example
     * // Update one ClientFeedback
     * const clientFeedback = await prisma.clientFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientFeedbackUpdateArgs>(args: SelectSubset<T, ClientFeedbackUpdateArgs<ExtArgs>>): Prisma__ClientFeedbackClient<$Result.GetResult<Prisma.$ClientFeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClientFeedbacks.
     * @param {ClientFeedbackDeleteManyArgs} args - Arguments to filter ClientFeedbacks to delete.
     * @example
     * // Delete a few ClientFeedbacks
     * const { count } = await prisma.clientFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientFeedbackDeleteManyArgs>(args?: SelectSubset<T, ClientFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientFeedbacks
     * const clientFeedback = await prisma.clientFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientFeedbackUpdateManyArgs>(args: SelectSubset<T, ClientFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientFeedback.
     * @param {ClientFeedbackUpsertArgs} args - Arguments to update or create a ClientFeedback.
     * @example
     * // Update or create a ClientFeedback
     * const clientFeedback = await prisma.clientFeedback.upsert({
     *   create: {
     *     // ... data to create a ClientFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientFeedback we want to update
     *   }
     * })
     */
    upsert<T extends ClientFeedbackUpsertArgs>(args: SelectSubset<T, ClientFeedbackUpsertArgs<ExtArgs>>): Prisma__ClientFeedbackClient<$Result.GetResult<Prisma.$ClientFeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClientFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFeedbackCountArgs} args - Arguments to filter ClientFeedbacks to count.
     * @example
     * // Count the number of ClientFeedbacks
     * const count = await prisma.clientFeedback.count({
     *   where: {
     *     // ... the filter for the ClientFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends ClientFeedbackCountArgs>(
      args?: Subset<T, ClientFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientFeedbackAggregateArgs>(args: Subset<T, ClientFeedbackAggregateArgs>): Prisma.PrismaPromise<GetClientFeedbackAggregateType<T>>

    /**
     * Group by ClientFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: ClientFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientFeedback model
   */
  readonly fields: ClientFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientFeedback model
   */ 
  interface ClientFeedbackFieldRefs {
    readonly id: FieldRef<"ClientFeedback", 'String'>
    readonly token: FieldRef<"ClientFeedback", 'String'>
    readonly noteId: FieldRef<"ClientFeedback", 'String'>
    readonly clientEmail: FieldRef<"ClientFeedback", 'String'>
    readonly clientName: FieldRef<"ClientFeedback", 'String'>
    readonly rating: FieldRef<"ClientFeedback", 'Int'>
    readonly comment: FieldRef<"ClientFeedback", 'String'>
    readonly wouldReturn: FieldRef<"ClientFeedback", 'Boolean'>
    readonly wouldRecommend: FieldRef<"ClientFeedback", 'Boolean'>
    readonly hasResponded: FieldRef<"ClientFeedback", 'Boolean'>
    readonly respondedAt: FieldRef<"ClientFeedback", 'DateTime'>
    readonly createdAt: FieldRef<"ClientFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientFeedback findUnique
   */
  export type ClientFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientFeedback
     */
    select?: ClientFeedbackSelect<ExtArgs> | null
    /**
     * Filter, which ClientFeedback to fetch.
     */
    where: ClientFeedbackWhereUniqueInput
  }

  /**
   * ClientFeedback findUniqueOrThrow
   */
  export type ClientFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientFeedback
     */
    select?: ClientFeedbackSelect<ExtArgs> | null
    /**
     * Filter, which ClientFeedback to fetch.
     */
    where: ClientFeedbackWhereUniqueInput
  }

  /**
   * ClientFeedback findFirst
   */
  export type ClientFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientFeedback
     */
    select?: ClientFeedbackSelect<ExtArgs> | null
    /**
     * Filter, which ClientFeedback to fetch.
     */
    where?: ClientFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientFeedbacks to fetch.
     */
    orderBy?: ClientFeedbackOrderByWithRelationInput | ClientFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientFeedbacks.
     */
    cursor?: ClientFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientFeedbacks.
     */
    distinct?: ClientFeedbackScalarFieldEnum | ClientFeedbackScalarFieldEnum[]
  }

  /**
   * ClientFeedback findFirstOrThrow
   */
  export type ClientFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientFeedback
     */
    select?: ClientFeedbackSelect<ExtArgs> | null
    /**
     * Filter, which ClientFeedback to fetch.
     */
    where?: ClientFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientFeedbacks to fetch.
     */
    orderBy?: ClientFeedbackOrderByWithRelationInput | ClientFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientFeedbacks.
     */
    cursor?: ClientFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientFeedbacks.
     */
    distinct?: ClientFeedbackScalarFieldEnum | ClientFeedbackScalarFieldEnum[]
  }

  /**
   * ClientFeedback findMany
   */
  export type ClientFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientFeedback
     */
    select?: ClientFeedbackSelect<ExtArgs> | null
    /**
     * Filter, which ClientFeedbacks to fetch.
     */
    where?: ClientFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientFeedbacks to fetch.
     */
    orderBy?: ClientFeedbackOrderByWithRelationInput | ClientFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientFeedbacks.
     */
    cursor?: ClientFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientFeedbacks.
     */
    skip?: number
    distinct?: ClientFeedbackScalarFieldEnum | ClientFeedbackScalarFieldEnum[]
  }

  /**
   * ClientFeedback create
   */
  export type ClientFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientFeedback
     */
    select?: ClientFeedbackSelect<ExtArgs> | null
    /**
     * The data needed to create a ClientFeedback.
     */
    data: XOR<ClientFeedbackCreateInput, ClientFeedbackUncheckedCreateInput>
  }

  /**
   * ClientFeedback createMany
   */
  export type ClientFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientFeedbacks.
     */
    data: ClientFeedbackCreateManyInput | ClientFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientFeedback createManyAndReturn
   */
  export type ClientFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientFeedback
     */
    select?: ClientFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClientFeedbacks.
     */
    data: ClientFeedbackCreateManyInput | ClientFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientFeedback update
   */
  export type ClientFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientFeedback
     */
    select?: ClientFeedbackSelect<ExtArgs> | null
    /**
     * The data needed to update a ClientFeedback.
     */
    data: XOR<ClientFeedbackUpdateInput, ClientFeedbackUncheckedUpdateInput>
    /**
     * Choose, which ClientFeedback to update.
     */
    where: ClientFeedbackWhereUniqueInput
  }

  /**
   * ClientFeedback updateMany
   */
  export type ClientFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientFeedbacks.
     */
    data: XOR<ClientFeedbackUpdateManyMutationInput, ClientFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which ClientFeedbacks to update
     */
    where?: ClientFeedbackWhereInput
  }

  /**
   * ClientFeedback upsert
   */
  export type ClientFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientFeedback
     */
    select?: ClientFeedbackSelect<ExtArgs> | null
    /**
     * The filter to search for the ClientFeedback to update in case it exists.
     */
    where: ClientFeedbackWhereUniqueInput
    /**
     * In case the ClientFeedback found by the `where` argument doesn't exist, create a new ClientFeedback with this data.
     */
    create: XOR<ClientFeedbackCreateInput, ClientFeedbackUncheckedCreateInput>
    /**
     * In case the ClientFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientFeedbackUpdateInput, ClientFeedbackUncheckedUpdateInput>
  }

  /**
   * ClientFeedback delete
   */
  export type ClientFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientFeedback
     */
    select?: ClientFeedbackSelect<ExtArgs> | null
    /**
     * Filter which ClientFeedback to delete.
     */
    where: ClientFeedbackWhereUniqueInput
  }

  /**
   * ClientFeedback deleteMany
   */
  export type ClientFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientFeedbacks to delete
     */
    where?: ClientFeedbackWhereInput
  }

  /**
   * ClientFeedback without action
   */
  export type ClientFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientFeedback
     */
    select?: ClientFeedbackSelect<ExtArgs> | null
  }


  /**
   * Model EmailLog
   */

  export type AggregateEmailLog = {
    _count: EmailLogCountAggregateOutputType | null
    _min: EmailLogMinAggregateOutputType | null
    _max: EmailLogMaxAggregateOutputType | null
  }

  export type EmailLogMinAggregateOutputType = {
    id: string | null
    type: string | null
    clientEmail: string | null
    clientName: string | null
    subject: string | null
    htmlContent: string | null
    noteId: string | null
    promotionId: string | null
    sentAt: Date | null
    opened: boolean | null
    clicked: boolean | null
  }

  export type EmailLogMaxAggregateOutputType = {
    id: string | null
    type: string | null
    clientEmail: string | null
    clientName: string | null
    subject: string | null
    htmlContent: string | null
    noteId: string | null
    promotionId: string | null
    sentAt: Date | null
    opened: boolean | null
    clicked: boolean | null
  }

  export type EmailLogCountAggregateOutputType = {
    id: number
    type: number
    clientEmail: number
    clientName: number
    subject: number
    htmlContent: number
    noteId: number
    promotionId: number
    sentAt: number
    opened: number
    clicked: number
    _all: number
  }


  export type EmailLogMinAggregateInputType = {
    id?: true
    type?: true
    clientEmail?: true
    clientName?: true
    subject?: true
    htmlContent?: true
    noteId?: true
    promotionId?: true
    sentAt?: true
    opened?: true
    clicked?: true
  }

  export type EmailLogMaxAggregateInputType = {
    id?: true
    type?: true
    clientEmail?: true
    clientName?: true
    subject?: true
    htmlContent?: true
    noteId?: true
    promotionId?: true
    sentAt?: true
    opened?: true
    clicked?: true
  }

  export type EmailLogCountAggregateInputType = {
    id?: true
    type?: true
    clientEmail?: true
    clientName?: true
    subject?: true
    htmlContent?: true
    noteId?: true
    promotionId?: true
    sentAt?: true
    opened?: true
    clicked?: true
    _all?: true
  }

  export type EmailLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLog to aggregate.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailLogs
    **/
    _count?: true | EmailLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailLogMaxAggregateInputType
  }

  export type GetEmailLogAggregateType<T extends EmailLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailLog[P]>
      : GetScalarType<T[P], AggregateEmailLog[P]>
  }




  export type EmailLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLogWhereInput
    orderBy?: EmailLogOrderByWithAggregationInput | EmailLogOrderByWithAggregationInput[]
    by: EmailLogScalarFieldEnum[] | EmailLogScalarFieldEnum
    having?: EmailLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailLogCountAggregateInputType | true
    _min?: EmailLogMinAggregateInputType
    _max?: EmailLogMaxAggregateInputType
  }

  export type EmailLogGroupByOutputType = {
    id: string
    type: string
    clientEmail: string
    clientName: string | null
    subject: string
    htmlContent: string
    noteId: string | null
    promotionId: string | null
    sentAt: Date
    opened: boolean
    clicked: boolean
    _count: EmailLogCountAggregateOutputType | null
    _min: EmailLogMinAggregateOutputType | null
    _max: EmailLogMaxAggregateOutputType | null
  }

  type GetEmailLogGroupByPayload<T extends EmailLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailLogGroupByOutputType[P]>
            : GetScalarType<T[P], EmailLogGroupByOutputType[P]>
        }
      >
    >


  export type EmailLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    clientEmail?: boolean
    clientName?: boolean
    subject?: boolean
    htmlContent?: boolean
    noteId?: boolean
    promotionId?: boolean
    sentAt?: boolean
    opened?: boolean
    clicked?: boolean
  }, ExtArgs["result"]["emailLog"]>

  export type EmailLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    clientEmail?: boolean
    clientName?: boolean
    subject?: boolean
    htmlContent?: boolean
    noteId?: boolean
    promotionId?: boolean
    sentAt?: boolean
    opened?: boolean
    clicked?: boolean
  }, ExtArgs["result"]["emailLog"]>

  export type EmailLogSelectScalar = {
    id?: boolean
    type?: boolean
    clientEmail?: boolean
    clientName?: boolean
    subject?: boolean
    htmlContent?: boolean
    noteId?: boolean
    promotionId?: boolean
    sentAt?: boolean
    opened?: boolean
    clicked?: boolean
  }


  export type $EmailLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      clientEmail: string
      clientName: string | null
      subject: string
      htmlContent: string
      noteId: string | null
      promotionId: string | null
      sentAt: Date
      opened: boolean
      clicked: boolean
    }, ExtArgs["result"]["emailLog"]>
    composites: {}
  }

  type EmailLogGetPayload<S extends boolean | null | undefined | EmailLogDefaultArgs> = $Result.GetResult<Prisma.$EmailLogPayload, S>

  type EmailLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailLogCountAggregateInputType | true
    }

  export interface EmailLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailLog'], meta: { name: 'EmailLog' } }
    /**
     * Find zero or one EmailLog that matches the filter.
     * @param {EmailLogFindUniqueArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailLogFindUniqueArgs>(args: SelectSubset<T, EmailLogFindUniqueArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailLogFindUniqueOrThrowArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindFirstArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailLogFindFirstArgs>(args?: SelectSubset<T, EmailLogFindFirstArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindFirstOrThrowArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailLogs
     * const emailLogs = await prisma.emailLog.findMany()
     * 
     * // Get first 10 EmailLogs
     * const emailLogs = await prisma.emailLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailLogWithIdOnly = await prisma.emailLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailLogFindManyArgs>(args?: SelectSubset<T, EmailLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailLog.
     * @param {EmailLogCreateArgs} args - Arguments to create a EmailLog.
     * @example
     * // Create one EmailLog
     * const EmailLog = await prisma.emailLog.create({
     *   data: {
     *     // ... data to create a EmailLog
     *   }
     * })
     * 
     */
    create<T extends EmailLogCreateArgs>(args: SelectSubset<T, EmailLogCreateArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailLogs.
     * @param {EmailLogCreateManyArgs} args - Arguments to create many EmailLogs.
     * @example
     * // Create many EmailLogs
     * const emailLog = await prisma.emailLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailLogCreateManyArgs>(args?: SelectSubset<T, EmailLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailLogs and returns the data saved in the database.
     * @param {EmailLogCreateManyAndReturnArgs} args - Arguments to create many EmailLogs.
     * @example
     * // Create many EmailLogs
     * const emailLog = await prisma.emailLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailLogs and only return the `id`
     * const emailLogWithIdOnly = await prisma.emailLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmailLog.
     * @param {EmailLogDeleteArgs} args - Arguments to delete one EmailLog.
     * @example
     * // Delete one EmailLog
     * const EmailLog = await prisma.emailLog.delete({
     *   where: {
     *     // ... filter to delete one EmailLog
     *   }
     * })
     * 
     */
    delete<T extends EmailLogDeleteArgs>(args: SelectSubset<T, EmailLogDeleteArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailLog.
     * @param {EmailLogUpdateArgs} args - Arguments to update one EmailLog.
     * @example
     * // Update one EmailLog
     * const emailLog = await prisma.emailLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailLogUpdateArgs>(args: SelectSubset<T, EmailLogUpdateArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailLogs.
     * @param {EmailLogDeleteManyArgs} args - Arguments to filter EmailLogs to delete.
     * @example
     * // Delete a few EmailLogs
     * const { count } = await prisma.emailLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailLogDeleteManyArgs>(args?: SelectSubset<T, EmailLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailLogs
     * const emailLog = await prisma.emailLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailLogUpdateManyArgs>(args: SelectSubset<T, EmailLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailLog.
     * @param {EmailLogUpsertArgs} args - Arguments to update or create a EmailLog.
     * @example
     * // Update or create a EmailLog
     * const emailLog = await prisma.emailLog.upsert({
     *   create: {
     *     // ... data to create a EmailLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailLog we want to update
     *   }
     * })
     */
    upsert<T extends EmailLogUpsertArgs>(args: SelectSubset<T, EmailLogUpsertArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogCountArgs} args - Arguments to filter EmailLogs to count.
     * @example
     * // Count the number of EmailLogs
     * const count = await prisma.emailLog.count({
     *   where: {
     *     // ... the filter for the EmailLogs we want to count
     *   }
     * })
    **/
    count<T extends EmailLogCountArgs>(
      args?: Subset<T, EmailLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailLogAggregateArgs>(args: Subset<T, EmailLogAggregateArgs>): Prisma.PrismaPromise<GetEmailLogAggregateType<T>>

    /**
     * Group by EmailLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailLogGroupByArgs['orderBy'] }
        : { orderBy?: EmailLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailLog model
   */
  readonly fields: EmailLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailLog model
   */ 
  interface EmailLogFieldRefs {
    readonly id: FieldRef<"EmailLog", 'String'>
    readonly type: FieldRef<"EmailLog", 'String'>
    readonly clientEmail: FieldRef<"EmailLog", 'String'>
    readonly clientName: FieldRef<"EmailLog", 'String'>
    readonly subject: FieldRef<"EmailLog", 'String'>
    readonly htmlContent: FieldRef<"EmailLog", 'String'>
    readonly noteId: FieldRef<"EmailLog", 'String'>
    readonly promotionId: FieldRef<"EmailLog", 'String'>
    readonly sentAt: FieldRef<"EmailLog", 'DateTime'>
    readonly opened: FieldRef<"EmailLog", 'Boolean'>
    readonly clicked: FieldRef<"EmailLog", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EmailLog findUnique
   */
  export type EmailLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog findUniqueOrThrow
   */
  export type EmailLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog findFirst
   */
  export type EmailLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLogs.
     */
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog findFirstOrThrow
   */
  export type EmailLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLogs.
     */
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog findMany
   */
  export type EmailLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Filter, which EmailLogs to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog create
   */
  export type EmailLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * The data needed to create a EmailLog.
     */
    data: XOR<EmailLogCreateInput, EmailLogUncheckedCreateInput>
  }

  /**
   * EmailLog createMany
   */
  export type EmailLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailLogs.
     */
    data: EmailLogCreateManyInput | EmailLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailLog createManyAndReturn
   */
  export type EmailLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmailLogs.
     */
    data: EmailLogCreateManyInput | EmailLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailLog update
   */
  export type EmailLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * The data needed to update a EmailLog.
     */
    data: XOR<EmailLogUpdateInput, EmailLogUncheckedUpdateInput>
    /**
     * Choose, which EmailLog to update.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog updateMany
   */
  export type EmailLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailLogs.
     */
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyInput>
    /**
     * Filter which EmailLogs to update
     */
    where?: EmailLogWhereInput
  }

  /**
   * EmailLog upsert
   */
  export type EmailLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * The filter to search for the EmailLog to update in case it exists.
     */
    where: EmailLogWhereUniqueInput
    /**
     * In case the EmailLog found by the `where` argument doesn't exist, create a new EmailLog with this data.
     */
    create: XOR<EmailLogCreateInput, EmailLogUncheckedCreateInput>
    /**
     * In case the EmailLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailLogUpdateInput, EmailLogUncheckedUpdateInput>
  }

  /**
   * EmailLog delete
   */
  export type EmailLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Filter which EmailLog to delete.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog deleteMany
   */
  export type EmailLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLogs to delete
     */
    where?: EmailLogWhereInput
  }

  /**
   * EmailLog without action
   */
  export type EmailLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
  }


  /**
   * Model Note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteMinAggregateOutputType = {
    id: string | null
    content: string | null
    clientId: string | null
    authorId: string | null
    emailSent: boolean | null
    emailSentAt: Date | null
    feedbackToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoteMaxAggregateOutputType = {
    id: string | null
    content: string | null
    clientId: string | null
    authorId: string | null
    emailSent: boolean | null
    emailSentAt: Date | null
    feedbackToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoteCountAggregateOutputType = {
    id: number
    content: number
    clientId: number
    authorId: number
    emailSent: number
    emailSentAt: number
    feedbackToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NoteMinAggregateInputType = {
    id?: true
    content?: true
    clientId?: true
    authorId?: true
    emailSent?: true
    emailSentAt?: true
    feedbackToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoteMaxAggregateInputType = {
    id?: true
    content?: true
    clientId?: true
    authorId?: true
    emailSent?: true
    emailSentAt?: true
    feedbackToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoteCountAggregateInputType = {
    id?: true
    content?: true
    clientId?: true
    authorId?: true
    emailSent?: true
    emailSentAt?: true
    feedbackToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithAggregationInput | NoteOrderByWithAggregationInput[]
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum
    having?: NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }

  export type NoteGroupByOutputType = {
    id: string
    content: string
    clientId: string
    authorId: string
    emailSent: boolean
    emailSentAt: Date | null
    feedbackToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    clientId?: boolean
    authorId?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    feedbackToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    clientId?: boolean
    authorId?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    feedbackToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectScalar = {
    id?: boolean
    content?: boolean
    clientId?: boolean
    authorId?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    feedbackToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note"
    objects: {
      client: Prisma.$ClientProfilePayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      clientId: string
      authorId: string
      emailSent: boolean
      emailSentAt: Date | null
      feedbackToken: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["note"]>
    composites: {}
  }

  type NoteGetPayload<S extends boolean | null | undefined | NoteDefaultArgs> = $Result.GetResult<Prisma.$NotePayload, S>

  type NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NoteCountAggregateInputType | true
    }

  export interface NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note'], meta: { name: 'Note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteFindUniqueArgs>(args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Note that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteFindFirstArgs>(args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteWithIdOnly = await prisma.note.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteFindManyArgs>(args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
     */
    create<T extends NoteCreateArgs>(args: SelectSubset<T, NoteCreateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notes.
     * @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteCreateManyArgs>(args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {NoteCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const noteWithIdOnly = await prisma.note.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoteCreateManyAndReturnArgs>(args?: SelectSubset<T, NoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
     */
    delete<T extends NoteDeleteArgs>(args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteUpdateArgs>(args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteDeleteManyArgs>(args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteUpdateManyArgs>(args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
     */
    upsert<T extends NoteUpsertArgs>(args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note model
   */
  readonly fields: NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Note model
   */ 
  interface NoteFieldRefs {
    readonly id: FieldRef<"Note", 'String'>
    readonly content: FieldRef<"Note", 'String'>
    readonly clientId: FieldRef<"Note", 'String'>
    readonly authorId: FieldRef<"Note", 'String'>
    readonly emailSent: FieldRef<"Note", 'Boolean'>
    readonly emailSentAt: FieldRef<"Note", 'DateTime'>
    readonly feedbackToken: FieldRef<"Note", 'String'>
    readonly createdAt: FieldRef<"Note", 'DateTime'>
    readonly updatedAt: FieldRef<"Note", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Note findUnique
   */
  export type NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findFirst
   */
  export type NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findMany
   */
  export type NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note create
   */
  export type NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Note.
     */
    data: XOR<NoteCreateInput, NoteUncheckedCreateInput>
  }

  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Note createManyAndReturn
   */
  export type NoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Note update
   */
  export type NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
  }

  /**
   * Note upsert
   */
  export type NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
  }

  /**
   * Note delete
   */
  export type NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput
  }

  /**
   * Note without action
   */
  export type NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
  }


  /**
   * Model Assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    professionalId: string | null
    assignedAt: Date | null
  }

  export type AssignmentMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    professionalId: string | null
    assignedAt: Date | null
  }

  export type AssignmentCountAggregateOutputType = {
    id: number
    clientId: number
    professionalId: number
    assignedAt: number
    _all: number
  }


  export type AssignmentMinAggregateInputType = {
    id?: true
    clientId?: true
    professionalId?: true
    assignedAt?: true
  }

  export type AssignmentMaxAggregateInputType = {
    id?: true
    clientId?: true
    professionalId?: true
    assignedAt?: true
  }

  export type AssignmentCountAggregateInputType = {
    id?: true
    clientId?: true
    professionalId?: true
    assignedAt?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignment to aggregate.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type AssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithAggregationInput | AssignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: AssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    id: string
    clientId: string
    professionalId: string
    assignedAt: Date
    _count: AssignmentCountAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends AssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    professionalId?: boolean
    assignedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    professionalId?: boolean
    assignedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectScalar = {
    id?: boolean
    clientId?: boolean
    professionalId?: boolean
    assignedAt?: boolean
  }

  export type AssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assignment"
    objects: {
      client: Prisma.$ClientProfilePayload<ExtArgs>
      professional: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      professionalId: string
      assignedAt: Date
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type AssignmentGetPayload<S extends boolean | null | undefined | AssignmentDefaultArgs> = $Result.GetResult<Prisma.$AssignmentPayload, S>

  type AssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface AssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assignment'], meta: { name: 'Assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {AssignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentFindUniqueArgs>(args: SelectSubset<T, AssignmentFindUniqueArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentFindFirstArgs>(args?: SelectSubset<T, AssignmentFindFirstArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentWithIdOnly = await prisma.assignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentFindManyArgs>(args?: SelectSubset<T, AssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Assignment.
     * @param {AssignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
     */
    create<T extends AssignmentCreateArgs>(args: SelectSubset<T, AssignmentCreateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Assignments.
     * @param {AssignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentCreateManyArgs>(args?: SelectSubset<T, AssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignments and returns the data saved in the database.
     * @param {AssignmentCreateManyAndReturnArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Assignment.
     * @param {AssignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
     */
    delete<T extends AssignmentDeleteArgs>(args: SelectSubset<T, AssignmentDeleteArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Assignment.
     * @param {AssignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentUpdateArgs>(args: SelectSubset<T, AssignmentUpdateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Assignments.
     * @param {AssignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentDeleteManyArgs>(args?: SelectSubset<T, AssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentUpdateManyArgs>(args: SelectSubset<T, AssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assignment.
     * @param {AssignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentUpsertArgs>(args: SelectSubset<T, AssignmentUpsertArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends AssignmentCountArgs>(
      args?: Subset<T, AssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assignment model
   */
  readonly fields: AssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    professional<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assignment model
   */ 
  interface AssignmentFieldRefs {
    readonly id: FieldRef<"Assignment", 'String'>
    readonly clientId: FieldRef<"Assignment", 'String'>
    readonly professionalId: FieldRef<"Assignment", 'String'>
    readonly assignedAt: FieldRef<"Assignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Assignment findUnique
   */
  export type AssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findUniqueOrThrow
   */
  export type AssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findFirst
   */
  export type AssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findFirstOrThrow
   */
  export type AssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findMany
   */
  export type AssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignments to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment create
   */
  export type AssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assignment.
     */
    data: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
  }

  /**
   * Assignment createMany
   */
  export type AssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assignment createManyAndReturn
   */
  export type AssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment update
   */
  export type AssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assignment.
     */
    data: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
    /**
     * Choose, which Assignment to update.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment updateMany
   */
  export type AssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
  }

  /**
   * Assignment upsert
   */
  export type AssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assignment to update in case it exists.
     */
    where: AssignmentWhereUniqueInput
    /**
     * In case the Assignment found by the `where` argument doesn't exist, create a new Assignment with this data.
     */
    create: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
    /**
     * In case the Assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
  }

  /**
   * Assignment delete
   */
  export type AssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter which Assignment to delete.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment deleteMany
   */
  export type AssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignments to delete
     */
    where?: AssignmentWhereInput
  }

  /**
   * Assignment without action
   */
  export type AssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    rating: number | null
    comment: string | null
    professionalId: string | null
    isAnonymous: boolean | null
    createdAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    rating: number | null
    comment: string | null
    professionalId: string | null
    isAnonymous: boolean | null
    createdAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    rating: number
    comment: number
    professionalId: number
    isAnonymous: number
    createdAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    professionalId?: true
    isAnonymous?: true
    createdAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    professionalId?: true
    isAnonymous?: true
    createdAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    professionalId?: true
    isAnonymous?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    rating: number
    comment: string | null
    professionalId: string
    isAnonymous: boolean
    createdAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    comment?: boolean
    professionalId?: boolean
    isAnonymous?: boolean
    createdAt?: boolean
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    comment?: boolean
    professionalId?: boolean
    isAnonymous?: boolean
    createdAt?: boolean
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    rating?: boolean
    comment?: boolean
    professionalId?: boolean
    isAnonymous?: boolean
    createdAt?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      professional: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rating: number
      comment: string | null
      professionalId: string
      isAnonymous: boolean
      createdAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    professional<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly professionalId: FieldRef<"Review", 'String'>
    readonly isAnonymous: FieldRef<"Review", 'Boolean'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model ServiceCategory
   */

  export type AggregateServiceCategory = {
    _count: ServiceCategoryCountAggregateOutputType | null
    _avg: ServiceCategoryAvgAggregateOutputType | null
    _sum: ServiceCategorySumAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  export type ServiceCategoryAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type ServiceCategorySumAggregateOutputType = {
    displayOrder: number | null
  }

  export type ServiceCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    displayOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceCategoryAvgAggregateInputType = {
    displayOrder?: true
  }

  export type ServiceCategorySumAggregateInputType = {
    displayOrder?: true
  }

  export type ServiceCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategory to aggregate.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCategories
    **/
    _count?: true | ServiceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type GetServiceCategoryAggregateType<T extends ServiceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCategory[P]>
      : GetScalarType<T[P], AggregateServiceCategory[P]>
  }




  export type ServiceCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCategoryWhereInput
    orderBy?: ServiceCategoryOrderByWithAggregationInput | ServiceCategoryOrderByWithAggregationInput[]
    by: ServiceCategoryScalarFieldEnum[] | ServiceCategoryScalarFieldEnum
    having?: ServiceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCategoryCountAggregateInputType | true
    _avg?: ServiceCategoryAvgAggregateInputType
    _sum?: ServiceCategorySumAggregateInputType
    _min?: ServiceCategoryMinAggregateInputType
    _max?: ServiceCategoryMaxAggregateInputType
  }

  export type ServiceCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    displayOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCategoryCountAggregateOutputType | null
    _avg: ServiceCategoryAvgAggregateOutputType | null
    _sum: ServiceCategorySumAggregateOutputType | null
    _min: ServiceCategoryMinAggregateOutputType | null
    _max: ServiceCategoryMaxAggregateOutputType | null
  }

  type GetServiceCategoryGroupByPayload<T extends ServiceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    services?: boolean | ServiceCategory$servicesArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceCategory"]>

  export type ServiceCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceCategory$servicesArgs<ExtArgs>
    _count?: boolean | ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceCategory"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      displayOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceCategory"]>
    composites: {}
  }

  type ServiceCategoryGetPayload<S extends boolean | null | undefined | ServiceCategoryDefaultArgs> = $Result.GetResult<Prisma.$ServiceCategoryPayload, S>

  type ServiceCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCategoryCountAggregateInputType | true
    }

  export interface ServiceCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCategory'], meta: { name: 'ServiceCategory' } }
    /**
     * Find zero or one ServiceCategory that matches the filter.
     * @param {ServiceCategoryFindUniqueArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceCategoryFindUniqueArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceCategoryFindUniqueOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceCategoryFindFirstArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindFirstOrThrowArgs} args - Arguments to find a ServiceCategory
     * @example
     * // Get one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany()
     * 
     * // Get first 10 ServiceCategories
     * const serviceCategories = await prisma.serviceCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceCategoryFindManyArgs>(args?: SelectSubset<T, ServiceCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceCategory.
     * @param {ServiceCategoryCreateArgs} args - Arguments to create a ServiceCategory.
     * @example
     * // Create one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.create({
     *   data: {
     *     // ... data to create a ServiceCategory
     *   }
     * })
     * 
     */
    create<T extends ServiceCategoryCreateArgs>(args: SelectSubset<T, ServiceCategoryCreateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceCategories.
     * @param {ServiceCategoryCreateManyArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCategoryCreateManyArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceCategories and returns the data saved in the database.
     * @param {ServiceCategoryCreateManyAndReturnArgs} args - Arguments to create many ServiceCategories.
     * @example
     * // Create many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceCategories and only return the `id`
     * const serviceCategoryWithIdOnly = await prisma.serviceCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceCategory.
     * @param {ServiceCategoryDeleteArgs} args - Arguments to delete one ServiceCategory.
     * @example
     * // Delete one ServiceCategory
     * const ServiceCategory = await prisma.serviceCategory.delete({
     *   where: {
     *     // ... filter to delete one ServiceCategory
     *   }
     * })
     * 
     */
    delete<T extends ServiceCategoryDeleteArgs>(args: SelectSubset<T, ServiceCategoryDeleteArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceCategory.
     * @param {ServiceCategoryUpdateArgs} args - Arguments to update one ServiceCategory.
     * @example
     * // Update one ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceCategoryUpdateArgs>(args: SelectSubset<T, ServiceCategoryUpdateArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceCategories.
     * @param {ServiceCategoryDeleteManyArgs} args - Arguments to filter ServiceCategories to delete.
     * @example
     * // Delete a few ServiceCategories
     * const { count } = await prisma.serviceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceCategoryDeleteManyArgs>(args?: SelectSubset<T, ServiceCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCategories
     * const serviceCategory = await prisma.serviceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceCategoryUpdateManyArgs>(args: SelectSubset<T, ServiceCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceCategory.
     * @param {ServiceCategoryUpsertArgs} args - Arguments to update or create a ServiceCategory.
     * @example
     * // Update or create a ServiceCategory
     * const serviceCategory = await prisma.serviceCategory.upsert({
     *   create: {
     *     // ... data to create a ServiceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCategory we want to update
     *   }
     * })
     */
    upsert<T extends ServiceCategoryUpsertArgs>(args: SelectSubset<T, ServiceCategoryUpsertArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryCountArgs} args - Arguments to filter ServiceCategories to count.
     * @example
     * // Count the number of ServiceCategories
     * const count = await prisma.serviceCategory.count({
     *   where: {
     *     // ... the filter for the ServiceCategories we want to count
     *   }
     * })
    **/
    count<T extends ServiceCategoryCountArgs>(
      args?: Subset<T, ServiceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCategoryAggregateArgs>(args: Subset<T, ServiceCategoryAggregateArgs>): Prisma.PrismaPromise<GetServiceCategoryAggregateType<T>>

    /**
     * Group by ServiceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceCategory model
   */
  readonly fields: ServiceCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends ServiceCategory$servicesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategory$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceCategory model
   */ 
  interface ServiceCategoryFieldRefs {
    readonly id: FieldRef<"ServiceCategory", 'String'>
    readonly name: FieldRef<"ServiceCategory", 'String'>
    readonly description: FieldRef<"ServiceCategory", 'String'>
    readonly displayOrder: FieldRef<"ServiceCategory", 'Int'>
    readonly isActive: FieldRef<"ServiceCategory", 'Boolean'>
    readonly createdAt: FieldRef<"ServiceCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceCategory findUnique
   */
  export type ServiceCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findUniqueOrThrow
   */
  export type ServiceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory findFirst
   */
  export type ServiceCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findFirstOrThrow
   */
  export type ServiceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategory to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCategories.
     */
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory findMany
   */
  export type ServiceCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceCategories to fetch.
     */
    where?: ServiceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCategories to fetch.
     */
    orderBy?: ServiceCategoryOrderByWithRelationInput | ServiceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCategories.
     */
    cursor?: ServiceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCategories.
     */
    skip?: number
    distinct?: ServiceCategoryScalarFieldEnum | ServiceCategoryScalarFieldEnum[]
  }

  /**
   * ServiceCategory create
   */
  export type ServiceCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceCategory.
     */
    data: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
  }

  /**
   * ServiceCategory createMany
   */
  export type ServiceCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory createManyAndReturn
   */
  export type ServiceCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceCategories.
     */
    data: ServiceCategoryCreateManyInput | ServiceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCategory update
   */
  export type ServiceCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceCategory.
     */
    data: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
    /**
     * Choose, which ServiceCategory to update.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory updateMany
   */
  export type ServiceCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCategories.
     */
    data: XOR<ServiceCategoryUpdateManyMutationInput, ServiceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCategories to update
     */
    where?: ServiceCategoryWhereInput
  }

  /**
   * ServiceCategory upsert
   */
  export type ServiceCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceCategory to update in case it exists.
     */
    where: ServiceCategoryWhereUniqueInput
    /**
     * In case the ServiceCategory found by the `where` argument doesn't exist, create a new ServiceCategory with this data.
     */
    create: XOR<ServiceCategoryCreateInput, ServiceCategoryUncheckedCreateInput>
    /**
     * In case the ServiceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCategoryUpdateInput, ServiceCategoryUncheckedUpdateInput>
  }

  /**
   * ServiceCategory delete
   */
  export type ServiceCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
    /**
     * Filter which ServiceCategory to delete.
     */
    where: ServiceCategoryWhereUniqueInput
  }

  /**
   * ServiceCategory deleteMany
   */
  export type ServiceCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCategories to delete
     */
    where?: ServiceCategoryWhereInput
  }

  /**
   * ServiceCategory.services
   */
  export type ServiceCategory$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * ServiceCategory without action
   */
  export type ServiceCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCategory
     */
    select?: ServiceCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    duration: number | null
    price: Decimal | null
    displayOrder: number | null
  }

  export type ServiceSumAggregateOutputType = {
    duration: number | null
    price: Decimal | null
    displayOrder: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    duration: number | null
    price: Decimal | null
    categoryId: string | null
    imageUrl: string | null
    displayOrder: number | null
    isActive: boolean | null
    requiresProfessional: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    duration: number | null
    price: Decimal | null
    categoryId: string | null
    imageUrl: string | null
    displayOrder: number | null
    isActive: boolean | null
    requiresProfessional: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    duration: number
    price: number
    categoryId: number
    imageUrl: number
    displayOrder: number
    isActive: number
    requiresProfessional: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    duration?: true
    price?: true
    displayOrder?: true
  }

  export type ServiceSumAggregateInputType = {
    duration?: true
    price?: true
    displayOrder?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    duration?: true
    price?: true
    categoryId?: true
    imageUrl?: true
    displayOrder?: true
    isActive?: true
    requiresProfessional?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    duration?: true
    price?: true
    categoryId?: true
    imageUrl?: true
    displayOrder?: true
    isActive?: true
    requiresProfessional?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    duration?: true
    price?: true
    categoryId?: true
    imageUrl?: true
    displayOrder?: true
    isActive?: true
    requiresProfessional?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    duration: number
    price: Decimal
    categoryId: string
    imageUrl: string | null
    displayOrder: number
    isActive: boolean
    requiresProfessional: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    categoryId?: boolean
    imageUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    packageServices?: boolean | Service$packageServicesArgs<ExtArgs>
    promotions?: boolean | Service$promotionsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    categoryId?: boolean
    imageUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    categoryId?: boolean
    imageUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    packageServices?: boolean | Service$packageServicesArgs<ExtArgs>
    promotions?: boolean | Service$promotionsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ServiceCategoryDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      category: Prisma.$ServiceCategoryPayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      packageServices: Prisma.$PackageServicePayload<ExtArgs>[]
      promotions: Prisma.$ServicePromotionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      duration: number
      price: Prisma.Decimal
      categoryId: string
      imageUrl: string | null
      displayOrder: number
      isActive: boolean
      requiresProfessional: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends ServiceCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceCategoryDefaultArgs<ExtArgs>>): Prisma__ServiceCategoryClient<$Result.GetResult<Prisma.$ServiceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bookings<T extends Service$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Service$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    packageServices<T extends Service$packageServicesArgs<ExtArgs> = {}>(args?: Subset<T, Service$packageServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageServicePayload<ExtArgs>, T, "findMany"> | Null>
    promotions<T extends Service$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Service$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePromotionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly slug: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly duration: FieldRef<"Service", 'Int'>
    readonly price: FieldRef<"Service", 'Decimal'>
    readonly categoryId: FieldRef<"Service", 'String'>
    readonly imageUrl: FieldRef<"Service", 'String'>
    readonly displayOrder: FieldRef<"Service", 'Int'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly requiresProfessional: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service.bookings
   */
  export type Service$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Service.packageServices
   */
  export type Service$packageServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageService
     */
    select?: PackageServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageServiceInclude<ExtArgs> | null
    where?: PackageServiceWhereInput
    orderBy?: PackageServiceOrderByWithRelationInput | PackageServiceOrderByWithRelationInput[]
    cursor?: PackageServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackageServiceScalarFieldEnum | PackageServiceScalarFieldEnum[]
  }

  /**
   * Service.promotions
   */
  export type Service$promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePromotion
     */
    select?: ServicePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePromotionInclude<ExtArgs> | null
    where?: ServicePromotionWhereInput
    orderBy?: ServicePromotionOrderByWithRelationInput | ServicePromotionOrderByWithRelationInput[]
    cursor?: ServicePromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicePromotionScalarFieldEnum | ServicePromotionScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Package
   */

  export type AggregatePackage = {
    _count: PackageCountAggregateOutputType | null
    _avg: PackageAvgAggregateOutputType | null
    _sum: PackageSumAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  export type PackageAvgAggregateOutputType = {
    price: Decimal | null
    originalPrice: Decimal | null
    discount: Decimal | null
    displayOrder: number | null
  }

  export type PackageSumAggregateOutputType = {
    price: Decimal | null
    originalPrice: Decimal | null
    discount: Decimal | null
    displayOrder: number | null
  }

  export type PackageMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    price: Decimal | null
    originalPrice: Decimal | null
    discount: Decimal | null
    variant: string | null
    imageUrl: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    price: Decimal | null
    originalPrice: Decimal | null
    discount: Decimal | null
    variant: string | null
    imageUrl: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackageCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    price: number
    originalPrice: number
    discount: number
    variant: number
    imageUrl: number
    displayOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PackageAvgAggregateInputType = {
    price?: true
    originalPrice?: true
    discount?: true
    displayOrder?: true
  }

  export type PackageSumAggregateInputType = {
    price?: true
    originalPrice?: true
    discount?: true
    displayOrder?: true
  }

  export type PackageMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    originalPrice?: true
    discount?: true
    variant?: true
    imageUrl?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackageMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    originalPrice?: true
    discount?: true
    variant?: true
    imageUrl?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackageCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    originalPrice?: true
    discount?: true
    variant?: true
    imageUrl?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Package to aggregate.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Packages
    **/
    _count?: true | PackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageMaxAggregateInputType
  }

  export type GetPackageAggregateType<T extends PackageAggregateArgs> = {
        [P in keyof T & keyof AggregatePackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackage[P]>
      : GetScalarType<T[P], AggregatePackage[P]>
  }




  export type PackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageWhereInput
    orderBy?: PackageOrderByWithAggregationInput | PackageOrderByWithAggregationInput[]
    by: PackageScalarFieldEnum[] | PackageScalarFieldEnum
    having?: PackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageCountAggregateInputType | true
    _avg?: PackageAvgAggregateInputType
    _sum?: PackageSumAggregateInputType
    _min?: PackageMinAggregateInputType
    _max?: PackageMaxAggregateInputType
  }

  export type PackageGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    price: Decimal
    originalPrice: Decimal | null
    discount: Decimal | null
    variant: string | null
    imageUrl: string | null
    displayOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PackageCountAggregateOutputType | null
    _avg: PackageAvgAggregateOutputType | null
    _sum: PackageSumAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  type GetPackageGroupByPayload<T extends PackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageGroupByOutputType[P]>
            : GetScalarType<T[P], PackageGroupByOutputType[P]>
        }
      >
    >


  export type PackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    discount?: boolean
    variant?: boolean
    imageUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    services?: boolean | Package$servicesArgs<ExtArgs>
    bookings?: boolean | Package$bookingsArgs<ExtArgs>
    promotions?: boolean | Package$promotionsArgs<ExtArgs>
    _count?: boolean | PackageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["package"]>

  export type PackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    discount?: boolean
    variant?: boolean
    imageUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["package"]>

  export type PackageSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    discount?: boolean
    variant?: boolean
    imageUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | Package$servicesArgs<ExtArgs>
    bookings?: boolean | Package$bookingsArgs<ExtArgs>
    promotions?: boolean | Package$promotionsArgs<ExtArgs>
    _count?: boolean | PackageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PackageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Package"
    objects: {
      services: Prisma.$PackageServicePayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      promotions: Prisma.$PackagePromotionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      price: Prisma.Decimal
      originalPrice: Prisma.Decimal | null
      discount: Prisma.Decimal | null
      variant: string | null
      imageUrl: string | null
      displayOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["package"]>
    composites: {}
  }

  type PackageGetPayload<S extends boolean | null | undefined | PackageDefaultArgs> = $Result.GetResult<Prisma.$PackagePayload, S>

  type PackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PackageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PackageCountAggregateInputType | true
    }

  export interface PackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Package'], meta: { name: 'Package' } }
    /**
     * Find zero or one Package that matches the filter.
     * @param {PackageFindUniqueArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageFindUniqueArgs>(args: SelectSubset<T, PackageFindUniqueArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Package that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PackageFindUniqueOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Package that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageFindFirstArgs>(args?: SelectSubset<T, PackageFindFirstArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Package that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Packages
     * const packages = await prisma.package.findMany()
     * 
     * // Get first 10 Packages
     * const packages = await prisma.package.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageWithIdOnly = await prisma.package.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageFindManyArgs>(args?: SelectSubset<T, PackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Package.
     * @param {PackageCreateArgs} args - Arguments to create a Package.
     * @example
     * // Create one Package
     * const Package = await prisma.package.create({
     *   data: {
     *     // ... data to create a Package
     *   }
     * })
     * 
     */
    create<T extends PackageCreateArgs>(args: SelectSubset<T, PackageCreateArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Packages.
     * @param {PackageCreateManyArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const package = await prisma.package.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageCreateManyArgs>(args?: SelectSubset<T, PackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Packages and returns the data saved in the database.
     * @param {PackageCreateManyAndReturnArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const package = await prisma.package.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Packages and only return the `id`
     * const packageWithIdOnly = await prisma.package.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackageCreateManyAndReturnArgs>(args?: SelectSubset<T, PackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Package.
     * @param {PackageDeleteArgs} args - Arguments to delete one Package.
     * @example
     * // Delete one Package
     * const Package = await prisma.package.delete({
     *   where: {
     *     // ... filter to delete one Package
     *   }
     * })
     * 
     */
    delete<T extends PackageDeleteArgs>(args: SelectSubset<T, PackageDeleteArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Package.
     * @param {PackageUpdateArgs} args - Arguments to update one Package.
     * @example
     * // Update one Package
     * const package = await prisma.package.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageUpdateArgs>(args: SelectSubset<T, PackageUpdateArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Packages.
     * @param {PackageDeleteManyArgs} args - Arguments to filter Packages to delete.
     * @example
     * // Delete a few Packages
     * const { count } = await prisma.package.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageDeleteManyArgs>(args?: SelectSubset<T, PackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Packages
     * const package = await prisma.package.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageUpdateManyArgs>(args: SelectSubset<T, PackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Package.
     * @param {PackageUpsertArgs} args - Arguments to update or create a Package.
     * @example
     * // Update or create a Package
     * const package = await prisma.package.upsert({
     *   create: {
     *     // ... data to create a Package
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Package we want to update
     *   }
     * })
     */
    upsert<T extends PackageUpsertArgs>(args: SelectSubset<T, PackageUpsertArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCountArgs} args - Arguments to filter Packages to count.
     * @example
     * // Count the number of Packages
     * const count = await prisma.package.count({
     *   where: {
     *     // ... the filter for the Packages we want to count
     *   }
     * })
    **/
    count<T extends PackageCountArgs>(
      args?: Subset<T, PackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageAggregateArgs>(args: Subset<T, PackageAggregateArgs>): Prisma.PrismaPromise<GetPackageAggregateType<T>>

    /**
     * Group by Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageGroupByArgs['orderBy'] }
        : { orderBy?: PackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Package model
   */
  readonly fields: PackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Package.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends Package$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Package$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageServicePayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Package$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Package$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    promotions<T extends Package$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Package$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePromotionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Package model
   */ 
  interface PackageFieldRefs {
    readonly id: FieldRef<"Package", 'String'>
    readonly name: FieldRef<"Package", 'String'>
    readonly slug: FieldRef<"Package", 'String'>
    readonly description: FieldRef<"Package", 'String'>
    readonly price: FieldRef<"Package", 'Decimal'>
    readonly originalPrice: FieldRef<"Package", 'Decimal'>
    readonly discount: FieldRef<"Package", 'Decimal'>
    readonly variant: FieldRef<"Package", 'String'>
    readonly imageUrl: FieldRef<"Package", 'String'>
    readonly displayOrder: FieldRef<"Package", 'Int'>
    readonly isActive: FieldRef<"Package", 'Boolean'>
    readonly createdAt: FieldRef<"Package", 'DateTime'>
    readonly updatedAt: FieldRef<"Package", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Package findUnique
   */
  export type PackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findUniqueOrThrow
   */
  export type PackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findFirst
   */
  export type PackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package findFirstOrThrow
   */
  export type PackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package findMany
   */
  export type PackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Packages to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package create
   */
  export type PackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The data needed to create a Package.
     */
    data: XOR<PackageCreateInput, PackageUncheckedCreateInput>
  }

  /**
   * Package createMany
   */
  export type PackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Packages.
     */
    data: PackageCreateManyInput | PackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Package createManyAndReturn
   */
  export type PackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Packages.
     */
    data: PackageCreateManyInput | PackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Package update
   */
  export type PackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The data needed to update a Package.
     */
    data: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
    /**
     * Choose, which Package to update.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package updateMany
   */
  export type PackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Packages.
     */
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyInput>
    /**
     * Filter which Packages to update
     */
    where?: PackageWhereInput
  }

  /**
   * Package upsert
   */
  export type PackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The filter to search for the Package to update in case it exists.
     */
    where: PackageWhereUniqueInput
    /**
     * In case the Package found by the `where` argument doesn't exist, create a new Package with this data.
     */
    create: XOR<PackageCreateInput, PackageUncheckedCreateInput>
    /**
     * In case the Package was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
  }

  /**
   * Package delete
   */
  export type PackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter which Package to delete.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package deleteMany
   */
  export type PackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Packages to delete
     */
    where?: PackageWhereInput
  }

  /**
   * Package.services
   */
  export type Package$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageService
     */
    select?: PackageServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageServiceInclude<ExtArgs> | null
    where?: PackageServiceWhereInput
    orderBy?: PackageServiceOrderByWithRelationInput | PackageServiceOrderByWithRelationInput[]
    cursor?: PackageServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackageServiceScalarFieldEnum | PackageServiceScalarFieldEnum[]
  }

  /**
   * Package.bookings
   */
  export type Package$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Package.promotions
   */
  export type Package$promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagePromotion
     */
    select?: PackagePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagePromotionInclude<ExtArgs> | null
    where?: PackagePromotionWhereInput
    orderBy?: PackagePromotionOrderByWithRelationInput | PackagePromotionOrderByWithRelationInput[]
    cursor?: PackagePromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackagePromotionScalarFieldEnum | PackagePromotionScalarFieldEnum[]
  }

  /**
   * Package without action
   */
  export type PackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
  }


  /**
   * Model PackageService
   */

  export type AggregatePackageService = {
    _count: PackageServiceCountAggregateOutputType | null
    _avg: PackageServiceAvgAggregateOutputType | null
    _sum: PackageServiceSumAggregateOutputType | null
    _min: PackageServiceMinAggregateOutputType | null
    _max: PackageServiceMaxAggregateOutputType | null
  }

  export type PackageServiceAvgAggregateOutputType = {
    quantity: number | null
    extraCost: Decimal | null
  }

  export type PackageServiceSumAggregateOutputType = {
    quantity: number | null
    extraCost: Decimal | null
  }

  export type PackageServiceMinAggregateOutputType = {
    id: string | null
    packageId: string | null
    serviceId: string | null
    quantity: number | null
    isOptional: boolean | null
    extraCost: Decimal | null
    createdAt: Date | null
  }

  export type PackageServiceMaxAggregateOutputType = {
    id: string | null
    packageId: string | null
    serviceId: string | null
    quantity: number | null
    isOptional: boolean | null
    extraCost: Decimal | null
    createdAt: Date | null
  }

  export type PackageServiceCountAggregateOutputType = {
    id: number
    packageId: number
    serviceId: number
    quantity: number
    isOptional: number
    extraCost: number
    createdAt: number
    _all: number
  }


  export type PackageServiceAvgAggregateInputType = {
    quantity?: true
    extraCost?: true
  }

  export type PackageServiceSumAggregateInputType = {
    quantity?: true
    extraCost?: true
  }

  export type PackageServiceMinAggregateInputType = {
    id?: true
    packageId?: true
    serviceId?: true
    quantity?: true
    isOptional?: true
    extraCost?: true
    createdAt?: true
  }

  export type PackageServiceMaxAggregateInputType = {
    id?: true
    packageId?: true
    serviceId?: true
    quantity?: true
    isOptional?: true
    extraCost?: true
    createdAt?: true
  }

  export type PackageServiceCountAggregateInputType = {
    id?: true
    packageId?: true
    serviceId?: true
    quantity?: true
    isOptional?: true
    extraCost?: true
    createdAt?: true
    _all?: true
  }

  export type PackageServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageService to aggregate.
     */
    where?: PackageServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageServices to fetch.
     */
    orderBy?: PackageServiceOrderByWithRelationInput | PackageServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PackageServices
    **/
    _count?: true | PackageServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackageServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackageServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageServiceMaxAggregateInputType
  }

  export type GetPackageServiceAggregateType<T extends PackageServiceAggregateArgs> = {
        [P in keyof T & keyof AggregatePackageService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackageService[P]>
      : GetScalarType<T[P], AggregatePackageService[P]>
  }




  export type PackageServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageServiceWhereInput
    orderBy?: PackageServiceOrderByWithAggregationInput | PackageServiceOrderByWithAggregationInput[]
    by: PackageServiceScalarFieldEnum[] | PackageServiceScalarFieldEnum
    having?: PackageServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageServiceCountAggregateInputType | true
    _avg?: PackageServiceAvgAggregateInputType
    _sum?: PackageServiceSumAggregateInputType
    _min?: PackageServiceMinAggregateInputType
    _max?: PackageServiceMaxAggregateInputType
  }

  export type PackageServiceGroupByOutputType = {
    id: string
    packageId: string
    serviceId: string
    quantity: number
    isOptional: boolean
    extraCost: Decimal | null
    createdAt: Date
    _count: PackageServiceCountAggregateOutputType | null
    _avg: PackageServiceAvgAggregateOutputType | null
    _sum: PackageServiceSumAggregateOutputType | null
    _min: PackageServiceMinAggregateOutputType | null
    _max: PackageServiceMaxAggregateOutputType | null
  }

  type GetPackageServiceGroupByPayload<T extends PackageServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageServiceGroupByOutputType[P]>
            : GetScalarType<T[P], PackageServiceGroupByOutputType[P]>
        }
      >
    >


  export type PackageServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    serviceId?: boolean
    quantity?: boolean
    isOptional?: boolean
    extraCost?: boolean
    createdAt?: boolean
    package?: boolean | PackageDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packageService"]>

  export type PackageServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    serviceId?: boolean
    quantity?: boolean
    isOptional?: boolean
    extraCost?: boolean
    createdAt?: boolean
    package?: boolean | PackageDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packageService"]>

  export type PackageServiceSelectScalar = {
    id?: boolean
    packageId?: boolean
    serviceId?: boolean
    quantity?: boolean
    isOptional?: boolean
    extraCost?: boolean
    createdAt?: boolean
  }

  export type PackageServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | PackageDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type PackageServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | PackageDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $PackageServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PackageService"
    objects: {
      package: Prisma.$PackagePayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      packageId: string
      serviceId: string
      quantity: number
      isOptional: boolean
      extraCost: Prisma.Decimal | null
      createdAt: Date
    }, ExtArgs["result"]["packageService"]>
    composites: {}
  }

  type PackageServiceGetPayload<S extends boolean | null | undefined | PackageServiceDefaultArgs> = $Result.GetResult<Prisma.$PackageServicePayload, S>

  type PackageServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PackageServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PackageServiceCountAggregateInputType | true
    }

  export interface PackageServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PackageService'], meta: { name: 'PackageService' } }
    /**
     * Find zero or one PackageService that matches the filter.
     * @param {PackageServiceFindUniqueArgs} args - Arguments to find a PackageService
     * @example
     * // Get one PackageService
     * const packageService = await prisma.packageService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageServiceFindUniqueArgs>(args: SelectSubset<T, PackageServiceFindUniqueArgs<ExtArgs>>): Prisma__PackageServiceClient<$Result.GetResult<Prisma.$PackageServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PackageService that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PackageServiceFindUniqueOrThrowArgs} args - Arguments to find a PackageService
     * @example
     * // Get one PackageService
     * const packageService = await prisma.packageService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageServiceClient<$Result.GetResult<Prisma.$PackageServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PackageService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageServiceFindFirstArgs} args - Arguments to find a PackageService
     * @example
     * // Get one PackageService
     * const packageService = await prisma.packageService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageServiceFindFirstArgs>(args?: SelectSubset<T, PackageServiceFindFirstArgs<ExtArgs>>): Prisma__PackageServiceClient<$Result.GetResult<Prisma.$PackageServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PackageService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageServiceFindFirstOrThrowArgs} args - Arguments to find a PackageService
     * @example
     * // Get one PackageService
     * const packageService = await prisma.packageService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageServiceClient<$Result.GetResult<Prisma.$PackageServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PackageServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PackageServices
     * const packageServices = await prisma.packageService.findMany()
     * 
     * // Get first 10 PackageServices
     * const packageServices = await prisma.packageService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageServiceWithIdOnly = await prisma.packageService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageServiceFindManyArgs>(args?: SelectSubset<T, PackageServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PackageService.
     * @param {PackageServiceCreateArgs} args - Arguments to create a PackageService.
     * @example
     * // Create one PackageService
     * const PackageService = await prisma.packageService.create({
     *   data: {
     *     // ... data to create a PackageService
     *   }
     * })
     * 
     */
    create<T extends PackageServiceCreateArgs>(args: SelectSubset<T, PackageServiceCreateArgs<ExtArgs>>): Prisma__PackageServiceClient<$Result.GetResult<Prisma.$PackageServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PackageServices.
     * @param {PackageServiceCreateManyArgs} args - Arguments to create many PackageServices.
     * @example
     * // Create many PackageServices
     * const packageService = await prisma.packageService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageServiceCreateManyArgs>(args?: SelectSubset<T, PackageServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PackageServices and returns the data saved in the database.
     * @param {PackageServiceCreateManyAndReturnArgs} args - Arguments to create many PackageServices.
     * @example
     * // Create many PackageServices
     * const packageService = await prisma.packageService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PackageServices and only return the `id`
     * const packageServiceWithIdOnly = await prisma.packageService.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackageServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, PackageServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PackageService.
     * @param {PackageServiceDeleteArgs} args - Arguments to delete one PackageService.
     * @example
     * // Delete one PackageService
     * const PackageService = await prisma.packageService.delete({
     *   where: {
     *     // ... filter to delete one PackageService
     *   }
     * })
     * 
     */
    delete<T extends PackageServiceDeleteArgs>(args: SelectSubset<T, PackageServiceDeleteArgs<ExtArgs>>): Prisma__PackageServiceClient<$Result.GetResult<Prisma.$PackageServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PackageService.
     * @param {PackageServiceUpdateArgs} args - Arguments to update one PackageService.
     * @example
     * // Update one PackageService
     * const packageService = await prisma.packageService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageServiceUpdateArgs>(args: SelectSubset<T, PackageServiceUpdateArgs<ExtArgs>>): Prisma__PackageServiceClient<$Result.GetResult<Prisma.$PackageServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PackageServices.
     * @param {PackageServiceDeleteManyArgs} args - Arguments to filter PackageServices to delete.
     * @example
     * // Delete a few PackageServices
     * const { count } = await prisma.packageService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageServiceDeleteManyArgs>(args?: SelectSubset<T, PackageServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackageServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PackageServices
     * const packageService = await prisma.packageService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageServiceUpdateManyArgs>(args: SelectSubset<T, PackageServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PackageService.
     * @param {PackageServiceUpsertArgs} args - Arguments to update or create a PackageService.
     * @example
     * // Update or create a PackageService
     * const packageService = await prisma.packageService.upsert({
     *   create: {
     *     // ... data to create a PackageService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PackageService we want to update
     *   }
     * })
     */
    upsert<T extends PackageServiceUpsertArgs>(args: SelectSubset<T, PackageServiceUpsertArgs<ExtArgs>>): Prisma__PackageServiceClient<$Result.GetResult<Prisma.$PackageServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PackageServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageServiceCountArgs} args - Arguments to filter PackageServices to count.
     * @example
     * // Count the number of PackageServices
     * const count = await prisma.packageService.count({
     *   where: {
     *     // ... the filter for the PackageServices we want to count
     *   }
     * })
    **/
    count<T extends PackageServiceCountArgs>(
      args?: Subset<T, PackageServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PackageService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageServiceAggregateArgs>(args: Subset<T, PackageServiceAggregateArgs>): Prisma.PrismaPromise<GetPackageServiceAggregateType<T>>

    /**
     * Group by PackageService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageServiceGroupByArgs['orderBy'] }
        : { orderBy?: PackageServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PackageService model
   */
  readonly fields: PackageServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PackageService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    package<T extends PackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PackageDefaultArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PackageService model
   */ 
  interface PackageServiceFieldRefs {
    readonly id: FieldRef<"PackageService", 'String'>
    readonly packageId: FieldRef<"PackageService", 'String'>
    readonly serviceId: FieldRef<"PackageService", 'String'>
    readonly quantity: FieldRef<"PackageService", 'Int'>
    readonly isOptional: FieldRef<"PackageService", 'Boolean'>
    readonly extraCost: FieldRef<"PackageService", 'Decimal'>
    readonly createdAt: FieldRef<"PackageService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PackageService findUnique
   */
  export type PackageServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageService
     */
    select?: PackageServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageServiceInclude<ExtArgs> | null
    /**
     * Filter, which PackageService to fetch.
     */
    where: PackageServiceWhereUniqueInput
  }

  /**
   * PackageService findUniqueOrThrow
   */
  export type PackageServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageService
     */
    select?: PackageServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageServiceInclude<ExtArgs> | null
    /**
     * Filter, which PackageService to fetch.
     */
    where: PackageServiceWhereUniqueInput
  }

  /**
   * PackageService findFirst
   */
  export type PackageServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageService
     */
    select?: PackageServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageServiceInclude<ExtArgs> | null
    /**
     * Filter, which PackageService to fetch.
     */
    where?: PackageServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageServices to fetch.
     */
    orderBy?: PackageServiceOrderByWithRelationInput | PackageServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageServices.
     */
    cursor?: PackageServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageServices.
     */
    distinct?: PackageServiceScalarFieldEnum | PackageServiceScalarFieldEnum[]
  }

  /**
   * PackageService findFirstOrThrow
   */
  export type PackageServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageService
     */
    select?: PackageServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageServiceInclude<ExtArgs> | null
    /**
     * Filter, which PackageService to fetch.
     */
    where?: PackageServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageServices to fetch.
     */
    orderBy?: PackageServiceOrderByWithRelationInput | PackageServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageServices.
     */
    cursor?: PackageServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageServices.
     */
    distinct?: PackageServiceScalarFieldEnum | PackageServiceScalarFieldEnum[]
  }

  /**
   * PackageService findMany
   */
  export type PackageServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageService
     */
    select?: PackageServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageServiceInclude<ExtArgs> | null
    /**
     * Filter, which PackageServices to fetch.
     */
    where?: PackageServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageServices to fetch.
     */
    orderBy?: PackageServiceOrderByWithRelationInput | PackageServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PackageServices.
     */
    cursor?: PackageServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageServices.
     */
    skip?: number
    distinct?: PackageServiceScalarFieldEnum | PackageServiceScalarFieldEnum[]
  }

  /**
   * PackageService create
   */
  export type PackageServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageService
     */
    select?: PackageServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a PackageService.
     */
    data: XOR<PackageServiceCreateInput, PackageServiceUncheckedCreateInput>
  }

  /**
   * PackageService createMany
   */
  export type PackageServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PackageServices.
     */
    data: PackageServiceCreateManyInput | PackageServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackageService createManyAndReturn
   */
  export type PackageServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageService
     */
    select?: PackageServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PackageServices.
     */
    data: PackageServiceCreateManyInput | PackageServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PackageService update
   */
  export type PackageServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageService
     */
    select?: PackageServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a PackageService.
     */
    data: XOR<PackageServiceUpdateInput, PackageServiceUncheckedUpdateInput>
    /**
     * Choose, which PackageService to update.
     */
    where: PackageServiceWhereUniqueInput
  }

  /**
   * PackageService updateMany
   */
  export type PackageServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PackageServices.
     */
    data: XOR<PackageServiceUpdateManyMutationInput, PackageServiceUncheckedUpdateManyInput>
    /**
     * Filter which PackageServices to update
     */
    where?: PackageServiceWhereInput
  }

  /**
   * PackageService upsert
   */
  export type PackageServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageService
     */
    select?: PackageServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the PackageService to update in case it exists.
     */
    where: PackageServiceWhereUniqueInput
    /**
     * In case the PackageService found by the `where` argument doesn't exist, create a new PackageService with this data.
     */
    create: XOR<PackageServiceCreateInput, PackageServiceUncheckedCreateInput>
    /**
     * In case the PackageService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageServiceUpdateInput, PackageServiceUncheckedUpdateInput>
  }

  /**
   * PackageService delete
   */
  export type PackageServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageService
     */
    select?: PackageServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageServiceInclude<ExtArgs> | null
    /**
     * Filter which PackageService to delete.
     */
    where: PackageServiceWhereUniqueInput
  }

  /**
   * PackageService deleteMany
   */
  export type PackageServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageServices to delete
     */
    where?: PackageServiceWhereInput
  }

  /**
   * PackageService without action
   */
  export type PackageServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageService
     */
    select?: PackageServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageServiceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    stripePaymentId: string | null
    stripeCustomerId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    paymentMethod: string | null
    receiptUrl: string | null
    receiptPdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    stripePaymentId: string | null
    stripeCustomerId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    paymentMethod: string | null
    receiptUrl: string | null
    receiptPdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    stripePaymentId: number
    stripeCustomerId: number
    amount: number
    currency: number
    status: number
    paymentMethod: number
    receiptUrl: number
    receiptPdfUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    stripePaymentId?: true
    stripeCustomerId?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    receiptUrl?: true
    receiptPdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    stripePaymentId?: true
    stripeCustomerId?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    receiptUrl?: true
    receiptPdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    stripePaymentId?: true
    stripeCustomerId?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    receiptUrl?: true
    receiptPdfUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    stripePaymentId: string | null
    stripeCustomerId: string | null
    amount: Decimal
    currency: string
    status: $Enums.PaymentStatus
    paymentMethod: string | null
    receiptUrl: string | null
    receiptPdfUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripePaymentId?: boolean
    stripeCustomerId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    receiptUrl?: boolean
    receiptPdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | Payment$bookingArgs<ExtArgs>
    order?: boolean | Payment$orderArgs<ExtArgs>
    giftCard?: boolean | Payment$giftCardArgs<ExtArgs>
    gymSubscription?: boolean | Payment$gymSubscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripePaymentId?: boolean
    stripeCustomerId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    receiptUrl?: boolean
    receiptPdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    stripePaymentId?: boolean
    stripeCustomerId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    receiptUrl?: boolean
    receiptPdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | Payment$bookingArgs<ExtArgs>
    order?: boolean | Payment$orderArgs<ExtArgs>
    giftCard?: boolean | Payment$giftCardArgs<ExtArgs>
    gymSubscription?: boolean | Payment$gymSubscriptionArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs> | null
      order: Prisma.$OrderPayload<ExtArgs> | null
      giftCard: Prisma.$GiftCardPayload<ExtArgs> | null
      gymSubscription: Prisma.$GymSubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stripePaymentId: string | null
      stripeCustomerId: string | null
      amount: Prisma.Decimal
      currency: string
      status: $Enums.PaymentStatus
      paymentMethod: string | null
      receiptUrl: string | null
      receiptPdfUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends Payment$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Payment$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    order<T extends Payment$orderArgs<ExtArgs> = {}>(args?: Subset<T, Payment$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    giftCard<T extends Payment$giftCardArgs<ExtArgs> = {}>(args?: Subset<T, Payment$giftCardArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    gymSubscription<T extends Payment$gymSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Payment$gymSubscriptionArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly stripePaymentId: FieldRef<"Payment", 'String'>
    readonly stripeCustomerId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly receiptUrl: FieldRef<"Payment", 'String'>
    readonly receiptPdfUrl: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.booking
   */
  export type Payment$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Payment.order
   */
  export type Payment$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Payment.giftCard
   */
  export type Payment$giftCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    where?: GiftCardWhereInput
  }

  /**
   * Payment.gymSubscription
   */
  export type Payment$gymSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    where?: GymSubscriptionWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    subtotal: Decimal | null
    taxTPS: Decimal | null
    taxTVQ: Decimal | null
    total: Decimal | null
    giftCardAmount: Decimal | null
  }

  export type BookingSumAggregateOutputType = {
    subtotal: Decimal | null
    taxTPS: Decimal | null
    taxTVQ: Decimal | null
    total: Decimal | null
    giftCardAmount: Decimal | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    bookingNumber: string | null
    type: $Enums.BookingType | null
    serviceId: string | null
    packageId: string | null
    clientEmail: string | null
    clientName: string | null
    clientPhone: string | null
    specialNotes: string | null
    bookingDate: Date | null
    startTime: string | null
    endTime: string | null
    professionalId: string | null
    subtotal: Decimal | null
    taxTPS: Decimal | null
    taxTVQ: Decimal | null
    total: Decimal | null
    giftCardId: string | null
    giftCardAmount: Decimal | null
    status: $Enums.BookingStatus | null
    paymentId: string | null
    reminderSent: boolean | null
    googleCalendarEventId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    bookingNumber: string | null
    type: $Enums.BookingType | null
    serviceId: string | null
    packageId: string | null
    clientEmail: string | null
    clientName: string | null
    clientPhone: string | null
    specialNotes: string | null
    bookingDate: Date | null
    startTime: string | null
    endTime: string | null
    professionalId: string | null
    subtotal: Decimal | null
    taxTPS: Decimal | null
    taxTVQ: Decimal | null
    total: Decimal | null
    giftCardId: string | null
    giftCardAmount: Decimal | null
    status: $Enums.BookingStatus | null
    paymentId: string | null
    reminderSent: boolean | null
    googleCalendarEventId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    bookingNumber: number
    type: number
    serviceId: number
    packageId: number
    clientEmail: number
    clientName: number
    clientPhone: number
    specialNotes: number
    bookingDate: number
    startTime: number
    endTime: number
    professionalId: number
    subtotal: number
    taxTPS: number
    taxTVQ: number
    total: number
    giftCardId: number
    giftCardAmount: number
    status: number
    paymentId: number
    reminderSent: number
    googleCalendarEventId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    subtotal?: true
    taxTPS?: true
    taxTVQ?: true
    total?: true
    giftCardAmount?: true
  }

  export type BookingSumAggregateInputType = {
    subtotal?: true
    taxTPS?: true
    taxTVQ?: true
    total?: true
    giftCardAmount?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    bookingNumber?: true
    type?: true
    serviceId?: true
    packageId?: true
    clientEmail?: true
    clientName?: true
    clientPhone?: true
    specialNotes?: true
    bookingDate?: true
    startTime?: true
    endTime?: true
    professionalId?: true
    subtotal?: true
    taxTPS?: true
    taxTVQ?: true
    total?: true
    giftCardId?: true
    giftCardAmount?: true
    status?: true
    paymentId?: true
    reminderSent?: true
    googleCalendarEventId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    bookingNumber?: true
    type?: true
    serviceId?: true
    packageId?: true
    clientEmail?: true
    clientName?: true
    clientPhone?: true
    specialNotes?: true
    bookingDate?: true
    startTime?: true
    endTime?: true
    professionalId?: true
    subtotal?: true
    taxTPS?: true
    taxTVQ?: true
    total?: true
    giftCardId?: true
    giftCardAmount?: true
    status?: true
    paymentId?: true
    reminderSent?: true
    googleCalendarEventId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    bookingNumber?: true
    type?: true
    serviceId?: true
    packageId?: true
    clientEmail?: true
    clientName?: true
    clientPhone?: true
    specialNotes?: true
    bookingDate?: true
    startTime?: true
    endTime?: true
    professionalId?: true
    subtotal?: true
    taxTPS?: true
    taxTVQ?: true
    total?: true
    giftCardId?: true
    giftCardAmount?: true
    status?: true
    paymentId?: true
    reminderSent?: true
    googleCalendarEventId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    bookingNumber: string
    type: $Enums.BookingType
    serviceId: string | null
    packageId: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes: string | null
    bookingDate: Date
    startTime: string
    endTime: string
    professionalId: string | null
    subtotal: Decimal
    taxTPS: Decimal
    taxTVQ: Decimal
    total: Decimal
    giftCardId: string | null
    giftCardAmount: Decimal | null
    status: $Enums.BookingStatus
    paymentId: string
    reminderSent: boolean
    googleCalendarEventId: string | null
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingNumber?: boolean
    type?: boolean
    serviceId?: boolean
    packageId?: boolean
    clientEmail?: boolean
    clientName?: boolean
    clientPhone?: boolean
    specialNotes?: boolean
    bookingDate?: boolean
    startTime?: boolean
    endTime?: boolean
    professionalId?: boolean
    subtotal?: boolean
    taxTPS?: boolean
    taxTVQ?: boolean
    total?: boolean
    giftCardId?: boolean
    giftCardAmount?: boolean
    status?: boolean
    paymentId?: boolean
    reminderSent?: boolean
    googleCalendarEventId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | Booking$serviceArgs<ExtArgs>
    package?: boolean | Booking$packageArgs<ExtArgs>
    professional?: boolean | Booking$professionalArgs<ExtArgs>
    giftCard?: boolean | Booking$giftCardArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    createdBy?: boolean | Booking$createdByArgs<ExtArgs>
    statusHistory?: boolean | Booking$statusHistoryArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingNumber?: boolean
    type?: boolean
    serviceId?: boolean
    packageId?: boolean
    clientEmail?: boolean
    clientName?: boolean
    clientPhone?: boolean
    specialNotes?: boolean
    bookingDate?: boolean
    startTime?: boolean
    endTime?: boolean
    professionalId?: boolean
    subtotal?: boolean
    taxTPS?: boolean
    taxTVQ?: boolean
    total?: boolean
    giftCardId?: boolean
    giftCardAmount?: boolean
    status?: boolean
    paymentId?: boolean
    reminderSent?: boolean
    googleCalendarEventId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | Booking$serviceArgs<ExtArgs>
    package?: boolean | Booking$packageArgs<ExtArgs>
    professional?: boolean | Booking$professionalArgs<ExtArgs>
    giftCard?: boolean | Booking$giftCardArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    createdBy?: boolean | Booking$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    bookingNumber?: boolean
    type?: boolean
    serviceId?: boolean
    packageId?: boolean
    clientEmail?: boolean
    clientName?: boolean
    clientPhone?: boolean
    specialNotes?: boolean
    bookingDate?: boolean
    startTime?: boolean
    endTime?: boolean
    professionalId?: boolean
    subtotal?: boolean
    taxTPS?: boolean
    taxTVQ?: boolean
    total?: boolean
    giftCardId?: boolean
    giftCardAmount?: boolean
    status?: boolean
    paymentId?: boolean
    reminderSent?: boolean
    googleCalendarEventId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | Booking$serviceArgs<ExtArgs>
    package?: boolean | Booking$packageArgs<ExtArgs>
    professional?: boolean | Booking$professionalArgs<ExtArgs>
    giftCard?: boolean | Booking$giftCardArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    createdBy?: boolean | Booking$createdByArgs<ExtArgs>
    statusHistory?: boolean | Booking$statusHistoryArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | Booking$serviceArgs<ExtArgs>
    package?: boolean | Booking$packageArgs<ExtArgs>
    professional?: boolean | Booking$professionalArgs<ExtArgs>
    giftCard?: boolean | Booking$giftCardArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    createdBy?: boolean | Booking$createdByArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs> | null
      package: Prisma.$PackagePayload<ExtArgs> | null
      professional: Prisma.$UserPayload<ExtArgs> | null
      giftCard: Prisma.$GiftCardPayload<ExtArgs> | null
      payment: Prisma.$PaymentPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      statusHistory: Prisma.$BookingStatusHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingNumber: string
      type: $Enums.BookingType
      serviceId: string | null
      packageId: string | null
      clientEmail: string
      clientName: string
      clientPhone: string
      specialNotes: string | null
      bookingDate: Date
      startTime: string
      endTime: string
      professionalId: string | null
      subtotal: Prisma.Decimal
      taxTPS: Prisma.Decimal
      taxTVQ: Prisma.Decimal
      total: Prisma.Decimal
      giftCardId: string | null
      giftCardAmount: Prisma.Decimal | null
      status: $Enums.BookingStatus
      paymentId: string
      reminderSent: boolean
      googleCalendarEventId: string | null
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends Booking$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Booking$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    package<T extends Booking$packageArgs<ExtArgs> = {}>(args?: Subset<T, Booking$packageArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    professional<T extends Booking$professionalArgs<ExtArgs> = {}>(args?: Subset<T, Booking$professionalArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    giftCard<T extends Booking$giftCardArgs<ExtArgs> = {}>(args?: Subset<T, Booking$giftCardArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBy<T extends Booking$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Booking$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    statusHistory<T extends Booking$statusHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Booking$statusHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingStatusHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly bookingNumber: FieldRef<"Booking", 'String'>
    readonly type: FieldRef<"Booking", 'BookingType'>
    readonly serviceId: FieldRef<"Booking", 'String'>
    readonly packageId: FieldRef<"Booking", 'String'>
    readonly clientEmail: FieldRef<"Booking", 'String'>
    readonly clientName: FieldRef<"Booking", 'String'>
    readonly clientPhone: FieldRef<"Booking", 'String'>
    readonly specialNotes: FieldRef<"Booking", 'String'>
    readonly bookingDate: FieldRef<"Booking", 'DateTime'>
    readonly startTime: FieldRef<"Booking", 'String'>
    readonly endTime: FieldRef<"Booking", 'String'>
    readonly professionalId: FieldRef<"Booking", 'String'>
    readonly subtotal: FieldRef<"Booking", 'Decimal'>
    readonly taxTPS: FieldRef<"Booking", 'Decimal'>
    readonly taxTVQ: FieldRef<"Booking", 'Decimal'>
    readonly total: FieldRef<"Booking", 'Decimal'>
    readonly giftCardId: FieldRef<"Booking", 'String'>
    readonly giftCardAmount: FieldRef<"Booking", 'Decimal'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly paymentId: FieldRef<"Booking", 'String'>
    readonly reminderSent: FieldRef<"Booking", 'Boolean'>
    readonly googleCalendarEventId: FieldRef<"Booking", 'String'>
    readonly createdById: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking.service
   */
  export type Booking$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * Booking.package
   */
  export type Booking$packageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    where?: PackageWhereInput
  }

  /**
   * Booking.professional
   */
  export type Booking$professionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Booking.giftCard
   */
  export type Booking$giftCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    where?: GiftCardWhereInput
  }

  /**
   * Booking.createdBy
   */
  export type Booking$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Booking.statusHistory
   */
  export type Booking$statusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusHistory
     */
    select?: BookingStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusHistoryInclude<ExtArgs> | null
    where?: BookingStatusHistoryWhereInput
    orderBy?: BookingStatusHistoryOrderByWithRelationInput | BookingStatusHistoryOrderByWithRelationInput[]
    cursor?: BookingStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingStatusHistoryScalarFieldEnum | BookingStatusHistoryScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Availability
   */

  export type AggregateAvailability = {
    _count: AvailabilityCountAggregateOutputType | null
    _min: AvailabilityMinAggregateOutputType | null
    _max: AvailabilityMaxAggregateOutputType | null
  }

  export type AvailabilityMinAggregateOutputType = {
    id: string | null
    professionalId: string | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    isAvailable: boolean | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvailabilityMaxAggregateOutputType = {
    id: string | null
    professionalId: string | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    isAvailable: boolean | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvailabilityCountAggregateOutputType = {
    id: number
    professionalId: number
    date: number
    startTime: number
    endTime: number
    isAvailable: number
    reason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AvailabilityMinAggregateInputType = {
    id?: true
    professionalId?: true
    date?: true
    startTime?: true
    endTime?: true
    isAvailable?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvailabilityMaxAggregateInputType = {
    id?: true
    professionalId?: true
    date?: true
    startTime?: true
    endTime?: true
    isAvailable?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvailabilityCountAggregateInputType = {
    id?: true
    professionalId?: true
    date?: true
    startTime?: true
    endTime?: true
    isAvailable?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Availability to aggregate.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Availabilities
    **/
    _count?: true | AvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvailabilityMaxAggregateInputType
  }

  export type GetAvailabilityAggregateType<T extends AvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvailability[P]>
      : GetScalarType<T[P], AggregateAvailability[P]>
  }




  export type AvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithAggregationInput | AvailabilityOrderByWithAggregationInput[]
    by: AvailabilityScalarFieldEnum[] | AvailabilityScalarFieldEnum
    having?: AvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvailabilityCountAggregateInputType | true
    _min?: AvailabilityMinAggregateInputType
    _max?: AvailabilityMaxAggregateInputType
  }

  export type AvailabilityGroupByOutputType = {
    id: string
    professionalId: string
    date: Date
    startTime: string | null
    endTime: string | null
    isAvailable: boolean
    reason: string | null
    createdAt: Date
    updatedAt: Date
    _count: AvailabilityCountAggregateOutputType | null
    _min: AvailabilityMinAggregateOutputType | null
    _max: AvailabilityMaxAggregateOutputType | null
  }

  type GetAvailabilityGroupByPayload<T extends AvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], AvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type AvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    professionalId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    isAvailable?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    professionalId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    isAvailable?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectScalar = {
    id?: boolean
    professionalId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    isAvailable?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AvailabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Availability"
    objects: {
      professional: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      professionalId: string
      date: Date
      startTime: string | null
      endTime: string | null
      isAvailable: boolean
      reason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["availability"]>
    composites: {}
  }

  type AvailabilityGetPayload<S extends boolean | null | undefined | AvailabilityDefaultArgs> = $Result.GetResult<Prisma.$AvailabilityPayload, S>

  type AvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AvailabilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AvailabilityCountAggregateInputType | true
    }

  export interface AvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Availability'], meta: { name: 'Availability' } }
    /**
     * Find zero or one Availability that matches the filter.
     * @param {AvailabilityFindUniqueArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvailabilityFindUniqueArgs>(args: SelectSubset<T, AvailabilityFindUniqueArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Availability that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AvailabilityFindUniqueOrThrowArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, AvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Availability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindFirstArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvailabilityFindFirstArgs>(args?: SelectSubset<T, AvailabilityFindFirstArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Availability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindFirstOrThrowArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, AvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Availabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Availabilities
     * const availabilities = await prisma.availability.findMany()
     * 
     * // Get first 10 Availabilities
     * const availabilities = await prisma.availability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const availabilityWithIdOnly = await prisma.availability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvailabilityFindManyArgs>(args?: SelectSubset<T, AvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Availability.
     * @param {AvailabilityCreateArgs} args - Arguments to create a Availability.
     * @example
     * // Create one Availability
     * const Availability = await prisma.availability.create({
     *   data: {
     *     // ... data to create a Availability
     *   }
     * })
     * 
     */
    create<T extends AvailabilityCreateArgs>(args: SelectSubset<T, AvailabilityCreateArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Availabilities.
     * @param {AvailabilityCreateManyArgs} args - Arguments to create many Availabilities.
     * @example
     * // Create many Availabilities
     * const availability = await prisma.availability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvailabilityCreateManyArgs>(args?: SelectSubset<T, AvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Availabilities and returns the data saved in the database.
     * @param {AvailabilityCreateManyAndReturnArgs} args - Arguments to create many Availabilities.
     * @example
     * // Create many Availabilities
     * const availability = await prisma.availability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Availabilities and only return the `id`
     * const availabilityWithIdOnly = await prisma.availability.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvailabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, AvailabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Availability.
     * @param {AvailabilityDeleteArgs} args - Arguments to delete one Availability.
     * @example
     * // Delete one Availability
     * const Availability = await prisma.availability.delete({
     *   where: {
     *     // ... filter to delete one Availability
     *   }
     * })
     * 
     */
    delete<T extends AvailabilityDeleteArgs>(args: SelectSubset<T, AvailabilityDeleteArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Availability.
     * @param {AvailabilityUpdateArgs} args - Arguments to update one Availability.
     * @example
     * // Update one Availability
     * const availability = await prisma.availability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvailabilityUpdateArgs>(args: SelectSubset<T, AvailabilityUpdateArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Availabilities.
     * @param {AvailabilityDeleteManyArgs} args - Arguments to filter Availabilities to delete.
     * @example
     * // Delete a few Availabilities
     * const { count } = await prisma.availability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvailabilityDeleteManyArgs>(args?: SelectSubset<T, AvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Availabilities
     * const availability = await prisma.availability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvailabilityUpdateManyArgs>(args: SelectSubset<T, AvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Availability.
     * @param {AvailabilityUpsertArgs} args - Arguments to update or create a Availability.
     * @example
     * // Update or create a Availability
     * const availability = await prisma.availability.upsert({
     *   create: {
     *     // ... data to create a Availability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Availability we want to update
     *   }
     * })
     */
    upsert<T extends AvailabilityUpsertArgs>(args: SelectSubset<T, AvailabilityUpsertArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityCountArgs} args - Arguments to filter Availabilities to count.
     * @example
     * // Count the number of Availabilities
     * const count = await prisma.availability.count({
     *   where: {
     *     // ... the filter for the Availabilities we want to count
     *   }
     * })
    **/
    count<T extends AvailabilityCountArgs>(
      args?: Subset<T, AvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvailabilityAggregateArgs>(args: Subset<T, AvailabilityAggregateArgs>): Prisma.PrismaPromise<GetAvailabilityAggregateType<T>>

    /**
     * Group by Availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: AvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Availability model
   */
  readonly fields: AvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Availability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    professional<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Availability model
   */ 
  interface AvailabilityFieldRefs {
    readonly id: FieldRef<"Availability", 'String'>
    readonly professionalId: FieldRef<"Availability", 'String'>
    readonly date: FieldRef<"Availability", 'DateTime'>
    readonly startTime: FieldRef<"Availability", 'String'>
    readonly endTime: FieldRef<"Availability", 'String'>
    readonly isAvailable: FieldRef<"Availability", 'Boolean'>
    readonly reason: FieldRef<"Availability", 'String'>
    readonly createdAt: FieldRef<"Availability", 'DateTime'>
    readonly updatedAt: FieldRef<"Availability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Availability findUnique
   */
  export type AvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability findUniqueOrThrow
   */
  export type AvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability findFirst
   */
  export type AvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Availabilities.
     */
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability findFirstOrThrow
   */
  export type AvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Availabilities.
     */
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability findMany
   */
  export type AvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availabilities to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability create
   */
  export type AvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Availability.
     */
    data: XOR<AvailabilityCreateInput, AvailabilityUncheckedCreateInput>
  }

  /**
   * Availability createMany
   */
  export type AvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Availabilities.
     */
    data: AvailabilityCreateManyInput | AvailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Availability createManyAndReturn
   */
  export type AvailabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Availabilities.
     */
    data: AvailabilityCreateManyInput | AvailabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Availability update
   */
  export type AvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Availability.
     */
    data: XOR<AvailabilityUpdateInput, AvailabilityUncheckedUpdateInput>
    /**
     * Choose, which Availability to update.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability updateMany
   */
  export type AvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Availabilities.
     */
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which Availabilities to update
     */
    where?: AvailabilityWhereInput
  }

  /**
   * Availability upsert
   */
  export type AvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Availability to update in case it exists.
     */
    where: AvailabilityWhereUniqueInput
    /**
     * In case the Availability found by the `where` argument doesn't exist, create a new Availability with this data.
     */
    create: XOR<AvailabilityCreateInput, AvailabilityUncheckedCreateInput>
    /**
     * In case the Availability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvailabilityUpdateInput, AvailabilityUncheckedUpdateInput>
  }

  /**
   * Availability delete
   */
  export type AvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter which Availability to delete.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability deleteMany
   */
  export type AvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Availabilities to delete
     */
    where?: AvailabilityWhereInput
  }

  /**
   * Availability without action
   */
  export type AvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
  }


  /**
   * Model GiftCard
   */

  export type AggregateGiftCard = {
    _count: GiftCardCountAggregateOutputType | null
    _avg: GiftCardAvgAggregateOutputType | null
    _sum: GiftCardSumAggregateOutputType | null
    _min: GiftCardMinAggregateOutputType | null
    _max: GiftCardMaxAggregateOutputType | null
  }

  export type GiftCardAvgAggregateOutputType = {
    amount: Decimal | null
    balance: Decimal | null
  }

  export type GiftCardSumAggregateOutputType = {
    amount: Decimal | null
    balance: Decimal | null
  }

  export type GiftCardMinAggregateOutputType = {
    id: string | null
    code: string | null
    amount: Decimal | null
    balance: Decimal | null
    purchasedBy: string | null
    recipientName: string | null
    recipientEmail: string | null
    message: string | null
    isActive: boolean | null
    expiresAt: Date | null
    paymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GiftCardMaxAggregateOutputType = {
    id: string | null
    code: string | null
    amount: Decimal | null
    balance: Decimal | null
    purchasedBy: string | null
    recipientName: string | null
    recipientEmail: string | null
    message: string | null
    isActive: boolean | null
    expiresAt: Date | null
    paymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GiftCardCountAggregateOutputType = {
    id: number
    code: number
    amount: number
    balance: number
    purchasedBy: number
    recipientName: number
    recipientEmail: number
    message: number
    isActive: number
    expiresAt: number
    paymentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GiftCardAvgAggregateInputType = {
    amount?: true
    balance?: true
  }

  export type GiftCardSumAggregateInputType = {
    amount?: true
    balance?: true
  }

  export type GiftCardMinAggregateInputType = {
    id?: true
    code?: true
    amount?: true
    balance?: true
    purchasedBy?: true
    recipientName?: true
    recipientEmail?: true
    message?: true
    isActive?: true
    expiresAt?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GiftCardMaxAggregateInputType = {
    id?: true
    code?: true
    amount?: true
    balance?: true
    purchasedBy?: true
    recipientName?: true
    recipientEmail?: true
    message?: true
    isActive?: true
    expiresAt?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GiftCardCountAggregateInputType = {
    id?: true
    code?: true
    amount?: true
    balance?: true
    purchasedBy?: true
    recipientName?: true
    recipientEmail?: true
    message?: true
    isActive?: true
    expiresAt?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GiftCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GiftCard to aggregate.
     */
    where?: GiftCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftCards to fetch.
     */
    orderBy?: GiftCardOrderByWithRelationInput | GiftCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GiftCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GiftCards
    **/
    _count?: true | GiftCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GiftCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GiftCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GiftCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GiftCardMaxAggregateInputType
  }

  export type GetGiftCardAggregateType<T extends GiftCardAggregateArgs> = {
        [P in keyof T & keyof AggregateGiftCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGiftCard[P]>
      : GetScalarType<T[P], AggregateGiftCard[P]>
  }




  export type GiftCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GiftCardWhereInput
    orderBy?: GiftCardOrderByWithAggregationInput | GiftCardOrderByWithAggregationInput[]
    by: GiftCardScalarFieldEnum[] | GiftCardScalarFieldEnum
    having?: GiftCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GiftCardCountAggregateInputType | true
    _avg?: GiftCardAvgAggregateInputType
    _sum?: GiftCardSumAggregateInputType
    _min?: GiftCardMinAggregateInputType
    _max?: GiftCardMaxAggregateInputType
  }

  export type GiftCardGroupByOutputType = {
    id: string
    code: string
    amount: Decimal
    balance: Decimal
    purchasedBy: string | null
    recipientName: string | null
    recipientEmail: string | null
    message: string | null
    isActive: boolean
    expiresAt: Date | null
    paymentId: string
    createdAt: Date
    updatedAt: Date
    _count: GiftCardCountAggregateOutputType | null
    _avg: GiftCardAvgAggregateOutputType | null
    _sum: GiftCardSumAggregateOutputType | null
    _min: GiftCardMinAggregateOutputType | null
    _max: GiftCardMaxAggregateOutputType | null
  }

  type GetGiftCardGroupByPayload<T extends GiftCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GiftCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GiftCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GiftCardGroupByOutputType[P]>
            : GetScalarType<T[P], GiftCardGroupByOutputType[P]>
        }
      >
    >


  export type GiftCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    amount?: boolean
    balance?: boolean
    purchasedBy?: boolean
    recipientName?: boolean
    recipientEmail?: boolean
    message?: boolean
    isActive?: boolean
    expiresAt?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    usedInBookings?: boolean | GiftCard$usedInBookingsArgs<ExtArgs>
    _count?: boolean | GiftCardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["giftCard"]>

  export type GiftCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    amount?: boolean
    balance?: boolean
    purchasedBy?: boolean
    recipientName?: boolean
    recipientEmail?: boolean
    message?: boolean
    isActive?: boolean
    expiresAt?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["giftCard"]>

  export type GiftCardSelectScalar = {
    id?: boolean
    code?: boolean
    amount?: boolean
    balance?: boolean
    purchasedBy?: boolean
    recipientName?: boolean
    recipientEmail?: boolean
    message?: boolean
    isActive?: boolean
    expiresAt?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GiftCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    usedInBookings?: boolean | GiftCard$usedInBookingsArgs<ExtArgs>
    _count?: boolean | GiftCardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GiftCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $GiftCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GiftCard"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
      usedInBookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      amount: Prisma.Decimal
      balance: Prisma.Decimal
      purchasedBy: string | null
      recipientName: string | null
      recipientEmail: string | null
      message: string | null
      isActive: boolean
      expiresAt: Date | null
      paymentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["giftCard"]>
    composites: {}
  }

  type GiftCardGetPayload<S extends boolean | null | undefined | GiftCardDefaultArgs> = $Result.GetResult<Prisma.$GiftCardPayload, S>

  type GiftCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GiftCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GiftCardCountAggregateInputType | true
    }

  export interface GiftCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GiftCard'], meta: { name: 'GiftCard' } }
    /**
     * Find zero or one GiftCard that matches the filter.
     * @param {GiftCardFindUniqueArgs} args - Arguments to find a GiftCard
     * @example
     * // Get one GiftCard
     * const giftCard = await prisma.giftCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GiftCardFindUniqueArgs>(args: SelectSubset<T, GiftCardFindUniqueArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GiftCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GiftCardFindUniqueOrThrowArgs} args - Arguments to find a GiftCard
     * @example
     * // Get one GiftCard
     * const giftCard = await prisma.giftCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GiftCardFindUniqueOrThrowArgs>(args: SelectSubset<T, GiftCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GiftCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCardFindFirstArgs} args - Arguments to find a GiftCard
     * @example
     * // Get one GiftCard
     * const giftCard = await prisma.giftCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GiftCardFindFirstArgs>(args?: SelectSubset<T, GiftCardFindFirstArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GiftCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCardFindFirstOrThrowArgs} args - Arguments to find a GiftCard
     * @example
     * // Get one GiftCard
     * const giftCard = await prisma.giftCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GiftCardFindFirstOrThrowArgs>(args?: SelectSubset<T, GiftCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GiftCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GiftCards
     * const giftCards = await prisma.giftCard.findMany()
     * 
     * // Get first 10 GiftCards
     * const giftCards = await prisma.giftCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const giftCardWithIdOnly = await prisma.giftCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GiftCardFindManyArgs>(args?: SelectSubset<T, GiftCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GiftCard.
     * @param {GiftCardCreateArgs} args - Arguments to create a GiftCard.
     * @example
     * // Create one GiftCard
     * const GiftCard = await prisma.giftCard.create({
     *   data: {
     *     // ... data to create a GiftCard
     *   }
     * })
     * 
     */
    create<T extends GiftCardCreateArgs>(args: SelectSubset<T, GiftCardCreateArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GiftCards.
     * @param {GiftCardCreateManyArgs} args - Arguments to create many GiftCards.
     * @example
     * // Create many GiftCards
     * const giftCard = await prisma.giftCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GiftCardCreateManyArgs>(args?: SelectSubset<T, GiftCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GiftCards and returns the data saved in the database.
     * @param {GiftCardCreateManyAndReturnArgs} args - Arguments to create many GiftCards.
     * @example
     * // Create many GiftCards
     * const giftCard = await prisma.giftCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GiftCards and only return the `id`
     * const giftCardWithIdOnly = await prisma.giftCard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GiftCardCreateManyAndReturnArgs>(args?: SelectSubset<T, GiftCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GiftCard.
     * @param {GiftCardDeleteArgs} args - Arguments to delete one GiftCard.
     * @example
     * // Delete one GiftCard
     * const GiftCard = await prisma.giftCard.delete({
     *   where: {
     *     // ... filter to delete one GiftCard
     *   }
     * })
     * 
     */
    delete<T extends GiftCardDeleteArgs>(args: SelectSubset<T, GiftCardDeleteArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GiftCard.
     * @param {GiftCardUpdateArgs} args - Arguments to update one GiftCard.
     * @example
     * // Update one GiftCard
     * const giftCard = await prisma.giftCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GiftCardUpdateArgs>(args: SelectSubset<T, GiftCardUpdateArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GiftCards.
     * @param {GiftCardDeleteManyArgs} args - Arguments to filter GiftCards to delete.
     * @example
     * // Delete a few GiftCards
     * const { count } = await prisma.giftCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GiftCardDeleteManyArgs>(args?: SelectSubset<T, GiftCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GiftCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GiftCards
     * const giftCard = await prisma.giftCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GiftCardUpdateManyArgs>(args: SelectSubset<T, GiftCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GiftCard.
     * @param {GiftCardUpsertArgs} args - Arguments to update or create a GiftCard.
     * @example
     * // Update or create a GiftCard
     * const giftCard = await prisma.giftCard.upsert({
     *   create: {
     *     // ... data to create a GiftCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GiftCard we want to update
     *   }
     * })
     */
    upsert<T extends GiftCardUpsertArgs>(args: SelectSubset<T, GiftCardUpsertArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GiftCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCardCountArgs} args - Arguments to filter GiftCards to count.
     * @example
     * // Count the number of GiftCards
     * const count = await prisma.giftCard.count({
     *   where: {
     *     // ... the filter for the GiftCards we want to count
     *   }
     * })
    **/
    count<T extends GiftCardCountArgs>(
      args?: Subset<T, GiftCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GiftCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GiftCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GiftCardAggregateArgs>(args: Subset<T, GiftCardAggregateArgs>): Prisma.PrismaPromise<GetGiftCardAggregateType<T>>

    /**
     * Group by GiftCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GiftCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GiftCardGroupByArgs['orderBy'] }
        : { orderBy?: GiftCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GiftCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGiftCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GiftCard model
   */
  readonly fields: GiftCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GiftCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GiftCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usedInBookings<T extends GiftCard$usedInBookingsArgs<ExtArgs> = {}>(args?: Subset<T, GiftCard$usedInBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GiftCard model
   */ 
  interface GiftCardFieldRefs {
    readonly id: FieldRef<"GiftCard", 'String'>
    readonly code: FieldRef<"GiftCard", 'String'>
    readonly amount: FieldRef<"GiftCard", 'Decimal'>
    readonly balance: FieldRef<"GiftCard", 'Decimal'>
    readonly purchasedBy: FieldRef<"GiftCard", 'String'>
    readonly recipientName: FieldRef<"GiftCard", 'String'>
    readonly recipientEmail: FieldRef<"GiftCard", 'String'>
    readonly message: FieldRef<"GiftCard", 'String'>
    readonly isActive: FieldRef<"GiftCard", 'Boolean'>
    readonly expiresAt: FieldRef<"GiftCard", 'DateTime'>
    readonly paymentId: FieldRef<"GiftCard", 'String'>
    readonly createdAt: FieldRef<"GiftCard", 'DateTime'>
    readonly updatedAt: FieldRef<"GiftCard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GiftCard findUnique
   */
  export type GiftCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * Filter, which GiftCard to fetch.
     */
    where: GiftCardWhereUniqueInput
  }

  /**
   * GiftCard findUniqueOrThrow
   */
  export type GiftCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * Filter, which GiftCard to fetch.
     */
    where: GiftCardWhereUniqueInput
  }

  /**
   * GiftCard findFirst
   */
  export type GiftCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * Filter, which GiftCard to fetch.
     */
    where?: GiftCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftCards to fetch.
     */
    orderBy?: GiftCardOrderByWithRelationInput | GiftCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GiftCards.
     */
    cursor?: GiftCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GiftCards.
     */
    distinct?: GiftCardScalarFieldEnum | GiftCardScalarFieldEnum[]
  }

  /**
   * GiftCard findFirstOrThrow
   */
  export type GiftCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * Filter, which GiftCard to fetch.
     */
    where?: GiftCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftCards to fetch.
     */
    orderBy?: GiftCardOrderByWithRelationInput | GiftCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GiftCards.
     */
    cursor?: GiftCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GiftCards.
     */
    distinct?: GiftCardScalarFieldEnum | GiftCardScalarFieldEnum[]
  }

  /**
   * GiftCard findMany
   */
  export type GiftCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * Filter, which GiftCards to fetch.
     */
    where?: GiftCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftCards to fetch.
     */
    orderBy?: GiftCardOrderByWithRelationInput | GiftCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GiftCards.
     */
    cursor?: GiftCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftCards.
     */
    skip?: number
    distinct?: GiftCardScalarFieldEnum | GiftCardScalarFieldEnum[]
  }

  /**
   * GiftCard create
   */
  export type GiftCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * The data needed to create a GiftCard.
     */
    data: XOR<GiftCardCreateInput, GiftCardUncheckedCreateInput>
  }

  /**
   * GiftCard createMany
   */
  export type GiftCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GiftCards.
     */
    data: GiftCardCreateManyInput | GiftCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GiftCard createManyAndReturn
   */
  export type GiftCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GiftCards.
     */
    data: GiftCardCreateManyInput | GiftCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GiftCard update
   */
  export type GiftCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * The data needed to update a GiftCard.
     */
    data: XOR<GiftCardUpdateInput, GiftCardUncheckedUpdateInput>
    /**
     * Choose, which GiftCard to update.
     */
    where: GiftCardWhereUniqueInput
  }

  /**
   * GiftCard updateMany
   */
  export type GiftCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GiftCards.
     */
    data: XOR<GiftCardUpdateManyMutationInput, GiftCardUncheckedUpdateManyInput>
    /**
     * Filter which GiftCards to update
     */
    where?: GiftCardWhereInput
  }

  /**
   * GiftCard upsert
   */
  export type GiftCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * The filter to search for the GiftCard to update in case it exists.
     */
    where: GiftCardWhereUniqueInput
    /**
     * In case the GiftCard found by the `where` argument doesn't exist, create a new GiftCard with this data.
     */
    create: XOR<GiftCardCreateInput, GiftCardUncheckedCreateInput>
    /**
     * In case the GiftCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GiftCardUpdateInput, GiftCardUncheckedUpdateInput>
  }

  /**
   * GiftCard delete
   */
  export type GiftCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * Filter which GiftCard to delete.
     */
    where: GiftCardWhereUniqueInput
  }

  /**
   * GiftCard deleteMany
   */
  export type GiftCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GiftCards to delete
     */
    where?: GiftCardWhereInput
  }

  /**
   * GiftCard.usedInBookings
   */
  export type GiftCard$usedInBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * GiftCard without action
   */
  export type GiftCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
  }


  /**
   * Model GymMembership
   */

  export type AggregateGymMembership = {
    _count: GymMembershipCountAggregateOutputType | null
    _avg: GymMembershipAvgAggregateOutputType | null
    _sum: GymMembershipSumAggregateOutputType | null
    _min: GymMembershipMinAggregateOutputType | null
    _max: GymMembershipMaxAggregateOutputType | null
  }

  export type GymMembershipAvgAggregateOutputType = {
    price: Decimal | null
    duration: number | null
    displayOrder: number | null
  }

  export type GymMembershipSumAggregateOutputType = {
    price: Decimal | null
    duration: number | null
    displayOrder: number | null
  }

  export type GymMembershipMinAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    price: Decimal | null
    duration: number | null
    description: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymMembershipMaxAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    price: Decimal | null
    duration: number | null
    description: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymMembershipCountAggregateOutputType = {
    id: number
    type: number
    name: number
    price: number
    duration: number
    description: number
    displayOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GymMembershipAvgAggregateInputType = {
    price?: true
    duration?: true
    displayOrder?: true
  }

  export type GymMembershipSumAggregateInputType = {
    price?: true
    duration?: true
    displayOrder?: true
  }

  export type GymMembershipMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    price?: true
    duration?: true
    description?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymMembershipMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    price?: true
    duration?: true
    description?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymMembershipCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    price?: true
    duration?: true
    description?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GymMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymMembership to aggregate.
     */
    where?: GymMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymMemberships to fetch.
     */
    orderBy?: GymMembershipOrderByWithRelationInput | GymMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GymMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GymMemberships
    **/
    _count?: true | GymMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GymMembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GymMembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GymMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GymMembershipMaxAggregateInputType
  }

  export type GetGymMembershipAggregateType<T extends GymMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateGymMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGymMembership[P]>
      : GetScalarType<T[P], AggregateGymMembership[P]>
  }




  export type GymMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymMembershipWhereInput
    orderBy?: GymMembershipOrderByWithAggregationInput | GymMembershipOrderByWithAggregationInput[]
    by: GymMembershipScalarFieldEnum[] | GymMembershipScalarFieldEnum
    having?: GymMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GymMembershipCountAggregateInputType | true
    _avg?: GymMembershipAvgAggregateInputType
    _sum?: GymMembershipSumAggregateInputType
    _min?: GymMembershipMinAggregateInputType
    _max?: GymMembershipMaxAggregateInputType
  }

  export type GymMembershipGroupByOutputType = {
    id: string
    type: string
    name: string
    price: Decimal
    duration: number
    description: string | null
    displayOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: GymMembershipCountAggregateOutputType | null
    _avg: GymMembershipAvgAggregateOutputType | null
    _sum: GymMembershipSumAggregateOutputType | null
    _min: GymMembershipMinAggregateOutputType | null
    _max: GymMembershipMaxAggregateOutputType | null
  }

  type GetGymMembershipGroupByPayload<T extends GymMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GymMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GymMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GymMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], GymMembershipGroupByOutputType[P]>
        }
      >
    >


  export type GymMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | GymMembership$subscriptionsArgs<ExtArgs>
    _count?: boolean | GymMembershipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymMembership"]>

  export type GymMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gymMembership"]>

  export type GymMembershipSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    description?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GymMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | GymMembership$subscriptionsArgs<ExtArgs>
    _count?: boolean | GymMembershipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GymMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GymMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GymMembership"
    objects: {
      subscriptions: Prisma.$GymSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      name: string
      price: Prisma.Decimal
      duration: number
      description: string | null
      displayOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gymMembership"]>
    composites: {}
  }

  type GymMembershipGetPayload<S extends boolean | null | undefined | GymMembershipDefaultArgs> = $Result.GetResult<Prisma.$GymMembershipPayload, S>

  type GymMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GymMembershipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GymMembershipCountAggregateInputType | true
    }

  export interface GymMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GymMembership'], meta: { name: 'GymMembership' } }
    /**
     * Find zero or one GymMembership that matches the filter.
     * @param {GymMembershipFindUniqueArgs} args - Arguments to find a GymMembership
     * @example
     * // Get one GymMembership
     * const gymMembership = await prisma.gymMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GymMembershipFindUniqueArgs>(args: SelectSubset<T, GymMembershipFindUniqueArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GymMembership that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GymMembershipFindUniqueOrThrowArgs} args - Arguments to find a GymMembership
     * @example
     * // Get one GymMembership
     * const gymMembership = await prisma.gymMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GymMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, GymMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GymMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymMembershipFindFirstArgs} args - Arguments to find a GymMembership
     * @example
     * // Get one GymMembership
     * const gymMembership = await prisma.gymMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GymMembershipFindFirstArgs>(args?: SelectSubset<T, GymMembershipFindFirstArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GymMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymMembershipFindFirstOrThrowArgs} args - Arguments to find a GymMembership
     * @example
     * // Get one GymMembership
     * const gymMembership = await prisma.gymMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GymMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, GymMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GymMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GymMemberships
     * const gymMemberships = await prisma.gymMembership.findMany()
     * 
     * // Get first 10 GymMemberships
     * const gymMemberships = await prisma.gymMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gymMembershipWithIdOnly = await prisma.gymMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GymMembershipFindManyArgs>(args?: SelectSubset<T, GymMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GymMembership.
     * @param {GymMembershipCreateArgs} args - Arguments to create a GymMembership.
     * @example
     * // Create one GymMembership
     * const GymMembership = await prisma.gymMembership.create({
     *   data: {
     *     // ... data to create a GymMembership
     *   }
     * })
     * 
     */
    create<T extends GymMembershipCreateArgs>(args: SelectSubset<T, GymMembershipCreateArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GymMemberships.
     * @param {GymMembershipCreateManyArgs} args - Arguments to create many GymMemberships.
     * @example
     * // Create many GymMemberships
     * const gymMembership = await prisma.gymMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GymMembershipCreateManyArgs>(args?: SelectSubset<T, GymMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GymMemberships and returns the data saved in the database.
     * @param {GymMembershipCreateManyAndReturnArgs} args - Arguments to create many GymMemberships.
     * @example
     * // Create many GymMemberships
     * const gymMembership = await prisma.gymMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GymMemberships and only return the `id`
     * const gymMembershipWithIdOnly = await prisma.gymMembership.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GymMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, GymMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GymMembership.
     * @param {GymMembershipDeleteArgs} args - Arguments to delete one GymMembership.
     * @example
     * // Delete one GymMembership
     * const GymMembership = await prisma.gymMembership.delete({
     *   where: {
     *     // ... filter to delete one GymMembership
     *   }
     * })
     * 
     */
    delete<T extends GymMembershipDeleteArgs>(args: SelectSubset<T, GymMembershipDeleteArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GymMembership.
     * @param {GymMembershipUpdateArgs} args - Arguments to update one GymMembership.
     * @example
     * // Update one GymMembership
     * const gymMembership = await prisma.gymMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GymMembershipUpdateArgs>(args: SelectSubset<T, GymMembershipUpdateArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GymMemberships.
     * @param {GymMembershipDeleteManyArgs} args - Arguments to filter GymMemberships to delete.
     * @example
     * // Delete a few GymMemberships
     * const { count } = await prisma.gymMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GymMembershipDeleteManyArgs>(args?: SelectSubset<T, GymMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GymMemberships
     * const gymMembership = await prisma.gymMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GymMembershipUpdateManyArgs>(args: SelectSubset<T, GymMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GymMembership.
     * @param {GymMembershipUpsertArgs} args - Arguments to update or create a GymMembership.
     * @example
     * // Update or create a GymMembership
     * const gymMembership = await prisma.gymMembership.upsert({
     *   create: {
     *     // ... data to create a GymMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GymMembership we want to update
     *   }
     * })
     */
    upsert<T extends GymMembershipUpsertArgs>(args: SelectSubset<T, GymMembershipUpsertArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GymMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymMembershipCountArgs} args - Arguments to filter GymMemberships to count.
     * @example
     * // Count the number of GymMemberships
     * const count = await prisma.gymMembership.count({
     *   where: {
     *     // ... the filter for the GymMemberships we want to count
     *   }
     * })
    **/
    count<T extends GymMembershipCountArgs>(
      args?: Subset<T, GymMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GymMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GymMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GymMembershipAggregateArgs>(args: Subset<T, GymMembershipAggregateArgs>): Prisma.PrismaPromise<GetGymMembershipAggregateType<T>>

    /**
     * Group by GymMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GymMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GymMembershipGroupByArgs['orderBy'] }
        : { orderBy?: GymMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GymMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGymMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GymMembership model
   */
  readonly fields: GymMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GymMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GymMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends GymMembership$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, GymMembership$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GymMembership model
   */ 
  interface GymMembershipFieldRefs {
    readonly id: FieldRef<"GymMembership", 'String'>
    readonly type: FieldRef<"GymMembership", 'String'>
    readonly name: FieldRef<"GymMembership", 'String'>
    readonly price: FieldRef<"GymMembership", 'Decimal'>
    readonly duration: FieldRef<"GymMembership", 'Int'>
    readonly description: FieldRef<"GymMembership", 'String'>
    readonly displayOrder: FieldRef<"GymMembership", 'Int'>
    readonly isActive: FieldRef<"GymMembership", 'Boolean'>
    readonly createdAt: FieldRef<"GymMembership", 'DateTime'>
    readonly updatedAt: FieldRef<"GymMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GymMembership findUnique
   */
  export type GymMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GymMembership to fetch.
     */
    where: GymMembershipWhereUniqueInput
  }

  /**
   * GymMembership findUniqueOrThrow
   */
  export type GymMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GymMembership to fetch.
     */
    where: GymMembershipWhereUniqueInput
  }

  /**
   * GymMembership findFirst
   */
  export type GymMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GymMembership to fetch.
     */
    where?: GymMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymMemberships to fetch.
     */
    orderBy?: GymMembershipOrderByWithRelationInput | GymMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymMemberships.
     */
    cursor?: GymMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymMemberships.
     */
    distinct?: GymMembershipScalarFieldEnum | GymMembershipScalarFieldEnum[]
  }

  /**
   * GymMembership findFirstOrThrow
   */
  export type GymMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GymMembership to fetch.
     */
    where?: GymMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymMemberships to fetch.
     */
    orderBy?: GymMembershipOrderByWithRelationInput | GymMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymMemberships.
     */
    cursor?: GymMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymMemberships.
     */
    distinct?: GymMembershipScalarFieldEnum | GymMembershipScalarFieldEnum[]
  }

  /**
   * GymMembership findMany
   */
  export type GymMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * Filter, which GymMemberships to fetch.
     */
    where?: GymMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymMemberships to fetch.
     */
    orderBy?: GymMembershipOrderByWithRelationInput | GymMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GymMemberships.
     */
    cursor?: GymMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymMemberships.
     */
    skip?: number
    distinct?: GymMembershipScalarFieldEnum | GymMembershipScalarFieldEnum[]
  }

  /**
   * GymMembership create
   */
  export type GymMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a GymMembership.
     */
    data: XOR<GymMembershipCreateInput, GymMembershipUncheckedCreateInput>
  }

  /**
   * GymMembership createMany
   */
  export type GymMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GymMemberships.
     */
    data: GymMembershipCreateManyInput | GymMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GymMembership createManyAndReturn
   */
  export type GymMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GymMemberships.
     */
    data: GymMembershipCreateManyInput | GymMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GymMembership update
   */
  export type GymMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a GymMembership.
     */
    data: XOR<GymMembershipUpdateInput, GymMembershipUncheckedUpdateInput>
    /**
     * Choose, which GymMembership to update.
     */
    where: GymMembershipWhereUniqueInput
  }

  /**
   * GymMembership updateMany
   */
  export type GymMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GymMemberships.
     */
    data: XOR<GymMembershipUpdateManyMutationInput, GymMembershipUncheckedUpdateManyInput>
    /**
     * Filter which GymMemberships to update
     */
    where?: GymMembershipWhereInput
  }

  /**
   * GymMembership upsert
   */
  export type GymMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the GymMembership to update in case it exists.
     */
    where: GymMembershipWhereUniqueInput
    /**
     * In case the GymMembership found by the `where` argument doesn't exist, create a new GymMembership with this data.
     */
    create: XOR<GymMembershipCreateInput, GymMembershipUncheckedCreateInput>
    /**
     * In case the GymMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GymMembershipUpdateInput, GymMembershipUncheckedUpdateInput>
  }

  /**
   * GymMembership delete
   */
  export type GymMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
    /**
     * Filter which GymMembership to delete.
     */
    where: GymMembershipWhereUniqueInput
  }

  /**
   * GymMembership deleteMany
   */
  export type GymMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymMemberships to delete
     */
    where?: GymMembershipWhereInput
  }

  /**
   * GymMembership.subscriptions
   */
  export type GymMembership$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    where?: GymSubscriptionWhereInput
    orderBy?: GymSubscriptionOrderByWithRelationInput | GymSubscriptionOrderByWithRelationInput[]
    cursor?: GymSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GymSubscriptionScalarFieldEnum | GymSubscriptionScalarFieldEnum[]
  }

  /**
   * GymMembership without action
   */
  export type GymMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymMembership
     */
    select?: GymMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymMembershipInclude<ExtArgs> | null
  }


  /**
   * Model GymSubscription
   */

  export type AggregateGymSubscription = {
    _count: GymSubscriptionCountAggregateOutputType | null
    _min: GymSubscriptionMinAggregateOutputType | null
    _max: GymSubscriptionMaxAggregateOutputType | null
  }

  export type GymSubscriptionMinAggregateOutputType = {
    id: string | null
    membershipId: string | null
    clientEmail: string | null
    clientName: string | null
    clientPhone: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    paymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymSubscriptionMaxAggregateOutputType = {
    id: string | null
    membershipId: string | null
    clientEmail: string | null
    clientName: string | null
    clientPhone: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    paymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GymSubscriptionCountAggregateOutputType = {
    id: number
    membershipId: number
    clientEmail: number
    clientName: number
    clientPhone: number
    startDate: number
    endDate: number
    isActive: number
    paymentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GymSubscriptionMinAggregateInputType = {
    id?: true
    membershipId?: true
    clientEmail?: true
    clientName?: true
    clientPhone?: true
    startDate?: true
    endDate?: true
    isActive?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymSubscriptionMaxAggregateInputType = {
    id?: true
    membershipId?: true
    clientEmail?: true
    clientName?: true
    clientPhone?: true
    startDate?: true
    endDate?: true
    isActive?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GymSubscriptionCountAggregateInputType = {
    id?: true
    membershipId?: true
    clientEmail?: true
    clientName?: true
    clientPhone?: true
    startDate?: true
    endDate?: true
    isActive?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GymSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymSubscription to aggregate.
     */
    where?: GymSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymSubscriptions to fetch.
     */
    orderBy?: GymSubscriptionOrderByWithRelationInput | GymSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GymSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GymSubscriptions
    **/
    _count?: true | GymSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GymSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GymSubscriptionMaxAggregateInputType
  }

  export type GetGymSubscriptionAggregateType<T extends GymSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateGymSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGymSubscription[P]>
      : GetScalarType<T[P], AggregateGymSubscription[P]>
  }




  export type GymSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GymSubscriptionWhereInput
    orderBy?: GymSubscriptionOrderByWithAggregationInput | GymSubscriptionOrderByWithAggregationInput[]
    by: GymSubscriptionScalarFieldEnum[] | GymSubscriptionScalarFieldEnum
    having?: GymSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GymSubscriptionCountAggregateInputType | true
    _min?: GymSubscriptionMinAggregateInputType
    _max?: GymSubscriptionMaxAggregateInputType
  }

  export type GymSubscriptionGroupByOutputType = {
    id: string
    membershipId: string
    clientEmail: string
    clientName: string
    clientPhone: string
    startDate: Date
    endDate: Date
    isActive: boolean
    paymentId: string
    createdAt: Date
    updatedAt: Date
    _count: GymSubscriptionCountAggregateOutputType | null
    _min: GymSubscriptionMinAggregateOutputType | null
    _max: GymSubscriptionMaxAggregateOutputType | null
  }

  type GetGymSubscriptionGroupByPayload<T extends GymSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GymSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GymSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GymSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], GymSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type GymSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    membershipId?: boolean
    clientEmail?: boolean
    clientName?: boolean
    clientPhone?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    membership?: boolean | GymMembershipDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymSubscription"]>

  export type GymSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    membershipId?: boolean
    clientEmail?: boolean
    clientName?: boolean
    clientPhone?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    membership?: boolean | GymMembershipDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gymSubscription"]>

  export type GymSubscriptionSelectScalar = {
    id?: boolean
    membershipId?: boolean
    clientEmail?: boolean
    clientName?: boolean
    clientPhone?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GymSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membership?: boolean | GymMembershipDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type GymSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membership?: boolean | GymMembershipDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $GymSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GymSubscription"
    objects: {
      membership: Prisma.$GymMembershipPayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      membershipId: string
      clientEmail: string
      clientName: string
      clientPhone: string
      startDate: Date
      endDate: Date
      isActive: boolean
      paymentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gymSubscription"]>
    composites: {}
  }

  type GymSubscriptionGetPayload<S extends boolean | null | undefined | GymSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$GymSubscriptionPayload, S>

  type GymSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GymSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GymSubscriptionCountAggregateInputType | true
    }

  export interface GymSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GymSubscription'], meta: { name: 'GymSubscription' } }
    /**
     * Find zero or one GymSubscription that matches the filter.
     * @param {GymSubscriptionFindUniqueArgs} args - Arguments to find a GymSubscription
     * @example
     * // Get one GymSubscription
     * const gymSubscription = await prisma.gymSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GymSubscriptionFindUniqueArgs>(args: SelectSubset<T, GymSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GymSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GymSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a GymSubscription
     * @example
     * // Get one GymSubscription
     * const gymSubscription = await prisma.gymSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GymSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, GymSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GymSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymSubscriptionFindFirstArgs} args - Arguments to find a GymSubscription
     * @example
     * // Get one GymSubscription
     * const gymSubscription = await prisma.gymSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GymSubscriptionFindFirstArgs>(args?: SelectSubset<T, GymSubscriptionFindFirstArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GymSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymSubscriptionFindFirstOrThrowArgs} args - Arguments to find a GymSubscription
     * @example
     * // Get one GymSubscription
     * const gymSubscription = await prisma.gymSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GymSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, GymSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GymSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GymSubscriptions
     * const gymSubscriptions = await prisma.gymSubscription.findMany()
     * 
     * // Get first 10 GymSubscriptions
     * const gymSubscriptions = await prisma.gymSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gymSubscriptionWithIdOnly = await prisma.gymSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GymSubscriptionFindManyArgs>(args?: SelectSubset<T, GymSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GymSubscription.
     * @param {GymSubscriptionCreateArgs} args - Arguments to create a GymSubscription.
     * @example
     * // Create one GymSubscription
     * const GymSubscription = await prisma.gymSubscription.create({
     *   data: {
     *     // ... data to create a GymSubscription
     *   }
     * })
     * 
     */
    create<T extends GymSubscriptionCreateArgs>(args: SelectSubset<T, GymSubscriptionCreateArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GymSubscriptions.
     * @param {GymSubscriptionCreateManyArgs} args - Arguments to create many GymSubscriptions.
     * @example
     * // Create many GymSubscriptions
     * const gymSubscription = await prisma.gymSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GymSubscriptionCreateManyArgs>(args?: SelectSubset<T, GymSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GymSubscriptions and returns the data saved in the database.
     * @param {GymSubscriptionCreateManyAndReturnArgs} args - Arguments to create many GymSubscriptions.
     * @example
     * // Create many GymSubscriptions
     * const gymSubscription = await prisma.gymSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GymSubscriptions and only return the `id`
     * const gymSubscriptionWithIdOnly = await prisma.gymSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GymSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, GymSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GymSubscription.
     * @param {GymSubscriptionDeleteArgs} args - Arguments to delete one GymSubscription.
     * @example
     * // Delete one GymSubscription
     * const GymSubscription = await prisma.gymSubscription.delete({
     *   where: {
     *     // ... filter to delete one GymSubscription
     *   }
     * })
     * 
     */
    delete<T extends GymSubscriptionDeleteArgs>(args: SelectSubset<T, GymSubscriptionDeleteArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GymSubscription.
     * @param {GymSubscriptionUpdateArgs} args - Arguments to update one GymSubscription.
     * @example
     * // Update one GymSubscription
     * const gymSubscription = await prisma.gymSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GymSubscriptionUpdateArgs>(args: SelectSubset<T, GymSubscriptionUpdateArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GymSubscriptions.
     * @param {GymSubscriptionDeleteManyArgs} args - Arguments to filter GymSubscriptions to delete.
     * @example
     * // Delete a few GymSubscriptions
     * const { count } = await prisma.gymSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GymSubscriptionDeleteManyArgs>(args?: SelectSubset<T, GymSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GymSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GymSubscriptions
     * const gymSubscription = await prisma.gymSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GymSubscriptionUpdateManyArgs>(args: SelectSubset<T, GymSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GymSubscription.
     * @param {GymSubscriptionUpsertArgs} args - Arguments to update or create a GymSubscription.
     * @example
     * // Update or create a GymSubscription
     * const gymSubscription = await prisma.gymSubscription.upsert({
     *   create: {
     *     // ... data to create a GymSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GymSubscription we want to update
     *   }
     * })
     */
    upsert<T extends GymSubscriptionUpsertArgs>(args: SelectSubset<T, GymSubscriptionUpsertArgs<ExtArgs>>): Prisma__GymSubscriptionClient<$Result.GetResult<Prisma.$GymSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GymSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymSubscriptionCountArgs} args - Arguments to filter GymSubscriptions to count.
     * @example
     * // Count the number of GymSubscriptions
     * const count = await prisma.gymSubscription.count({
     *   where: {
     *     // ... the filter for the GymSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends GymSubscriptionCountArgs>(
      args?: Subset<T, GymSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GymSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GymSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GymSubscriptionAggregateArgs>(args: Subset<T, GymSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetGymSubscriptionAggregateType<T>>

    /**
     * Group by GymSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GymSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GymSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GymSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: GymSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GymSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGymSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GymSubscription model
   */
  readonly fields: GymSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GymSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GymSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    membership<T extends GymMembershipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GymMembershipDefaultArgs<ExtArgs>>): Prisma__GymMembershipClient<$Result.GetResult<Prisma.$GymMembershipPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GymSubscription model
   */ 
  interface GymSubscriptionFieldRefs {
    readonly id: FieldRef<"GymSubscription", 'String'>
    readonly membershipId: FieldRef<"GymSubscription", 'String'>
    readonly clientEmail: FieldRef<"GymSubscription", 'String'>
    readonly clientName: FieldRef<"GymSubscription", 'String'>
    readonly clientPhone: FieldRef<"GymSubscription", 'String'>
    readonly startDate: FieldRef<"GymSubscription", 'DateTime'>
    readonly endDate: FieldRef<"GymSubscription", 'DateTime'>
    readonly isActive: FieldRef<"GymSubscription", 'Boolean'>
    readonly paymentId: FieldRef<"GymSubscription", 'String'>
    readonly createdAt: FieldRef<"GymSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"GymSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GymSubscription findUnique
   */
  export type GymSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which GymSubscription to fetch.
     */
    where: GymSubscriptionWhereUniqueInput
  }

  /**
   * GymSubscription findUniqueOrThrow
   */
  export type GymSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which GymSubscription to fetch.
     */
    where: GymSubscriptionWhereUniqueInput
  }

  /**
   * GymSubscription findFirst
   */
  export type GymSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which GymSubscription to fetch.
     */
    where?: GymSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymSubscriptions to fetch.
     */
    orderBy?: GymSubscriptionOrderByWithRelationInput | GymSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymSubscriptions.
     */
    cursor?: GymSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymSubscriptions.
     */
    distinct?: GymSubscriptionScalarFieldEnum | GymSubscriptionScalarFieldEnum[]
  }

  /**
   * GymSubscription findFirstOrThrow
   */
  export type GymSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which GymSubscription to fetch.
     */
    where?: GymSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymSubscriptions to fetch.
     */
    orderBy?: GymSubscriptionOrderByWithRelationInput | GymSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GymSubscriptions.
     */
    cursor?: GymSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GymSubscriptions.
     */
    distinct?: GymSubscriptionScalarFieldEnum | GymSubscriptionScalarFieldEnum[]
  }

  /**
   * GymSubscription findMany
   */
  export type GymSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which GymSubscriptions to fetch.
     */
    where?: GymSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GymSubscriptions to fetch.
     */
    orderBy?: GymSubscriptionOrderByWithRelationInput | GymSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GymSubscriptions.
     */
    cursor?: GymSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GymSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GymSubscriptions.
     */
    skip?: number
    distinct?: GymSubscriptionScalarFieldEnum | GymSubscriptionScalarFieldEnum[]
  }

  /**
   * GymSubscription create
   */
  export type GymSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a GymSubscription.
     */
    data: XOR<GymSubscriptionCreateInput, GymSubscriptionUncheckedCreateInput>
  }

  /**
   * GymSubscription createMany
   */
  export type GymSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GymSubscriptions.
     */
    data: GymSubscriptionCreateManyInput | GymSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GymSubscription createManyAndReturn
   */
  export type GymSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GymSubscriptions.
     */
    data: GymSubscriptionCreateManyInput | GymSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GymSubscription update
   */
  export type GymSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a GymSubscription.
     */
    data: XOR<GymSubscriptionUpdateInput, GymSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which GymSubscription to update.
     */
    where: GymSubscriptionWhereUniqueInput
  }

  /**
   * GymSubscription updateMany
   */
  export type GymSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GymSubscriptions.
     */
    data: XOR<GymSubscriptionUpdateManyMutationInput, GymSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which GymSubscriptions to update
     */
    where?: GymSubscriptionWhereInput
  }

  /**
   * GymSubscription upsert
   */
  export type GymSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the GymSubscription to update in case it exists.
     */
    where: GymSubscriptionWhereUniqueInput
    /**
     * In case the GymSubscription found by the `where` argument doesn't exist, create a new GymSubscription with this data.
     */
    create: XOR<GymSubscriptionCreateInput, GymSubscriptionUncheckedCreateInput>
    /**
     * In case the GymSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GymSubscriptionUpdateInput, GymSubscriptionUncheckedUpdateInput>
  }

  /**
   * GymSubscription delete
   */
  export type GymSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which GymSubscription to delete.
     */
    where: GymSubscriptionWhereUniqueInput
  }

  /**
   * GymSubscription deleteMany
   */
  export type GymSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GymSubscriptions to delete
     */
    where?: GymSubscriptionWhereInput
  }

  /**
   * GymSubscription without action
   */
  export type GymSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GymSubscription
     */
    select?: GymSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GymSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: Decimal | null
    stock: number | null
    displayOrder: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: Decimal | null
    stock: number | null
    displayOrder: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    price: Decimal | null
    stock: number | null
    category: string | null
    imageUrl: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    price: Decimal | null
    stock: number | null
    category: string | null
    imageUrl: string | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    price: number
    stock: number
    category: number
    imageUrl: number
    displayOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    stock?: true
    displayOrder?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    stock?: true
    displayOrder?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    stock?: true
    category?: true
    imageUrl?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    stock?: true
    category?: true
    imageUrl?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    stock?: true
    category?: true
    imageUrl?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    price: Decimal
    stock: number
    category: string | null
    imageUrl: string | null
    displayOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    imageUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    promotions?: boolean | Product$promotionsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    imageUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    imageUrl?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    promotions?: boolean | Product$promotionsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      promotions: Prisma.$ProductPromotionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      price: Prisma.Decimal
      stock: number
      category: string | null
      imageUrl: string | null
      displayOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    promotions<T extends Product$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Product$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPromotionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly slug: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly category: FieldRef<"Product", 'String'>
    readonly imageUrl: FieldRef<"Product", 'String'>
    readonly displayOrder: FieldRef<"Product", 'Int'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.promotions
   */
  export type Product$promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPromotion
     */
    select?: ProductPromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPromotionInclude<ExtArgs> | null
    where?: ProductPromotionWhereInput
    orderBy?: ProductPromotionOrderByWithRelationInput | ProductPromotionOrderByWithRelationInput[]
    cursor?: ProductPromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductPromotionScalarFieldEnum | ProductPromotionScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    subtotal: Decimal | null
    taxTPS: Decimal | null
    taxTVQ: Decimal | null
    total: Decimal | null
  }

  export type OrderSumAggregateOutputType = {
    subtotal: Decimal | null
    taxTPS: Decimal | null
    taxTVQ: Decimal | null
    total: Decimal | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    clientEmail: string | null
    clientName: string | null
    clientPhone: string | null
    shippingAddress: string | null
    subtotal: Decimal | null
    taxTPS: Decimal | null
    taxTVQ: Decimal | null
    total: Decimal | null
    status: $Enums.OrderStatus | null
    paymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    clientEmail: string | null
    clientName: string | null
    clientPhone: string | null
    shippingAddress: string | null
    subtotal: Decimal | null
    taxTPS: Decimal | null
    taxTVQ: Decimal | null
    total: Decimal | null
    status: $Enums.OrderStatus | null
    paymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    clientEmail: number
    clientName: number
    clientPhone: number
    shippingAddress: number
    subtotal: number
    taxTPS: number
    taxTVQ: number
    total: number
    status: number
    paymentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    subtotal?: true
    taxTPS?: true
    taxTVQ?: true
    total?: true
  }

  export type OrderSumAggregateInputType = {
    subtotal?: true
    taxTPS?: true
    taxTVQ?: true
    total?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    clientEmail?: true
    clientName?: true
    clientPhone?: true
    shippingAddress?: true
    subtotal?: true
    taxTPS?: true
    taxTVQ?: true
    total?: true
    status?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    clientEmail?: true
    clientName?: true
    clientPhone?: true
    shippingAddress?: true
    subtotal?: true
    taxTPS?: true
    taxTVQ?: true
    total?: true
    status?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    clientEmail?: true
    clientName?: true
    clientPhone?: true
    shippingAddress?: true
    subtotal?: true
    taxTPS?: true
    taxTVQ?: true
    total?: true
    status?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    orderNumber: string
    clientEmail: string
    clientName: string
    clientPhone: string
    shippingAddress: string | null
    subtotal: Decimal
    taxTPS: Decimal
    taxTVQ: Decimal
    total: Decimal
    status: $Enums.OrderStatus
    paymentId: string
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    clientEmail?: boolean
    clientName?: boolean
    clientPhone?: boolean
    shippingAddress?: boolean
    subtotal?: boolean
    taxTPS?: boolean
    taxTVQ?: boolean
    total?: boolean
    status?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    clientEmail?: boolean
    clientName?: boolean
    clientPhone?: boolean
    shippingAddress?: boolean
    subtotal?: boolean
    taxTPS?: boolean
    taxTVQ?: boolean
    total?: boolean
    status?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    clientEmail?: boolean
    clientName?: boolean
    clientPhone?: boolean
    shippingAddress?: boolean
    subtotal?: boolean
    taxTPS?: boolean
    taxTVQ?: boolean
    total?: boolean
    status?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
      items: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      clientEmail: string
      clientName: string
      clientPhone: string
      shippingAddress: string | null
      subtotal: Prisma.Decimal
      taxTPS: Prisma.Decimal
      taxTVQ: Prisma.Decimal
      total: Prisma.Decimal
      status: $Enums.OrderStatus
      paymentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly clientEmail: FieldRef<"Order", 'String'>
    readonly clientName: FieldRef<"Order", 'String'>
    readonly clientPhone: FieldRef<"Order", 'String'>
    readonly shippingAddress: FieldRef<"Order", 'String'>
    readonly subtotal: FieldRef<"Order", 'Decimal'>
    readonly taxTPS: FieldRef<"Order", 'Decimal'>
    readonly taxTVQ: FieldRef<"Order", 'Decimal'>
    readonly total: FieldRef<"Order", 'Decimal'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly paymentId: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    price: Decimal | null
    createdAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    price: Decimal | null
    createdAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    price: number
    createdAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productId: string
    quantity: number
    price: Decimal
    createdAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
  }

  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string
      quantity: number
      price: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */ 
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly price: FieldRef<"OrderItem", 'Decimal'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionAvgAggregateOutputType = {
    discountValue: Decimal | null
  }

  export type PromotionSumAggregateOutputType = {
    discountValue: Decimal | null
  }

  export type PromotionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    code: string | null
    discountType: $Enums.DiscountType | null
    discountValue: Decimal | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    code: string | null
    discountType: $Enums.DiscountType | null
    discountValue: Decimal | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    code: number
    discountType: number
    discountValue: number
    startDate: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromotionAvgAggregateInputType = {
    discountValue?: true
  }

  export type PromotionSumAggregateInputType = {
    discountValue?: true
  }

  export type PromotionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    discountType?: true
    discountValue?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    discountType?: true
    discountValue?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    discountType?: true
    discountValue?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _avg?: PromotionAvgAggregateInputType
    _sum?: PromotionSumAggregateInputType
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    code: string | null
    discountType: $Enums.DiscountType
    discountValue: Decimal
    startDate: Date
    endDate: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    discountType?: boolean
    discountValue?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    services?: boolean | Promotion$servicesArgs<ExtArgs>
    packages?: boolean | Promotion$packagesArgs<ExtArgs>
    products?: boolean | Promotion$productsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    discountType?: boolean
    discountValue?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    discountType?: boolean
    discountValue?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | Promotion$servicesArgs<ExtArgs>
    packages?: boolean | Promotion$packagesArgs<ExtArgs>
    products?: boolean | Promotion$productsArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromotionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {
      services: Prisma.$ServicePromotionPayload<ExtArgs>[]
      packages: Prisma.$PackagePromotionPayload<ExtArgs>[]
      products: Prisma.$ProductPromotionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      code: string | null
      discountType: $Enums.DiscountType
      discountValue: Prisma.Decimal
      startDate: Date
      endDate: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }

  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromotionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionFindUniqueArgs>(args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Promotion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionFindFirstArgs>(args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionFindManyArgs>(args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
     */
    create<T extends PromotionCreateArgs>(args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Promotions.
     * @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionCreateManyArgs>(args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Promotions and returns the data saved in the database.
     * @param {PromotionCreateManyAndReturnArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
     */
    delete<T extends PromotionDeleteArgs>(args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionUpdateArgs>(args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionDeleteManyArgs>(args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionUpdateManyArgs>(args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
     */
    upsert<T extends PromotionUpsertArgs>(args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends Promotion$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePromotionPayload<ExtArgs>, T, "findMany"> | Null>
    packages<T extends Promotion$packagesArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$packagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePromotionPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Promotion$productsArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPromotionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promotion model
   */ 
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'String'>
    readonly name: FieldRef<"Promotion", 'String'>
    readonly description: FieldRef<"Promotion", 'String'>
    readonly code: FieldRef<"Promotion", 'String'>
    readonly discountType: FieldRef<"Promotion", 'DiscountType'>
    readonly discountValue: FieldRef<"Promotion", 'Decimal'>
    readonly startDate: FieldRef<"Promotion", 'DateTime'>
    readonly endDate: FieldRef<"Promotion", 'DateTime'>
    readonly isActive: FieldRef<"Promotion", 'Boolean'>
    readonly createdAt: FieldRef<"Promotion", 'DateTime'>
    readonly updatedAt: FieldRef<"Promotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }

  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion createManyAndReturn
   */
  export type PromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
  }

  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }

  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
  }

  /**
   * Promotion.services
   */
  export type Promotion$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePromotion
     */
    select?: ServicePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePromotionInclude<ExtArgs> | null
    where?: ServicePromotionWhereInput
    orderBy?: ServicePromotionOrderByWithRelationInput | ServicePromotionOrderByWithRelationInput[]
    cursor?: ServicePromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicePromotionScalarFieldEnum | ServicePromotionScalarFieldEnum[]
  }

  /**
   * Promotion.packages
   */
  export type Promotion$packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagePromotion
     */
    select?: PackagePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagePromotionInclude<ExtArgs> | null
    where?: PackagePromotionWhereInput
    orderBy?: PackagePromotionOrderByWithRelationInput | PackagePromotionOrderByWithRelationInput[]
    cursor?: PackagePromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackagePromotionScalarFieldEnum | PackagePromotionScalarFieldEnum[]
  }

  /**
   * Promotion.products
   */
  export type Promotion$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPromotion
     */
    select?: ProductPromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPromotionInclude<ExtArgs> | null
    where?: ProductPromotionWhereInput
    orderBy?: ProductPromotionOrderByWithRelationInput | ProductPromotionOrderByWithRelationInput[]
    cursor?: ProductPromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductPromotionScalarFieldEnum | ProductPromotionScalarFieldEnum[]
  }

  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
  }


  /**
   * Model ServicePromotion
   */

  export type AggregateServicePromotion = {
    _count: ServicePromotionCountAggregateOutputType | null
    _min: ServicePromotionMinAggregateOutputType | null
    _max: ServicePromotionMaxAggregateOutputType | null
  }

  export type ServicePromotionMinAggregateOutputType = {
    id: string | null
    promotionId: string | null
    serviceId: string | null
    createdAt: Date | null
  }

  export type ServicePromotionMaxAggregateOutputType = {
    id: string | null
    promotionId: string | null
    serviceId: string | null
    createdAt: Date | null
  }

  export type ServicePromotionCountAggregateOutputType = {
    id: number
    promotionId: number
    serviceId: number
    createdAt: number
    _all: number
  }


  export type ServicePromotionMinAggregateInputType = {
    id?: true
    promotionId?: true
    serviceId?: true
    createdAt?: true
  }

  export type ServicePromotionMaxAggregateInputType = {
    id?: true
    promotionId?: true
    serviceId?: true
    createdAt?: true
  }

  export type ServicePromotionCountAggregateInputType = {
    id?: true
    promotionId?: true
    serviceId?: true
    createdAt?: true
    _all?: true
  }

  export type ServicePromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePromotion to aggregate.
     */
    where?: ServicePromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePromotions to fetch.
     */
    orderBy?: ServicePromotionOrderByWithRelationInput | ServicePromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicePromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicePromotions
    **/
    _count?: true | ServicePromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicePromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicePromotionMaxAggregateInputType
  }

  export type GetServicePromotionAggregateType<T extends ServicePromotionAggregateArgs> = {
        [P in keyof T & keyof AggregateServicePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicePromotion[P]>
      : GetScalarType<T[P], AggregateServicePromotion[P]>
  }




  export type ServicePromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePromotionWhereInput
    orderBy?: ServicePromotionOrderByWithAggregationInput | ServicePromotionOrderByWithAggregationInput[]
    by: ServicePromotionScalarFieldEnum[] | ServicePromotionScalarFieldEnum
    having?: ServicePromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicePromotionCountAggregateInputType | true
    _min?: ServicePromotionMinAggregateInputType
    _max?: ServicePromotionMaxAggregateInputType
  }

  export type ServicePromotionGroupByOutputType = {
    id: string
    promotionId: string
    serviceId: string
    createdAt: Date
    _count: ServicePromotionCountAggregateOutputType | null
    _min: ServicePromotionMinAggregateOutputType | null
    _max: ServicePromotionMaxAggregateOutputType | null
  }

  type GetServicePromotionGroupByPayload<T extends ServicePromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicePromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicePromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicePromotionGroupByOutputType[P]>
            : GetScalarType<T[P], ServicePromotionGroupByOutputType[P]>
        }
      >
    >


  export type ServicePromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePromotion"]>

  export type ServicePromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    serviceId?: boolean
    createdAt?: boolean
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePromotion"]>

  export type ServicePromotionSelectScalar = {
    id?: boolean
    promotionId?: boolean
    serviceId?: boolean
    createdAt?: boolean
  }

  export type ServicePromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ServicePromotionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ServicePromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicePromotion"
    objects: {
      promotion: Prisma.$PromotionPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      promotionId: string
      serviceId: string
      createdAt: Date
    }, ExtArgs["result"]["servicePromotion"]>
    composites: {}
  }

  type ServicePromotionGetPayload<S extends boolean | null | undefined | ServicePromotionDefaultArgs> = $Result.GetResult<Prisma.$ServicePromotionPayload, S>

  type ServicePromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServicePromotionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServicePromotionCountAggregateInputType | true
    }

  export interface ServicePromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicePromotion'], meta: { name: 'ServicePromotion' } }
    /**
     * Find zero or one ServicePromotion that matches the filter.
     * @param {ServicePromotionFindUniqueArgs} args - Arguments to find a ServicePromotion
     * @example
     * // Get one ServicePromotion
     * const servicePromotion = await prisma.servicePromotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicePromotionFindUniqueArgs>(args: SelectSubset<T, ServicePromotionFindUniqueArgs<ExtArgs>>): Prisma__ServicePromotionClient<$Result.GetResult<Prisma.$ServicePromotionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServicePromotion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServicePromotionFindUniqueOrThrowArgs} args - Arguments to find a ServicePromotion
     * @example
     * // Get one ServicePromotion
     * const servicePromotion = await prisma.servicePromotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicePromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicePromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicePromotionClient<$Result.GetResult<Prisma.$ServicePromotionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServicePromotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePromotionFindFirstArgs} args - Arguments to find a ServicePromotion
     * @example
     * // Get one ServicePromotion
     * const servicePromotion = await prisma.servicePromotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicePromotionFindFirstArgs>(args?: SelectSubset<T, ServicePromotionFindFirstArgs<ExtArgs>>): Prisma__ServicePromotionClient<$Result.GetResult<Prisma.$ServicePromotionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServicePromotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePromotionFindFirstOrThrowArgs} args - Arguments to find a ServicePromotion
     * @example
     * // Get one ServicePromotion
     * const servicePromotion = await prisma.servicePromotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicePromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicePromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicePromotionClient<$Result.GetResult<Prisma.$ServicePromotionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServicePromotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicePromotions
     * const servicePromotions = await prisma.servicePromotion.findMany()
     * 
     * // Get first 10 ServicePromotions
     * const servicePromotions = await prisma.servicePromotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicePromotionWithIdOnly = await prisma.servicePromotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicePromotionFindManyArgs>(args?: SelectSubset<T, ServicePromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePromotionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServicePromotion.
     * @param {ServicePromotionCreateArgs} args - Arguments to create a ServicePromotion.
     * @example
     * // Create one ServicePromotion
     * const ServicePromotion = await prisma.servicePromotion.create({
     *   data: {
     *     // ... data to create a ServicePromotion
     *   }
     * })
     * 
     */
    create<T extends ServicePromotionCreateArgs>(args: SelectSubset<T, ServicePromotionCreateArgs<ExtArgs>>): Prisma__ServicePromotionClient<$Result.GetResult<Prisma.$ServicePromotionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServicePromotions.
     * @param {ServicePromotionCreateManyArgs} args - Arguments to create many ServicePromotions.
     * @example
     * // Create many ServicePromotions
     * const servicePromotion = await prisma.servicePromotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicePromotionCreateManyArgs>(args?: SelectSubset<T, ServicePromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServicePromotions and returns the data saved in the database.
     * @param {ServicePromotionCreateManyAndReturnArgs} args - Arguments to create many ServicePromotions.
     * @example
     * // Create many ServicePromotions
     * const servicePromotion = await prisma.servicePromotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServicePromotions and only return the `id`
     * const servicePromotionWithIdOnly = await prisma.servicePromotion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicePromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicePromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePromotionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServicePromotion.
     * @param {ServicePromotionDeleteArgs} args - Arguments to delete one ServicePromotion.
     * @example
     * // Delete one ServicePromotion
     * const ServicePromotion = await prisma.servicePromotion.delete({
     *   where: {
     *     // ... filter to delete one ServicePromotion
     *   }
     * })
     * 
     */
    delete<T extends ServicePromotionDeleteArgs>(args: SelectSubset<T, ServicePromotionDeleteArgs<ExtArgs>>): Prisma__ServicePromotionClient<$Result.GetResult<Prisma.$ServicePromotionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServicePromotion.
     * @param {ServicePromotionUpdateArgs} args - Arguments to update one ServicePromotion.
     * @example
     * // Update one ServicePromotion
     * const servicePromotion = await prisma.servicePromotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicePromotionUpdateArgs>(args: SelectSubset<T, ServicePromotionUpdateArgs<ExtArgs>>): Prisma__ServicePromotionClient<$Result.GetResult<Prisma.$ServicePromotionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServicePromotions.
     * @param {ServicePromotionDeleteManyArgs} args - Arguments to filter ServicePromotions to delete.
     * @example
     * // Delete a few ServicePromotions
     * const { count } = await prisma.servicePromotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicePromotionDeleteManyArgs>(args?: SelectSubset<T, ServicePromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicePromotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicePromotions
     * const servicePromotion = await prisma.servicePromotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicePromotionUpdateManyArgs>(args: SelectSubset<T, ServicePromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServicePromotion.
     * @param {ServicePromotionUpsertArgs} args - Arguments to update or create a ServicePromotion.
     * @example
     * // Update or create a ServicePromotion
     * const servicePromotion = await prisma.servicePromotion.upsert({
     *   create: {
     *     // ... data to create a ServicePromotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicePromotion we want to update
     *   }
     * })
     */
    upsert<T extends ServicePromotionUpsertArgs>(args: SelectSubset<T, ServicePromotionUpsertArgs<ExtArgs>>): Prisma__ServicePromotionClient<$Result.GetResult<Prisma.$ServicePromotionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServicePromotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePromotionCountArgs} args - Arguments to filter ServicePromotions to count.
     * @example
     * // Count the number of ServicePromotions
     * const count = await prisma.servicePromotion.count({
     *   where: {
     *     // ... the filter for the ServicePromotions we want to count
     *   }
     * })
    **/
    count<T extends ServicePromotionCountArgs>(
      args?: Subset<T, ServicePromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicePromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicePromotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicePromotionAggregateArgs>(args: Subset<T, ServicePromotionAggregateArgs>): Prisma.PrismaPromise<GetServicePromotionAggregateType<T>>

    /**
     * Group by ServicePromotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicePromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicePromotionGroupByArgs['orderBy'] }
        : { orderBy?: ServicePromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicePromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicePromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicePromotion model
   */
  readonly fields: ServicePromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicePromotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicePromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    promotion<T extends PromotionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromotionDefaultArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicePromotion model
   */ 
  interface ServicePromotionFieldRefs {
    readonly id: FieldRef<"ServicePromotion", 'String'>
    readonly promotionId: FieldRef<"ServicePromotion", 'String'>
    readonly serviceId: FieldRef<"ServicePromotion", 'String'>
    readonly createdAt: FieldRef<"ServicePromotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServicePromotion findUnique
   */
  export type ServicePromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePromotion
     */
    select?: ServicePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePromotionInclude<ExtArgs> | null
    /**
     * Filter, which ServicePromotion to fetch.
     */
    where: ServicePromotionWhereUniqueInput
  }

  /**
   * ServicePromotion findUniqueOrThrow
   */
  export type ServicePromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePromotion
     */
    select?: ServicePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePromotionInclude<ExtArgs> | null
    /**
     * Filter, which ServicePromotion to fetch.
     */
    where: ServicePromotionWhereUniqueInput
  }

  /**
   * ServicePromotion findFirst
   */
  export type ServicePromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePromotion
     */
    select?: ServicePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePromotionInclude<ExtArgs> | null
    /**
     * Filter, which ServicePromotion to fetch.
     */
    where?: ServicePromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePromotions to fetch.
     */
    orderBy?: ServicePromotionOrderByWithRelationInput | ServicePromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePromotions.
     */
    cursor?: ServicePromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePromotions.
     */
    distinct?: ServicePromotionScalarFieldEnum | ServicePromotionScalarFieldEnum[]
  }

  /**
   * ServicePromotion findFirstOrThrow
   */
  export type ServicePromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePromotion
     */
    select?: ServicePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePromotionInclude<ExtArgs> | null
    /**
     * Filter, which ServicePromotion to fetch.
     */
    where?: ServicePromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePromotions to fetch.
     */
    orderBy?: ServicePromotionOrderByWithRelationInput | ServicePromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePromotions.
     */
    cursor?: ServicePromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePromotions.
     */
    distinct?: ServicePromotionScalarFieldEnum | ServicePromotionScalarFieldEnum[]
  }

  /**
   * ServicePromotion findMany
   */
  export type ServicePromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePromotion
     */
    select?: ServicePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePromotionInclude<ExtArgs> | null
    /**
     * Filter, which ServicePromotions to fetch.
     */
    where?: ServicePromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePromotions to fetch.
     */
    orderBy?: ServicePromotionOrderByWithRelationInput | ServicePromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicePromotions.
     */
    cursor?: ServicePromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePromotions.
     */
    skip?: number
    distinct?: ServicePromotionScalarFieldEnum | ServicePromotionScalarFieldEnum[]
  }

  /**
   * ServicePromotion create
   */
  export type ServicePromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePromotion
     */
    select?: ServicePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicePromotion.
     */
    data: XOR<ServicePromotionCreateInput, ServicePromotionUncheckedCreateInput>
  }

  /**
   * ServicePromotion createMany
   */
  export type ServicePromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicePromotions.
     */
    data: ServicePromotionCreateManyInput | ServicePromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicePromotion createManyAndReturn
   */
  export type ServicePromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePromotion
     */
    select?: ServicePromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServicePromotions.
     */
    data: ServicePromotionCreateManyInput | ServicePromotionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePromotionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicePromotion update
   */
  export type ServicePromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePromotion
     */
    select?: ServicePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicePromotion.
     */
    data: XOR<ServicePromotionUpdateInput, ServicePromotionUncheckedUpdateInput>
    /**
     * Choose, which ServicePromotion to update.
     */
    where: ServicePromotionWhereUniqueInput
  }

  /**
   * ServicePromotion updateMany
   */
  export type ServicePromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicePromotions.
     */
    data: XOR<ServicePromotionUpdateManyMutationInput, ServicePromotionUncheckedUpdateManyInput>
    /**
     * Filter which ServicePromotions to update
     */
    where?: ServicePromotionWhereInput
  }

  /**
   * ServicePromotion upsert
   */
  export type ServicePromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePromotion
     */
    select?: ServicePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicePromotion to update in case it exists.
     */
    where: ServicePromotionWhereUniqueInput
    /**
     * In case the ServicePromotion found by the `where` argument doesn't exist, create a new ServicePromotion with this data.
     */
    create: XOR<ServicePromotionCreateInput, ServicePromotionUncheckedCreateInput>
    /**
     * In case the ServicePromotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicePromotionUpdateInput, ServicePromotionUncheckedUpdateInput>
  }

  /**
   * ServicePromotion delete
   */
  export type ServicePromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePromotion
     */
    select?: ServicePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePromotionInclude<ExtArgs> | null
    /**
     * Filter which ServicePromotion to delete.
     */
    where: ServicePromotionWhereUniqueInput
  }

  /**
   * ServicePromotion deleteMany
   */
  export type ServicePromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePromotions to delete
     */
    where?: ServicePromotionWhereInput
  }

  /**
   * ServicePromotion without action
   */
  export type ServicePromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePromotion
     */
    select?: ServicePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePromotionInclude<ExtArgs> | null
  }


  /**
   * Model PackagePromotion
   */

  export type AggregatePackagePromotion = {
    _count: PackagePromotionCountAggregateOutputType | null
    _min: PackagePromotionMinAggregateOutputType | null
    _max: PackagePromotionMaxAggregateOutputType | null
  }

  export type PackagePromotionMinAggregateOutputType = {
    id: string | null
    promotionId: string | null
    packageId: string | null
    createdAt: Date | null
  }

  export type PackagePromotionMaxAggregateOutputType = {
    id: string | null
    promotionId: string | null
    packageId: string | null
    createdAt: Date | null
  }

  export type PackagePromotionCountAggregateOutputType = {
    id: number
    promotionId: number
    packageId: number
    createdAt: number
    _all: number
  }


  export type PackagePromotionMinAggregateInputType = {
    id?: true
    promotionId?: true
    packageId?: true
    createdAt?: true
  }

  export type PackagePromotionMaxAggregateInputType = {
    id?: true
    promotionId?: true
    packageId?: true
    createdAt?: true
  }

  export type PackagePromotionCountAggregateInputType = {
    id?: true
    promotionId?: true
    packageId?: true
    createdAt?: true
    _all?: true
  }

  export type PackagePromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackagePromotion to aggregate.
     */
    where?: PackagePromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackagePromotions to fetch.
     */
    orderBy?: PackagePromotionOrderByWithRelationInput | PackagePromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackagePromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackagePromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackagePromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PackagePromotions
    **/
    _count?: true | PackagePromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackagePromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackagePromotionMaxAggregateInputType
  }

  export type GetPackagePromotionAggregateType<T extends PackagePromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePackagePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackagePromotion[P]>
      : GetScalarType<T[P], AggregatePackagePromotion[P]>
  }




  export type PackagePromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackagePromotionWhereInput
    orderBy?: PackagePromotionOrderByWithAggregationInput | PackagePromotionOrderByWithAggregationInput[]
    by: PackagePromotionScalarFieldEnum[] | PackagePromotionScalarFieldEnum
    having?: PackagePromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackagePromotionCountAggregateInputType | true
    _min?: PackagePromotionMinAggregateInputType
    _max?: PackagePromotionMaxAggregateInputType
  }

  export type PackagePromotionGroupByOutputType = {
    id: string
    promotionId: string
    packageId: string
    createdAt: Date
    _count: PackagePromotionCountAggregateOutputType | null
    _min: PackagePromotionMinAggregateOutputType | null
    _max: PackagePromotionMaxAggregateOutputType | null
  }

  type GetPackagePromotionGroupByPayload<T extends PackagePromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackagePromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackagePromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackagePromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PackagePromotionGroupByOutputType[P]>
        }
      >
    >


  export type PackagePromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    packageId?: boolean
    createdAt?: boolean
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packagePromotion"]>

  export type PackagePromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    packageId?: boolean
    createdAt?: boolean
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packagePromotion"]>

  export type PackagePromotionSelectScalar = {
    id?: boolean
    promotionId?: boolean
    packageId?: boolean
    createdAt?: boolean
  }

  export type PackagePromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }
  export type PackagePromotionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }

  export type $PackagePromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PackagePromotion"
    objects: {
      promotion: Prisma.$PromotionPayload<ExtArgs>
      package: Prisma.$PackagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      promotionId: string
      packageId: string
      createdAt: Date
    }, ExtArgs["result"]["packagePromotion"]>
    composites: {}
  }

  type PackagePromotionGetPayload<S extends boolean | null | undefined | PackagePromotionDefaultArgs> = $Result.GetResult<Prisma.$PackagePromotionPayload, S>

  type PackagePromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PackagePromotionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PackagePromotionCountAggregateInputType | true
    }

  export interface PackagePromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PackagePromotion'], meta: { name: 'PackagePromotion' } }
    /**
     * Find zero or one PackagePromotion that matches the filter.
     * @param {PackagePromotionFindUniqueArgs} args - Arguments to find a PackagePromotion
     * @example
     * // Get one PackagePromotion
     * const packagePromotion = await prisma.packagePromotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackagePromotionFindUniqueArgs>(args: SelectSubset<T, PackagePromotionFindUniqueArgs<ExtArgs>>): Prisma__PackagePromotionClient<$Result.GetResult<Prisma.$PackagePromotionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PackagePromotion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PackagePromotionFindUniqueOrThrowArgs} args - Arguments to find a PackagePromotion
     * @example
     * // Get one PackagePromotion
     * const packagePromotion = await prisma.packagePromotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackagePromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PackagePromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackagePromotionClient<$Result.GetResult<Prisma.$PackagePromotionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PackagePromotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagePromotionFindFirstArgs} args - Arguments to find a PackagePromotion
     * @example
     * // Get one PackagePromotion
     * const packagePromotion = await prisma.packagePromotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackagePromotionFindFirstArgs>(args?: SelectSubset<T, PackagePromotionFindFirstArgs<ExtArgs>>): Prisma__PackagePromotionClient<$Result.GetResult<Prisma.$PackagePromotionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PackagePromotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagePromotionFindFirstOrThrowArgs} args - Arguments to find a PackagePromotion
     * @example
     * // Get one PackagePromotion
     * const packagePromotion = await prisma.packagePromotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackagePromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PackagePromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackagePromotionClient<$Result.GetResult<Prisma.$PackagePromotionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PackagePromotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagePromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PackagePromotions
     * const packagePromotions = await prisma.packagePromotion.findMany()
     * 
     * // Get first 10 PackagePromotions
     * const packagePromotions = await prisma.packagePromotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packagePromotionWithIdOnly = await prisma.packagePromotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackagePromotionFindManyArgs>(args?: SelectSubset<T, PackagePromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePromotionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PackagePromotion.
     * @param {PackagePromotionCreateArgs} args - Arguments to create a PackagePromotion.
     * @example
     * // Create one PackagePromotion
     * const PackagePromotion = await prisma.packagePromotion.create({
     *   data: {
     *     // ... data to create a PackagePromotion
     *   }
     * })
     * 
     */
    create<T extends PackagePromotionCreateArgs>(args: SelectSubset<T, PackagePromotionCreateArgs<ExtArgs>>): Prisma__PackagePromotionClient<$Result.GetResult<Prisma.$PackagePromotionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PackagePromotions.
     * @param {PackagePromotionCreateManyArgs} args - Arguments to create many PackagePromotions.
     * @example
     * // Create many PackagePromotions
     * const packagePromotion = await prisma.packagePromotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackagePromotionCreateManyArgs>(args?: SelectSubset<T, PackagePromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PackagePromotions and returns the data saved in the database.
     * @param {PackagePromotionCreateManyAndReturnArgs} args - Arguments to create many PackagePromotions.
     * @example
     * // Create many PackagePromotions
     * const packagePromotion = await prisma.packagePromotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PackagePromotions and only return the `id`
     * const packagePromotionWithIdOnly = await prisma.packagePromotion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackagePromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, PackagePromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePromotionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PackagePromotion.
     * @param {PackagePromotionDeleteArgs} args - Arguments to delete one PackagePromotion.
     * @example
     * // Delete one PackagePromotion
     * const PackagePromotion = await prisma.packagePromotion.delete({
     *   where: {
     *     // ... filter to delete one PackagePromotion
     *   }
     * })
     * 
     */
    delete<T extends PackagePromotionDeleteArgs>(args: SelectSubset<T, PackagePromotionDeleteArgs<ExtArgs>>): Prisma__PackagePromotionClient<$Result.GetResult<Prisma.$PackagePromotionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PackagePromotion.
     * @param {PackagePromotionUpdateArgs} args - Arguments to update one PackagePromotion.
     * @example
     * // Update one PackagePromotion
     * const packagePromotion = await prisma.packagePromotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackagePromotionUpdateArgs>(args: SelectSubset<T, PackagePromotionUpdateArgs<ExtArgs>>): Prisma__PackagePromotionClient<$Result.GetResult<Prisma.$PackagePromotionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PackagePromotions.
     * @param {PackagePromotionDeleteManyArgs} args - Arguments to filter PackagePromotions to delete.
     * @example
     * // Delete a few PackagePromotions
     * const { count } = await prisma.packagePromotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackagePromotionDeleteManyArgs>(args?: SelectSubset<T, PackagePromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackagePromotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagePromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PackagePromotions
     * const packagePromotion = await prisma.packagePromotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackagePromotionUpdateManyArgs>(args: SelectSubset<T, PackagePromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PackagePromotion.
     * @param {PackagePromotionUpsertArgs} args - Arguments to update or create a PackagePromotion.
     * @example
     * // Update or create a PackagePromotion
     * const packagePromotion = await prisma.packagePromotion.upsert({
     *   create: {
     *     // ... data to create a PackagePromotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PackagePromotion we want to update
     *   }
     * })
     */
    upsert<T extends PackagePromotionUpsertArgs>(args: SelectSubset<T, PackagePromotionUpsertArgs<ExtArgs>>): Prisma__PackagePromotionClient<$Result.GetResult<Prisma.$PackagePromotionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PackagePromotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagePromotionCountArgs} args - Arguments to filter PackagePromotions to count.
     * @example
     * // Count the number of PackagePromotions
     * const count = await prisma.packagePromotion.count({
     *   where: {
     *     // ... the filter for the PackagePromotions we want to count
     *   }
     * })
    **/
    count<T extends PackagePromotionCountArgs>(
      args?: Subset<T, PackagePromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackagePromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PackagePromotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagePromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackagePromotionAggregateArgs>(args: Subset<T, PackagePromotionAggregateArgs>): Prisma.PrismaPromise<GetPackagePromotionAggregateType<T>>

    /**
     * Group by PackagePromotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagePromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackagePromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackagePromotionGroupByArgs['orderBy'] }
        : { orderBy?: PackagePromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackagePromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackagePromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PackagePromotion model
   */
  readonly fields: PackagePromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PackagePromotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackagePromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    promotion<T extends PromotionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromotionDefaultArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    package<T extends PackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PackageDefaultArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PackagePromotion model
   */ 
  interface PackagePromotionFieldRefs {
    readonly id: FieldRef<"PackagePromotion", 'String'>
    readonly promotionId: FieldRef<"PackagePromotion", 'String'>
    readonly packageId: FieldRef<"PackagePromotion", 'String'>
    readonly createdAt: FieldRef<"PackagePromotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PackagePromotion findUnique
   */
  export type PackagePromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagePromotion
     */
    select?: PackagePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagePromotionInclude<ExtArgs> | null
    /**
     * Filter, which PackagePromotion to fetch.
     */
    where: PackagePromotionWhereUniqueInput
  }

  /**
   * PackagePromotion findUniqueOrThrow
   */
  export type PackagePromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagePromotion
     */
    select?: PackagePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagePromotionInclude<ExtArgs> | null
    /**
     * Filter, which PackagePromotion to fetch.
     */
    where: PackagePromotionWhereUniqueInput
  }

  /**
   * PackagePromotion findFirst
   */
  export type PackagePromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagePromotion
     */
    select?: PackagePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagePromotionInclude<ExtArgs> | null
    /**
     * Filter, which PackagePromotion to fetch.
     */
    where?: PackagePromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackagePromotions to fetch.
     */
    orderBy?: PackagePromotionOrderByWithRelationInput | PackagePromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackagePromotions.
     */
    cursor?: PackagePromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackagePromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackagePromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackagePromotions.
     */
    distinct?: PackagePromotionScalarFieldEnum | PackagePromotionScalarFieldEnum[]
  }

  /**
   * PackagePromotion findFirstOrThrow
   */
  export type PackagePromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagePromotion
     */
    select?: PackagePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagePromotionInclude<ExtArgs> | null
    /**
     * Filter, which PackagePromotion to fetch.
     */
    where?: PackagePromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackagePromotions to fetch.
     */
    orderBy?: PackagePromotionOrderByWithRelationInput | PackagePromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackagePromotions.
     */
    cursor?: PackagePromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackagePromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackagePromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackagePromotions.
     */
    distinct?: PackagePromotionScalarFieldEnum | PackagePromotionScalarFieldEnum[]
  }

  /**
   * PackagePromotion findMany
   */
  export type PackagePromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagePromotion
     */
    select?: PackagePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagePromotionInclude<ExtArgs> | null
    /**
     * Filter, which PackagePromotions to fetch.
     */
    where?: PackagePromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackagePromotions to fetch.
     */
    orderBy?: PackagePromotionOrderByWithRelationInput | PackagePromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PackagePromotions.
     */
    cursor?: PackagePromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackagePromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackagePromotions.
     */
    skip?: number
    distinct?: PackagePromotionScalarFieldEnum | PackagePromotionScalarFieldEnum[]
  }

  /**
   * PackagePromotion create
   */
  export type PackagePromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagePromotion
     */
    select?: PackagePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagePromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a PackagePromotion.
     */
    data: XOR<PackagePromotionCreateInput, PackagePromotionUncheckedCreateInput>
  }

  /**
   * PackagePromotion createMany
   */
  export type PackagePromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PackagePromotions.
     */
    data: PackagePromotionCreateManyInput | PackagePromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackagePromotion createManyAndReturn
   */
  export type PackagePromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagePromotion
     */
    select?: PackagePromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PackagePromotions.
     */
    data: PackagePromotionCreateManyInput | PackagePromotionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagePromotionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PackagePromotion update
   */
  export type PackagePromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagePromotion
     */
    select?: PackagePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagePromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a PackagePromotion.
     */
    data: XOR<PackagePromotionUpdateInput, PackagePromotionUncheckedUpdateInput>
    /**
     * Choose, which PackagePromotion to update.
     */
    where: PackagePromotionWhereUniqueInput
  }

  /**
   * PackagePromotion updateMany
   */
  export type PackagePromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PackagePromotions.
     */
    data: XOR<PackagePromotionUpdateManyMutationInput, PackagePromotionUncheckedUpdateManyInput>
    /**
     * Filter which PackagePromotions to update
     */
    where?: PackagePromotionWhereInput
  }

  /**
   * PackagePromotion upsert
   */
  export type PackagePromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagePromotion
     */
    select?: PackagePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagePromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the PackagePromotion to update in case it exists.
     */
    where: PackagePromotionWhereUniqueInput
    /**
     * In case the PackagePromotion found by the `where` argument doesn't exist, create a new PackagePromotion with this data.
     */
    create: XOR<PackagePromotionCreateInput, PackagePromotionUncheckedCreateInput>
    /**
     * In case the PackagePromotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackagePromotionUpdateInput, PackagePromotionUncheckedUpdateInput>
  }

  /**
   * PackagePromotion delete
   */
  export type PackagePromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagePromotion
     */
    select?: PackagePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagePromotionInclude<ExtArgs> | null
    /**
     * Filter which PackagePromotion to delete.
     */
    where: PackagePromotionWhereUniqueInput
  }

  /**
   * PackagePromotion deleteMany
   */
  export type PackagePromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackagePromotions to delete
     */
    where?: PackagePromotionWhereInput
  }

  /**
   * PackagePromotion without action
   */
  export type PackagePromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagePromotion
     */
    select?: PackagePromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagePromotionInclude<ExtArgs> | null
  }


  /**
   * Model ProductPromotion
   */

  export type AggregateProductPromotion = {
    _count: ProductPromotionCountAggregateOutputType | null
    _min: ProductPromotionMinAggregateOutputType | null
    _max: ProductPromotionMaxAggregateOutputType | null
  }

  export type ProductPromotionMinAggregateOutputType = {
    id: string | null
    promotionId: string | null
    productId: string | null
    createdAt: Date | null
  }

  export type ProductPromotionMaxAggregateOutputType = {
    id: string | null
    promotionId: string | null
    productId: string | null
    createdAt: Date | null
  }

  export type ProductPromotionCountAggregateOutputType = {
    id: number
    promotionId: number
    productId: number
    createdAt: number
    _all: number
  }


  export type ProductPromotionMinAggregateInputType = {
    id?: true
    promotionId?: true
    productId?: true
    createdAt?: true
  }

  export type ProductPromotionMaxAggregateInputType = {
    id?: true
    promotionId?: true
    productId?: true
    createdAt?: true
  }

  export type ProductPromotionCountAggregateInputType = {
    id?: true
    promotionId?: true
    productId?: true
    createdAt?: true
    _all?: true
  }

  export type ProductPromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductPromotion to aggregate.
     */
    where?: ProductPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPromotions to fetch.
     */
    orderBy?: ProductPromotionOrderByWithRelationInput | ProductPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductPromotions
    **/
    _count?: true | ProductPromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductPromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductPromotionMaxAggregateInputType
  }

  export type GetProductPromotionAggregateType<T extends ProductPromotionAggregateArgs> = {
        [P in keyof T & keyof AggregateProductPromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductPromotion[P]>
      : GetScalarType<T[P], AggregateProductPromotion[P]>
  }




  export type ProductPromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductPromotionWhereInput
    orderBy?: ProductPromotionOrderByWithAggregationInput | ProductPromotionOrderByWithAggregationInput[]
    by: ProductPromotionScalarFieldEnum[] | ProductPromotionScalarFieldEnum
    having?: ProductPromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductPromotionCountAggregateInputType | true
    _min?: ProductPromotionMinAggregateInputType
    _max?: ProductPromotionMaxAggregateInputType
  }

  export type ProductPromotionGroupByOutputType = {
    id: string
    promotionId: string
    productId: string
    createdAt: Date
    _count: ProductPromotionCountAggregateOutputType | null
    _min: ProductPromotionMinAggregateOutputType | null
    _max: ProductPromotionMaxAggregateOutputType | null
  }

  type GetProductPromotionGroupByPayload<T extends ProductPromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductPromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductPromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductPromotionGroupByOutputType[P]>
            : GetScalarType<T[P], ProductPromotionGroupByOutputType[P]>
        }
      >
    >


  export type ProductPromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    productId?: boolean
    createdAt?: boolean
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productPromotion"]>

  export type ProductPromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    productId?: boolean
    createdAt?: boolean
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productPromotion"]>

  export type ProductPromotionSelectScalar = {
    id?: boolean
    promotionId?: boolean
    productId?: boolean
    createdAt?: boolean
  }

  export type ProductPromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductPromotionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductPromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductPromotion"
    objects: {
      promotion: Prisma.$PromotionPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      promotionId: string
      productId: string
      createdAt: Date
    }, ExtArgs["result"]["productPromotion"]>
    composites: {}
  }

  type ProductPromotionGetPayload<S extends boolean | null | undefined | ProductPromotionDefaultArgs> = $Result.GetResult<Prisma.$ProductPromotionPayload, S>

  type ProductPromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductPromotionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductPromotionCountAggregateInputType | true
    }

  export interface ProductPromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductPromotion'], meta: { name: 'ProductPromotion' } }
    /**
     * Find zero or one ProductPromotion that matches the filter.
     * @param {ProductPromotionFindUniqueArgs} args - Arguments to find a ProductPromotion
     * @example
     * // Get one ProductPromotion
     * const productPromotion = await prisma.productPromotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductPromotionFindUniqueArgs>(args: SelectSubset<T, ProductPromotionFindUniqueArgs<ExtArgs>>): Prisma__ProductPromotionClient<$Result.GetResult<Prisma.$ProductPromotionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductPromotion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductPromotionFindUniqueOrThrowArgs} args - Arguments to find a ProductPromotion
     * @example
     * // Get one ProductPromotion
     * const productPromotion = await prisma.productPromotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductPromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductPromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductPromotionClient<$Result.GetResult<Prisma.$ProductPromotionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductPromotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPromotionFindFirstArgs} args - Arguments to find a ProductPromotion
     * @example
     * // Get one ProductPromotion
     * const productPromotion = await prisma.productPromotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductPromotionFindFirstArgs>(args?: SelectSubset<T, ProductPromotionFindFirstArgs<ExtArgs>>): Prisma__ProductPromotionClient<$Result.GetResult<Prisma.$ProductPromotionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductPromotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPromotionFindFirstOrThrowArgs} args - Arguments to find a ProductPromotion
     * @example
     * // Get one ProductPromotion
     * const productPromotion = await prisma.productPromotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductPromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductPromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductPromotionClient<$Result.GetResult<Prisma.$ProductPromotionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductPromotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductPromotions
     * const productPromotions = await prisma.productPromotion.findMany()
     * 
     * // Get first 10 ProductPromotions
     * const productPromotions = await prisma.productPromotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productPromotionWithIdOnly = await prisma.productPromotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductPromotionFindManyArgs>(args?: SelectSubset<T, ProductPromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPromotionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductPromotion.
     * @param {ProductPromotionCreateArgs} args - Arguments to create a ProductPromotion.
     * @example
     * // Create one ProductPromotion
     * const ProductPromotion = await prisma.productPromotion.create({
     *   data: {
     *     // ... data to create a ProductPromotion
     *   }
     * })
     * 
     */
    create<T extends ProductPromotionCreateArgs>(args: SelectSubset<T, ProductPromotionCreateArgs<ExtArgs>>): Prisma__ProductPromotionClient<$Result.GetResult<Prisma.$ProductPromotionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductPromotions.
     * @param {ProductPromotionCreateManyArgs} args - Arguments to create many ProductPromotions.
     * @example
     * // Create many ProductPromotions
     * const productPromotion = await prisma.productPromotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductPromotionCreateManyArgs>(args?: SelectSubset<T, ProductPromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductPromotions and returns the data saved in the database.
     * @param {ProductPromotionCreateManyAndReturnArgs} args - Arguments to create many ProductPromotions.
     * @example
     * // Create many ProductPromotions
     * const productPromotion = await prisma.productPromotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductPromotions and only return the `id`
     * const productPromotionWithIdOnly = await prisma.productPromotion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductPromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductPromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPromotionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductPromotion.
     * @param {ProductPromotionDeleteArgs} args - Arguments to delete one ProductPromotion.
     * @example
     * // Delete one ProductPromotion
     * const ProductPromotion = await prisma.productPromotion.delete({
     *   where: {
     *     // ... filter to delete one ProductPromotion
     *   }
     * })
     * 
     */
    delete<T extends ProductPromotionDeleteArgs>(args: SelectSubset<T, ProductPromotionDeleteArgs<ExtArgs>>): Prisma__ProductPromotionClient<$Result.GetResult<Prisma.$ProductPromotionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductPromotion.
     * @param {ProductPromotionUpdateArgs} args - Arguments to update one ProductPromotion.
     * @example
     * // Update one ProductPromotion
     * const productPromotion = await prisma.productPromotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductPromotionUpdateArgs>(args: SelectSubset<T, ProductPromotionUpdateArgs<ExtArgs>>): Prisma__ProductPromotionClient<$Result.GetResult<Prisma.$ProductPromotionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductPromotions.
     * @param {ProductPromotionDeleteManyArgs} args - Arguments to filter ProductPromotions to delete.
     * @example
     * // Delete a few ProductPromotions
     * const { count } = await prisma.productPromotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductPromotionDeleteManyArgs>(args?: SelectSubset<T, ProductPromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductPromotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductPromotions
     * const productPromotion = await prisma.productPromotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductPromotionUpdateManyArgs>(args: SelectSubset<T, ProductPromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductPromotion.
     * @param {ProductPromotionUpsertArgs} args - Arguments to update or create a ProductPromotion.
     * @example
     * // Update or create a ProductPromotion
     * const productPromotion = await prisma.productPromotion.upsert({
     *   create: {
     *     // ... data to create a ProductPromotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductPromotion we want to update
     *   }
     * })
     */
    upsert<T extends ProductPromotionUpsertArgs>(args: SelectSubset<T, ProductPromotionUpsertArgs<ExtArgs>>): Prisma__ProductPromotionClient<$Result.GetResult<Prisma.$ProductPromotionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductPromotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPromotionCountArgs} args - Arguments to filter ProductPromotions to count.
     * @example
     * // Count the number of ProductPromotions
     * const count = await prisma.productPromotion.count({
     *   where: {
     *     // ... the filter for the ProductPromotions we want to count
     *   }
     * })
    **/
    count<T extends ProductPromotionCountArgs>(
      args?: Subset<T, ProductPromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductPromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductPromotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductPromotionAggregateArgs>(args: Subset<T, ProductPromotionAggregateArgs>): Prisma.PrismaPromise<GetProductPromotionAggregateType<T>>

    /**
     * Group by ProductPromotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductPromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductPromotionGroupByArgs['orderBy'] }
        : { orderBy?: ProductPromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductPromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductPromotion model
   */
  readonly fields: ProductPromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductPromotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductPromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    promotion<T extends PromotionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromotionDefaultArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductPromotion model
   */ 
  interface ProductPromotionFieldRefs {
    readonly id: FieldRef<"ProductPromotion", 'String'>
    readonly promotionId: FieldRef<"ProductPromotion", 'String'>
    readonly productId: FieldRef<"ProductPromotion", 'String'>
    readonly createdAt: FieldRef<"ProductPromotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductPromotion findUnique
   */
  export type ProductPromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPromotion
     */
    select?: ProductPromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPromotionInclude<ExtArgs> | null
    /**
     * Filter, which ProductPromotion to fetch.
     */
    where: ProductPromotionWhereUniqueInput
  }

  /**
   * ProductPromotion findUniqueOrThrow
   */
  export type ProductPromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPromotion
     */
    select?: ProductPromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPromotionInclude<ExtArgs> | null
    /**
     * Filter, which ProductPromotion to fetch.
     */
    where: ProductPromotionWhereUniqueInput
  }

  /**
   * ProductPromotion findFirst
   */
  export type ProductPromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPromotion
     */
    select?: ProductPromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPromotionInclude<ExtArgs> | null
    /**
     * Filter, which ProductPromotion to fetch.
     */
    where?: ProductPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPromotions to fetch.
     */
    orderBy?: ProductPromotionOrderByWithRelationInput | ProductPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPromotions.
     */
    cursor?: ProductPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPromotions.
     */
    distinct?: ProductPromotionScalarFieldEnum | ProductPromotionScalarFieldEnum[]
  }

  /**
   * ProductPromotion findFirstOrThrow
   */
  export type ProductPromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPromotion
     */
    select?: ProductPromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPromotionInclude<ExtArgs> | null
    /**
     * Filter, which ProductPromotion to fetch.
     */
    where?: ProductPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPromotions to fetch.
     */
    orderBy?: ProductPromotionOrderByWithRelationInput | ProductPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPromotions.
     */
    cursor?: ProductPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPromotions.
     */
    distinct?: ProductPromotionScalarFieldEnum | ProductPromotionScalarFieldEnum[]
  }

  /**
   * ProductPromotion findMany
   */
  export type ProductPromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPromotion
     */
    select?: ProductPromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPromotionInclude<ExtArgs> | null
    /**
     * Filter, which ProductPromotions to fetch.
     */
    where?: ProductPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPromotions to fetch.
     */
    orderBy?: ProductPromotionOrderByWithRelationInput | ProductPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductPromotions.
     */
    cursor?: ProductPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPromotions.
     */
    skip?: number
    distinct?: ProductPromotionScalarFieldEnum | ProductPromotionScalarFieldEnum[]
  }

  /**
   * ProductPromotion create
   */
  export type ProductPromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPromotion
     */
    select?: ProductPromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductPromotion.
     */
    data: XOR<ProductPromotionCreateInput, ProductPromotionUncheckedCreateInput>
  }

  /**
   * ProductPromotion createMany
   */
  export type ProductPromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductPromotions.
     */
    data: ProductPromotionCreateManyInput | ProductPromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductPromotion createManyAndReturn
   */
  export type ProductPromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPromotion
     */
    select?: ProductPromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductPromotions.
     */
    data: ProductPromotionCreateManyInput | ProductPromotionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPromotionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductPromotion update
   */
  export type ProductPromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPromotion
     */
    select?: ProductPromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductPromotion.
     */
    data: XOR<ProductPromotionUpdateInput, ProductPromotionUncheckedUpdateInput>
    /**
     * Choose, which ProductPromotion to update.
     */
    where: ProductPromotionWhereUniqueInput
  }

  /**
   * ProductPromotion updateMany
   */
  export type ProductPromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductPromotions.
     */
    data: XOR<ProductPromotionUpdateManyMutationInput, ProductPromotionUncheckedUpdateManyInput>
    /**
     * Filter which ProductPromotions to update
     */
    where?: ProductPromotionWhereInput
  }

  /**
   * ProductPromotion upsert
   */
  export type ProductPromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPromotion
     */
    select?: ProductPromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductPromotion to update in case it exists.
     */
    where: ProductPromotionWhereUniqueInput
    /**
     * In case the ProductPromotion found by the `where` argument doesn't exist, create a new ProductPromotion with this data.
     */
    create: XOR<ProductPromotionCreateInput, ProductPromotionUncheckedCreateInput>
    /**
     * In case the ProductPromotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductPromotionUpdateInput, ProductPromotionUncheckedUpdateInput>
  }

  /**
   * ProductPromotion delete
   */
  export type ProductPromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPromotion
     */
    select?: ProductPromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPromotionInclude<ExtArgs> | null
    /**
     * Filter which ProductPromotion to delete.
     */
    where: ProductPromotionWhereUniqueInput
  }

  /**
   * ProductPromotion deleteMany
   */
  export type ProductPromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductPromotions to delete
     */
    where?: ProductPromotionWhereInput
  }

  /**
   * ProductPromotion without action
   */
  export type ProductPromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPromotion
     */
    select?: ProductPromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPromotionInclude<ExtArgs> | null
  }


  /**
   * Model BookingStatusHistory
   */

  export type AggregateBookingStatusHistory = {
    _count: BookingStatusHistoryCountAggregateOutputType | null
    _min: BookingStatusHistoryMinAggregateOutputType | null
    _max: BookingStatusHistoryMaxAggregateOutputType | null
  }

  export type BookingStatusHistoryMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    oldStatus: $Enums.BookingStatus | null
    newStatus: $Enums.BookingStatus | null
    changedById: string | null
    changedBy: string | null
    changedByRole: string | null
    reason: string | null
    notes: string | null
    oldDate: Date | null
    newDate: Date | null
    oldStartTime: string | null
    newStartTime: string | null
    oldEndTime: string | null
    newEndTime: string | null
    oldProfessionalId: string | null
    newProfessionalId: string | null
    changedAt: Date | null
  }

  export type BookingStatusHistoryMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    oldStatus: $Enums.BookingStatus | null
    newStatus: $Enums.BookingStatus | null
    changedById: string | null
    changedBy: string | null
    changedByRole: string | null
    reason: string | null
    notes: string | null
    oldDate: Date | null
    newDate: Date | null
    oldStartTime: string | null
    newStartTime: string | null
    oldEndTime: string | null
    newEndTime: string | null
    oldProfessionalId: string | null
    newProfessionalId: string | null
    changedAt: Date | null
  }

  export type BookingStatusHistoryCountAggregateOutputType = {
    id: number
    bookingId: number
    oldStatus: number
    newStatus: number
    changedById: number
    changedBy: number
    changedByRole: number
    reason: number
    notes: number
    oldDate: number
    newDate: number
    oldStartTime: number
    newStartTime: number
    oldEndTime: number
    newEndTime: number
    oldProfessionalId: number
    newProfessionalId: number
    changedAt: number
    _all: number
  }


  export type BookingStatusHistoryMinAggregateInputType = {
    id?: true
    bookingId?: true
    oldStatus?: true
    newStatus?: true
    changedById?: true
    changedBy?: true
    changedByRole?: true
    reason?: true
    notes?: true
    oldDate?: true
    newDate?: true
    oldStartTime?: true
    newStartTime?: true
    oldEndTime?: true
    newEndTime?: true
    oldProfessionalId?: true
    newProfessionalId?: true
    changedAt?: true
  }

  export type BookingStatusHistoryMaxAggregateInputType = {
    id?: true
    bookingId?: true
    oldStatus?: true
    newStatus?: true
    changedById?: true
    changedBy?: true
    changedByRole?: true
    reason?: true
    notes?: true
    oldDate?: true
    newDate?: true
    oldStartTime?: true
    newStartTime?: true
    oldEndTime?: true
    newEndTime?: true
    oldProfessionalId?: true
    newProfessionalId?: true
    changedAt?: true
  }

  export type BookingStatusHistoryCountAggregateInputType = {
    id?: true
    bookingId?: true
    oldStatus?: true
    newStatus?: true
    changedById?: true
    changedBy?: true
    changedByRole?: true
    reason?: true
    notes?: true
    oldDate?: true
    newDate?: true
    oldStartTime?: true
    newStartTime?: true
    oldEndTime?: true
    newEndTime?: true
    oldProfessionalId?: true
    newProfessionalId?: true
    changedAt?: true
    _all?: true
  }

  export type BookingStatusHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingStatusHistory to aggregate.
     */
    where?: BookingStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStatusHistories to fetch.
     */
    orderBy?: BookingStatusHistoryOrderByWithRelationInput | BookingStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingStatusHistories
    **/
    _count?: true | BookingStatusHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingStatusHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingStatusHistoryMaxAggregateInputType
  }

  export type GetBookingStatusHistoryAggregateType<T extends BookingStatusHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingStatusHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingStatusHistory[P]>
      : GetScalarType<T[P], AggregateBookingStatusHistory[P]>
  }




  export type BookingStatusHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingStatusHistoryWhereInput
    orderBy?: BookingStatusHistoryOrderByWithAggregationInput | BookingStatusHistoryOrderByWithAggregationInput[]
    by: BookingStatusHistoryScalarFieldEnum[] | BookingStatusHistoryScalarFieldEnum
    having?: BookingStatusHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingStatusHistoryCountAggregateInputType | true
    _min?: BookingStatusHistoryMinAggregateInputType
    _max?: BookingStatusHistoryMaxAggregateInputType
  }

  export type BookingStatusHistoryGroupByOutputType = {
    id: string
    bookingId: string
    oldStatus: $Enums.BookingStatus | null
    newStatus: $Enums.BookingStatus
    changedById: string
    changedBy: string
    changedByRole: string
    reason: string | null
    notes: string | null
    oldDate: Date | null
    newDate: Date | null
    oldStartTime: string | null
    newStartTime: string | null
    oldEndTime: string | null
    newEndTime: string | null
    oldProfessionalId: string | null
    newProfessionalId: string | null
    changedAt: Date
    _count: BookingStatusHistoryCountAggregateOutputType | null
    _min: BookingStatusHistoryMinAggregateOutputType | null
    _max: BookingStatusHistoryMaxAggregateOutputType | null
  }

  type GetBookingStatusHistoryGroupByPayload<T extends BookingStatusHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingStatusHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingStatusHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingStatusHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], BookingStatusHistoryGroupByOutputType[P]>
        }
      >
    >


  export type BookingStatusHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    changedById?: boolean
    changedBy?: boolean
    changedByRole?: boolean
    reason?: boolean
    notes?: boolean
    oldDate?: boolean
    newDate?: boolean
    oldStartTime?: boolean
    newStartTime?: boolean
    oldEndTime?: boolean
    newEndTime?: boolean
    oldProfessionalId?: boolean
    newProfessionalId?: boolean
    changedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingStatusHistory"]>

  export type BookingStatusHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    changedById?: boolean
    changedBy?: boolean
    changedByRole?: boolean
    reason?: boolean
    notes?: boolean
    oldDate?: boolean
    newDate?: boolean
    oldStartTime?: boolean
    newStartTime?: boolean
    oldEndTime?: boolean
    newEndTime?: boolean
    oldProfessionalId?: boolean
    newProfessionalId?: boolean
    changedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingStatusHistory"]>

  export type BookingStatusHistorySelectScalar = {
    id?: boolean
    bookingId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    changedById?: boolean
    changedBy?: boolean
    changedByRole?: boolean
    reason?: boolean
    notes?: boolean
    oldDate?: boolean
    newDate?: boolean
    oldStartTime?: boolean
    newStartTime?: boolean
    oldEndTime?: boolean
    newEndTime?: boolean
    oldProfessionalId?: boolean
    newProfessionalId?: boolean
    changedAt?: boolean
  }

  export type BookingStatusHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type BookingStatusHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $BookingStatusHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingStatusHistory"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      oldStatus: $Enums.BookingStatus | null
      newStatus: $Enums.BookingStatus
      changedById: string
      changedBy: string
      changedByRole: string
      reason: string | null
      notes: string | null
      oldDate: Date | null
      newDate: Date | null
      oldStartTime: string | null
      newStartTime: string | null
      oldEndTime: string | null
      newEndTime: string | null
      oldProfessionalId: string | null
      newProfessionalId: string | null
      changedAt: Date
    }, ExtArgs["result"]["bookingStatusHistory"]>
    composites: {}
  }

  type BookingStatusHistoryGetPayload<S extends boolean | null | undefined | BookingStatusHistoryDefaultArgs> = $Result.GetResult<Prisma.$BookingStatusHistoryPayload, S>

  type BookingStatusHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingStatusHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingStatusHistoryCountAggregateInputType | true
    }

  export interface BookingStatusHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingStatusHistory'], meta: { name: 'BookingStatusHistory' } }
    /**
     * Find zero or one BookingStatusHistory that matches the filter.
     * @param {BookingStatusHistoryFindUniqueArgs} args - Arguments to find a BookingStatusHistory
     * @example
     * // Get one BookingStatusHistory
     * const bookingStatusHistory = await prisma.bookingStatusHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingStatusHistoryFindUniqueArgs>(args: SelectSubset<T, BookingStatusHistoryFindUniqueArgs<ExtArgs>>): Prisma__BookingStatusHistoryClient<$Result.GetResult<Prisma.$BookingStatusHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BookingStatusHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingStatusHistoryFindUniqueOrThrowArgs} args - Arguments to find a BookingStatusHistory
     * @example
     * // Get one BookingStatusHistory
     * const bookingStatusHistory = await prisma.bookingStatusHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingStatusHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingStatusHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingStatusHistoryClient<$Result.GetResult<Prisma.$BookingStatusHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BookingStatusHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusHistoryFindFirstArgs} args - Arguments to find a BookingStatusHistory
     * @example
     * // Get one BookingStatusHistory
     * const bookingStatusHistory = await prisma.bookingStatusHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingStatusHistoryFindFirstArgs>(args?: SelectSubset<T, BookingStatusHistoryFindFirstArgs<ExtArgs>>): Prisma__BookingStatusHistoryClient<$Result.GetResult<Prisma.$BookingStatusHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BookingStatusHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusHistoryFindFirstOrThrowArgs} args - Arguments to find a BookingStatusHistory
     * @example
     * // Get one BookingStatusHistory
     * const bookingStatusHistory = await prisma.bookingStatusHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingStatusHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingStatusHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingStatusHistoryClient<$Result.GetResult<Prisma.$BookingStatusHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BookingStatusHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingStatusHistories
     * const bookingStatusHistories = await prisma.bookingStatusHistory.findMany()
     * 
     * // Get first 10 BookingStatusHistories
     * const bookingStatusHistories = await prisma.bookingStatusHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingStatusHistoryWithIdOnly = await prisma.bookingStatusHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingStatusHistoryFindManyArgs>(args?: SelectSubset<T, BookingStatusHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingStatusHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BookingStatusHistory.
     * @param {BookingStatusHistoryCreateArgs} args - Arguments to create a BookingStatusHistory.
     * @example
     * // Create one BookingStatusHistory
     * const BookingStatusHistory = await prisma.bookingStatusHistory.create({
     *   data: {
     *     // ... data to create a BookingStatusHistory
     *   }
     * })
     * 
     */
    create<T extends BookingStatusHistoryCreateArgs>(args: SelectSubset<T, BookingStatusHistoryCreateArgs<ExtArgs>>): Prisma__BookingStatusHistoryClient<$Result.GetResult<Prisma.$BookingStatusHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BookingStatusHistories.
     * @param {BookingStatusHistoryCreateManyArgs} args - Arguments to create many BookingStatusHistories.
     * @example
     * // Create many BookingStatusHistories
     * const bookingStatusHistory = await prisma.bookingStatusHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingStatusHistoryCreateManyArgs>(args?: SelectSubset<T, BookingStatusHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingStatusHistories and returns the data saved in the database.
     * @param {BookingStatusHistoryCreateManyAndReturnArgs} args - Arguments to create many BookingStatusHistories.
     * @example
     * // Create many BookingStatusHistories
     * const bookingStatusHistory = await prisma.bookingStatusHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingStatusHistories and only return the `id`
     * const bookingStatusHistoryWithIdOnly = await prisma.bookingStatusHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingStatusHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingStatusHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingStatusHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BookingStatusHistory.
     * @param {BookingStatusHistoryDeleteArgs} args - Arguments to delete one BookingStatusHistory.
     * @example
     * // Delete one BookingStatusHistory
     * const BookingStatusHistory = await prisma.bookingStatusHistory.delete({
     *   where: {
     *     // ... filter to delete one BookingStatusHistory
     *   }
     * })
     * 
     */
    delete<T extends BookingStatusHistoryDeleteArgs>(args: SelectSubset<T, BookingStatusHistoryDeleteArgs<ExtArgs>>): Prisma__BookingStatusHistoryClient<$Result.GetResult<Prisma.$BookingStatusHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BookingStatusHistory.
     * @param {BookingStatusHistoryUpdateArgs} args - Arguments to update one BookingStatusHistory.
     * @example
     * // Update one BookingStatusHistory
     * const bookingStatusHistory = await prisma.bookingStatusHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingStatusHistoryUpdateArgs>(args: SelectSubset<T, BookingStatusHistoryUpdateArgs<ExtArgs>>): Prisma__BookingStatusHistoryClient<$Result.GetResult<Prisma.$BookingStatusHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BookingStatusHistories.
     * @param {BookingStatusHistoryDeleteManyArgs} args - Arguments to filter BookingStatusHistories to delete.
     * @example
     * // Delete a few BookingStatusHistories
     * const { count } = await prisma.bookingStatusHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingStatusHistoryDeleteManyArgs>(args?: SelectSubset<T, BookingStatusHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingStatusHistories
     * const bookingStatusHistory = await prisma.bookingStatusHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingStatusHistoryUpdateManyArgs>(args: SelectSubset<T, BookingStatusHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookingStatusHistory.
     * @param {BookingStatusHistoryUpsertArgs} args - Arguments to update or create a BookingStatusHistory.
     * @example
     * // Update or create a BookingStatusHistory
     * const bookingStatusHistory = await prisma.bookingStatusHistory.upsert({
     *   create: {
     *     // ... data to create a BookingStatusHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingStatusHistory we want to update
     *   }
     * })
     */
    upsert<T extends BookingStatusHistoryUpsertArgs>(args: SelectSubset<T, BookingStatusHistoryUpsertArgs<ExtArgs>>): Prisma__BookingStatusHistoryClient<$Result.GetResult<Prisma.$BookingStatusHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BookingStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusHistoryCountArgs} args - Arguments to filter BookingStatusHistories to count.
     * @example
     * // Count the number of BookingStatusHistories
     * const count = await prisma.bookingStatusHistory.count({
     *   where: {
     *     // ... the filter for the BookingStatusHistories we want to count
     *   }
     * })
    **/
    count<T extends BookingStatusHistoryCountArgs>(
      args?: Subset<T, BookingStatusHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingStatusHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingStatusHistoryAggregateArgs>(args: Subset<T, BookingStatusHistoryAggregateArgs>): Prisma.PrismaPromise<GetBookingStatusHistoryAggregateType<T>>

    /**
     * Group by BookingStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStatusHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingStatusHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingStatusHistoryGroupByArgs['orderBy'] }
        : { orderBy?: BookingStatusHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingStatusHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingStatusHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingStatusHistory model
   */
  readonly fields: BookingStatusHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingStatusHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingStatusHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingStatusHistory model
   */ 
  interface BookingStatusHistoryFieldRefs {
    readonly id: FieldRef<"BookingStatusHistory", 'String'>
    readonly bookingId: FieldRef<"BookingStatusHistory", 'String'>
    readonly oldStatus: FieldRef<"BookingStatusHistory", 'BookingStatus'>
    readonly newStatus: FieldRef<"BookingStatusHistory", 'BookingStatus'>
    readonly changedById: FieldRef<"BookingStatusHistory", 'String'>
    readonly changedBy: FieldRef<"BookingStatusHistory", 'String'>
    readonly changedByRole: FieldRef<"BookingStatusHistory", 'String'>
    readonly reason: FieldRef<"BookingStatusHistory", 'String'>
    readonly notes: FieldRef<"BookingStatusHistory", 'String'>
    readonly oldDate: FieldRef<"BookingStatusHistory", 'DateTime'>
    readonly newDate: FieldRef<"BookingStatusHistory", 'DateTime'>
    readonly oldStartTime: FieldRef<"BookingStatusHistory", 'String'>
    readonly newStartTime: FieldRef<"BookingStatusHistory", 'String'>
    readonly oldEndTime: FieldRef<"BookingStatusHistory", 'String'>
    readonly newEndTime: FieldRef<"BookingStatusHistory", 'String'>
    readonly oldProfessionalId: FieldRef<"BookingStatusHistory", 'String'>
    readonly newProfessionalId: FieldRef<"BookingStatusHistory", 'String'>
    readonly changedAt: FieldRef<"BookingStatusHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingStatusHistory findUnique
   */
  export type BookingStatusHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusHistory
     */
    select?: BookingStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatusHistory to fetch.
     */
    where: BookingStatusHistoryWhereUniqueInput
  }

  /**
   * BookingStatusHistory findUniqueOrThrow
   */
  export type BookingStatusHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusHistory
     */
    select?: BookingStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatusHistory to fetch.
     */
    where: BookingStatusHistoryWhereUniqueInput
  }

  /**
   * BookingStatusHistory findFirst
   */
  export type BookingStatusHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusHistory
     */
    select?: BookingStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatusHistory to fetch.
     */
    where?: BookingStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStatusHistories to fetch.
     */
    orderBy?: BookingStatusHistoryOrderByWithRelationInput | BookingStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingStatusHistories.
     */
    cursor?: BookingStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingStatusHistories.
     */
    distinct?: BookingStatusHistoryScalarFieldEnum | BookingStatusHistoryScalarFieldEnum[]
  }

  /**
   * BookingStatusHistory findFirstOrThrow
   */
  export type BookingStatusHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusHistory
     */
    select?: BookingStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatusHistory to fetch.
     */
    where?: BookingStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStatusHistories to fetch.
     */
    orderBy?: BookingStatusHistoryOrderByWithRelationInput | BookingStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingStatusHistories.
     */
    cursor?: BookingStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingStatusHistories.
     */
    distinct?: BookingStatusHistoryScalarFieldEnum | BookingStatusHistoryScalarFieldEnum[]
  }

  /**
   * BookingStatusHistory findMany
   */
  export type BookingStatusHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusHistory
     */
    select?: BookingStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingStatusHistories to fetch.
     */
    where?: BookingStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStatusHistories to fetch.
     */
    orderBy?: BookingStatusHistoryOrderByWithRelationInput | BookingStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingStatusHistories.
     */
    cursor?: BookingStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStatusHistories.
     */
    skip?: number
    distinct?: BookingStatusHistoryScalarFieldEnum | BookingStatusHistoryScalarFieldEnum[]
  }

  /**
   * BookingStatusHistory create
   */
  export type BookingStatusHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusHistory
     */
    select?: BookingStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingStatusHistory.
     */
    data: XOR<BookingStatusHistoryCreateInput, BookingStatusHistoryUncheckedCreateInput>
  }

  /**
   * BookingStatusHistory createMany
   */
  export type BookingStatusHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingStatusHistories.
     */
    data: BookingStatusHistoryCreateManyInput | BookingStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingStatusHistory createManyAndReturn
   */
  export type BookingStatusHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusHistory
     */
    select?: BookingStatusHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BookingStatusHistories.
     */
    data: BookingStatusHistoryCreateManyInput | BookingStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingStatusHistory update
   */
  export type BookingStatusHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusHistory
     */
    select?: BookingStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingStatusHistory.
     */
    data: XOR<BookingStatusHistoryUpdateInput, BookingStatusHistoryUncheckedUpdateInput>
    /**
     * Choose, which BookingStatusHistory to update.
     */
    where: BookingStatusHistoryWhereUniqueInput
  }

  /**
   * BookingStatusHistory updateMany
   */
  export type BookingStatusHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingStatusHistories.
     */
    data: XOR<BookingStatusHistoryUpdateManyMutationInput, BookingStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which BookingStatusHistories to update
     */
    where?: BookingStatusHistoryWhereInput
  }

  /**
   * BookingStatusHistory upsert
   */
  export type BookingStatusHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusHistory
     */
    select?: BookingStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingStatusHistory to update in case it exists.
     */
    where: BookingStatusHistoryWhereUniqueInput
    /**
     * In case the BookingStatusHistory found by the `where` argument doesn't exist, create a new BookingStatusHistory with this data.
     */
    create: XOR<BookingStatusHistoryCreateInput, BookingStatusHistoryUncheckedCreateInput>
    /**
     * In case the BookingStatusHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingStatusHistoryUpdateInput, BookingStatusHistoryUncheckedUpdateInput>
  }

  /**
   * BookingStatusHistory delete
   */
  export type BookingStatusHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusHistory
     */
    select?: BookingStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter which BookingStatusHistory to delete.
     */
    where: BookingStatusHistoryWhereUniqueInput
  }

  /**
   * BookingStatusHistory deleteMany
   */
  export type BookingStatusHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingStatusHistories to delete
     */
    where?: BookingStatusHistoryWhereInput
  }

  /**
   * BookingStatusHistory without action
   */
  export type BookingStatusHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStatusHistory
     */
    select?: BookingStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStatusHistoryInclude<ExtArgs> | null
  }


  /**
   * Model WorkingSchedule
   */

  export type AggregateWorkingSchedule = {
    _count: WorkingScheduleCountAggregateOutputType | null
    _avg: WorkingScheduleAvgAggregateOutputType | null
    _sum: WorkingScheduleSumAggregateOutputType | null
    _min: WorkingScheduleMinAggregateOutputType | null
    _max: WorkingScheduleMaxAggregateOutputType | null
  }

  export type WorkingScheduleAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type WorkingScheduleSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type WorkingScheduleMinAggregateOutputType = {
    id: string | null
    professionalId: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkingScheduleMaxAggregateOutputType = {
    id: string | null
    professionalId: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkingScheduleCountAggregateOutputType = {
    id: number
    professionalId: number
    dayOfWeek: number
    startTime: number
    endTime: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkingScheduleAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type WorkingScheduleSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type WorkingScheduleMinAggregateInputType = {
    id?: true
    professionalId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkingScheduleMaxAggregateInputType = {
    id?: true
    professionalId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkingScheduleCountAggregateInputType = {
    id?: true
    professionalId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkingScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkingSchedule to aggregate.
     */
    where?: WorkingScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingSchedules to fetch.
     */
    orderBy?: WorkingScheduleOrderByWithRelationInput | WorkingScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkingScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkingSchedules
    **/
    _count?: true | WorkingScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkingScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkingScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkingScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkingScheduleMaxAggregateInputType
  }

  export type GetWorkingScheduleAggregateType<T extends WorkingScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkingSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkingSchedule[P]>
      : GetScalarType<T[P], AggregateWorkingSchedule[P]>
  }




  export type WorkingScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkingScheduleWhereInput
    orderBy?: WorkingScheduleOrderByWithAggregationInput | WorkingScheduleOrderByWithAggregationInput[]
    by: WorkingScheduleScalarFieldEnum[] | WorkingScheduleScalarFieldEnum
    having?: WorkingScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkingScheduleCountAggregateInputType | true
    _avg?: WorkingScheduleAvgAggregateInputType
    _sum?: WorkingScheduleSumAggregateInputType
    _min?: WorkingScheduleMinAggregateInputType
    _max?: WorkingScheduleMaxAggregateInputType
  }

  export type WorkingScheduleGroupByOutputType = {
    id: string
    professionalId: string
    dayOfWeek: number
    startTime: string
    endTime: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: WorkingScheduleCountAggregateOutputType | null
    _avg: WorkingScheduleAvgAggregateOutputType | null
    _sum: WorkingScheduleSumAggregateOutputType | null
    _min: WorkingScheduleMinAggregateOutputType | null
    _max: WorkingScheduleMaxAggregateOutputType | null
  }

  type GetWorkingScheduleGroupByPayload<T extends WorkingScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkingScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkingScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkingScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], WorkingScheduleGroupByOutputType[P]>
        }
      >
    >


  export type WorkingScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    professionalId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workingSchedule"]>

  export type WorkingScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    professionalId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workingSchedule"]>

  export type WorkingScheduleSelectScalar = {
    id?: boolean
    professionalId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkingScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkingScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkingSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkingSchedule"
    objects: {
      professional: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      professionalId: string
      dayOfWeek: number
      startTime: string
      endTime: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workingSchedule"]>
    composites: {}
  }

  type WorkingScheduleGetPayload<S extends boolean | null | undefined | WorkingScheduleDefaultArgs> = $Result.GetResult<Prisma.$WorkingSchedulePayload, S>

  type WorkingScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkingScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkingScheduleCountAggregateInputType | true
    }

  export interface WorkingScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkingSchedule'], meta: { name: 'WorkingSchedule' } }
    /**
     * Find zero or one WorkingSchedule that matches the filter.
     * @param {WorkingScheduleFindUniqueArgs} args - Arguments to find a WorkingSchedule
     * @example
     * // Get one WorkingSchedule
     * const workingSchedule = await prisma.workingSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkingScheduleFindUniqueArgs>(args: SelectSubset<T, WorkingScheduleFindUniqueArgs<ExtArgs>>): Prisma__WorkingScheduleClient<$Result.GetResult<Prisma.$WorkingSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkingSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkingScheduleFindUniqueOrThrowArgs} args - Arguments to find a WorkingSchedule
     * @example
     * // Get one WorkingSchedule
     * const workingSchedule = await prisma.workingSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkingScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkingScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkingScheduleClient<$Result.GetResult<Prisma.$WorkingSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkingSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingScheduleFindFirstArgs} args - Arguments to find a WorkingSchedule
     * @example
     * // Get one WorkingSchedule
     * const workingSchedule = await prisma.workingSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkingScheduleFindFirstArgs>(args?: SelectSubset<T, WorkingScheduleFindFirstArgs<ExtArgs>>): Prisma__WorkingScheduleClient<$Result.GetResult<Prisma.$WorkingSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkingSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingScheduleFindFirstOrThrowArgs} args - Arguments to find a WorkingSchedule
     * @example
     * // Get one WorkingSchedule
     * const workingSchedule = await prisma.workingSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkingScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkingScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkingScheduleClient<$Result.GetResult<Prisma.$WorkingSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkingSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkingSchedules
     * const workingSchedules = await prisma.workingSchedule.findMany()
     * 
     * // Get first 10 WorkingSchedules
     * const workingSchedules = await prisma.workingSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workingScheduleWithIdOnly = await prisma.workingSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkingScheduleFindManyArgs>(args?: SelectSubset<T, WorkingScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkingSchedule.
     * @param {WorkingScheduleCreateArgs} args - Arguments to create a WorkingSchedule.
     * @example
     * // Create one WorkingSchedule
     * const WorkingSchedule = await prisma.workingSchedule.create({
     *   data: {
     *     // ... data to create a WorkingSchedule
     *   }
     * })
     * 
     */
    create<T extends WorkingScheduleCreateArgs>(args: SelectSubset<T, WorkingScheduleCreateArgs<ExtArgs>>): Prisma__WorkingScheduleClient<$Result.GetResult<Prisma.$WorkingSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkingSchedules.
     * @param {WorkingScheduleCreateManyArgs} args - Arguments to create many WorkingSchedules.
     * @example
     * // Create many WorkingSchedules
     * const workingSchedule = await prisma.workingSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkingScheduleCreateManyArgs>(args?: SelectSubset<T, WorkingScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkingSchedules and returns the data saved in the database.
     * @param {WorkingScheduleCreateManyAndReturnArgs} args - Arguments to create many WorkingSchedules.
     * @example
     * // Create many WorkingSchedules
     * const workingSchedule = await prisma.workingSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkingSchedules and only return the `id`
     * const workingScheduleWithIdOnly = await prisma.workingSchedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkingScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkingScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingSchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkingSchedule.
     * @param {WorkingScheduleDeleteArgs} args - Arguments to delete one WorkingSchedule.
     * @example
     * // Delete one WorkingSchedule
     * const WorkingSchedule = await prisma.workingSchedule.delete({
     *   where: {
     *     // ... filter to delete one WorkingSchedule
     *   }
     * })
     * 
     */
    delete<T extends WorkingScheduleDeleteArgs>(args: SelectSubset<T, WorkingScheduleDeleteArgs<ExtArgs>>): Prisma__WorkingScheduleClient<$Result.GetResult<Prisma.$WorkingSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkingSchedule.
     * @param {WorkingScheduleUpdateArgs} args - Arguments to update one WorkingSchedule.
     * @example
     * // Update one WorkingSchedule
     * const workingSchedule = await prisma.workingSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkingScheduleUpdateArgs>(args: SelectSubset<T, WorkingScheduleUpdateArgs<ExtArgs>>): Prisma__WorkingScheduleClient<$Result.GetResult<Prisma.$WorkingSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkingSchedules.
     * @param {WorkingScheduleDeleteManyArgs} args - Arguments to filter WorkingSchedules to delete.
     * @example
     * // Delete a few WorkingSchedules
     * const { count } = await prisma.workingSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkingScheduleDeleteManyArgs>(args?: SelectSubset<T, WorkingScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkingSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkingSchedules
     * const workingSchedule = await prisma.workingSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkingScheduleUpdateManyArgs>(args: SelectSubset<T, WorkingScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkingSchedule.
     * @param {WorkingScheduleUpsertArgs} args - Arguments to update or create a WorkingSchedule.
     * @example
     * // Update or create a WorkingSchedule
     * const workingSchedule = await prisma.workingSchedule.upsert({
     *   create: {
     *     // ... data to create a WorkingSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkingSchedule we want to update
     *   }
     * })
     */
    upsert<T extends WorkingScheduleUpsertArgs>(args: SelectSubset<T, WorkingScheduleUpsertArgs<ExtArgs>>): Prisma__WorkingScheduleClient<$Result.GetResult<Prisma.$WorkingSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkingSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingScheduleCountArgs} args - Arguments to filter WorkingSchedules to count.
     * @example
     * // Count the number of WorkingSchedules
     * const count = await prisma.workingSchedule.count({
     *   where: {
     *     // ... the filter for the WorkingSchedules we want to count
     *   }
     * })
    **/
    count<T extends WorkingScheduleCountArgs>(
      args?: Subset<T, WorkingScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkingScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkingSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkingScheduleAggregateArgs>(args: Subset<T, WorkingScheduleAggregateArgs>): Prisma.PrismaPromise<GetWorkingScheduleAggregateType<T>>

    /**
     * Group by WorkingSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkingScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkingScheduleGroupByArgs['orderBy'] }
        : { orderBy?: WorkingScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkingScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkingScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkingSchedule model
   */
  readonly fields: WorkingScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkingSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkingScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    professional<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkingSchedule model
   */ 
  interface WorkingScheduleFieldRefs {
    readonly id: FieldRef<"WorkingSchedule", 'String'>
    readonly professionalId: FieldRef<"WorkingSchedule", 'String'>
    readonly dayOfWeek: FieldRef<"WorkingSchedule", 'Int'>
    readonly startTime: FieldRef<"WorkingSchedule", 'String'>
    readonly endTime: FieldRef<"WorkingSchedule", 'String'>
    readonly isActive: FieldRef<"WorkingSchedule", 'Boolean'>
    readonly createdAt: FieldRef<"WorkingSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkingSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkingSchedule findUnique
   */
  export type WorkingScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingSchedule
     */
    select?: WorkingScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingScheduleInclude<ExtArgs> | null
    /**
     * Filter, which WorkingSchedule to fetch.
     */
    where: WorkingScheduleWhereUniqueInput
  }

  /**
   * WorkingSchedule findUniqueOrThrow
   */
  export type WorkingScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingSchedule
     */
    select?: WorkingScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingScheduleInclude<ExtArgs> | null
    /**
     * Filter, which WorkingSchedule to fetch.
     */
    where: WorkingScheduleWhereUniqueInput
  }

  /**
   * WorkingSchedule findFirst
   */
  export type WorkingScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingSchedule
     */
    select?: WorkingScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingScheduleInclude<ExtArgs> | null
    /**
     * Filter, which WorkingSchedule to fetch.
     */
    where?: WorkingScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingSchedules to fetch.
     */
    orderBy?: WorkingScheduleOrderByWithRelationInput | WorkingScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkingSchedules.
     */
    cursor?: WorkingScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkingSchedules.
     */
    distinct?: WorkingScheduleScalarFieldEnum | WorkingScheduleScalarFieldEnum[]
  }

  /**
   * WorkingSchedule findFirstOrThrow
   */
  export type WorkingScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingSchedule
     */
    select?: WorkingScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingScheduleInclude<ExtArgs> | null
    /**
     * Filter, which WorkingSchedule to fetch.
     */
    where?: WorkingScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingSchedules to fetch.
     */
    orderBy?: WorkingScheduleOrderByWithRelationInput | WorkingScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkingSchedules.
     */
    cursor?: WorkingScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkingSchedules.
     */
    distinct?: WorkingScheduleScalarFieldEnum | WorkingScheduleScalarFieldEnum[]
  }

  /**
   * WorkingSchedule findMany
   */
  export type WorkingScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingSchedule
     */
    select?: WorkingScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingScheduleInclude<ExtArgs> | null
    /**
     * Filter, which WorkingSchedules to fetch.
     */
    where?: WorkingScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingSchedules to fetch.
     */
    orderBy?: WorkingScheduleOrderByWithRelationInput | WorkingScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkingSchedules.
     */
    cursor?: WorkingScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingSchedules.
     */
    skip?: number
    distinct?: WorkingScheduleScalarFieldEnum | WorkingScheduleScalarFieldEnum[]
  }

  /**
   * WorkingSchedule create
   */
  export type WorkingScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingSchedule
     */
    select?: WorkingScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkingSchedule.
     */
    data: XOR<WorkingScheduleCreateInput, WorkingScheduleUncheckedCreateInput>
  }

  /**
   * WorkingSchedule createMany
   */
  export type WorkingScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkingSchedules.
     */
    data: WorkingScheduleCreateManyInput | WorkingScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkingSchedule createManyAndReturn
   */
  export type WorkingScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingSchedule
     */
    select?: WorkingScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkingSchedules.
     */
    data: WorkingScheduleCreateManyInput | WorkingScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkingSchedule update
   */
  export type WorkingScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingSchedule
     */
    select?: WorkingScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkingSchedule.
     */
    data: XOR<WorkingScheduleUpdateInput, WorkingScheduleUncheckedUpdateInput>
    /**
     * Choose, which WorkingSchedule to update.
     */
    where: WorkingScheduleWhereUniqueInput
  }

  /**
   * WorkingSchedule updateMany
   */
  export type WorkingScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkingSchedules.
     */
    data: XOR<WorkingScheduleUpdateManyMutationInput, WorkingScheduleUncheckedUpdateManyInput>
    /**
     * Filter which WorkingSchedules to update
     */
    where?: WorkingScheduleWhereInput
  }

  /**
   * WorkingSchedule upsert
   */
  export type WorkingScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingSchedule
     */
    select?: WorkingScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkingSchedule to update in case it exists.
     */
    where: WorkingScheduleWhereUniqueInput
    /**
     * In case the WorkingSchedule found by the `where` argument doesn't exist, create a new WorkingSchedule with this data.
     */
    create: XOR<WorkingScheduleCreateInput, WorkingScheduleUncheckedCreateInput>
    /**
     * In case the WorkingSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkingScheduleUpdateInput, WorkingScheduleUncheckedUpdateInput>
  }

  /**
   * WorkingSchedule delete
   */
  export type WorkingScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingSchedule
     */
    select?: WorkingScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingScheduleInclude<ExtArgs> | null
    /**
     * Filter which WorkingSchedule to delete.
     */
    where: WorkingScheduleWhereUniqueInput
  }

  /**
   * WorkingSchedule deleteMany
   */
  export type WorkingScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkingSchedules to delete
     */
    where?: WorkingScheduleWhereInput
  }

  /**
   * WorkingSchedule without action
   */
  export type WorkingScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingSchedule
     */
    select?: WorkingScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkingScheduleInclude<ExtArgs> | null
  }


  /**
   * Model BreakPeriod
   */

  export type AggregateBreakPeriod = {
    _count: BreakPeriodCountAggregateOutputType | null
    _avg: BreakPeriodAvgAggregateOutputType | null
    _sum: BreakPeriodSumAggregateOutputType | null
    _min: BreakPeriodMinAggregateOutputType | null
    _max: BreakPeriodMaxAggregateOutputType | null
  }

  export type BreakPeriodAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type BreakPeriodSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type BreakPeriodMinAggregateOutputType = {
    id: string | null
    professionalId: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    label: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreakPeriodMaxAggregateOutputType = {
    id: string | null
    professionalId: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    label: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreakPeriodCountAggregateOutputType = {
    id: number
    professionalId: number
    dayOfWeek: number
    startTime: number
    endTime: number
    label: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BreakPeriodAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type BreakPeriodSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type BreakPeriodMinAggregateInputType = {
    id?: true
    professionalId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    label?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreakPeriodMaxAggregateInputType = {
    id?: true
    professionalId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    label?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreakPeriodCountAggregateInputType = {
    id?: true
    professionalId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    label?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BreakPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreakPeriod to aggregate.
     */
    where?: BreakPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakPeriods to fetch.
     */
    orderBy?: BreakPeriodOrderByWithRelationInput | BreakPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BreakPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BreakPeriods
    **/
    _count?: true | BreakPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BreakPeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BreakPeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BreakPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BreakPeriodMaxAggregateInputType
  }

  export type GetBreakPeriodAggregateType<T extends BreakPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateBreakPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBreakPeriod[P]>
      : GetScalarType<T[P], AggregateBreakPeriod[P]>
  }




  export type BreakPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreakPeriodWhereInput
    orderBy?: BreakPeriodOrderByWithAggregationInput | BreakPeriodOrderByWithAggregationInput[]
    by: BreakPeriodScalarFieldEnum[] | BreakPeriodScalarFieldEnum
    having?: BreakPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BreakPeriodCountAggregateInputType | true
    _avg?: BreakPeriodAvgAggregateInputType
    _sum?: BreakPeriodSumAggregateInputType
    _min?: BreakPeriodMinAggregateInputType
    _max?: BreakPeriodMaxAggregateInputType
  }

  export type BreakPeriodGroupByOutputType = {
    id: string
    professionalId: string
    dayOfWeek: number | null
    startTime: string
    endTime: string
    label: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BreakPeriodCountAggregateOutputType | null
    _avg: BreakPeriodAvgAggregateOutputType | null
    _sum: BreakPeriodSumAggregateOutputType | null
    _min: BreakPeriodMinAggregateOutputType | null
    _max: BreakPeriodMaxAggregateOutputType | null
  }

  type GetBreakPeriodGroupByPayload<T extends BreakPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BreakPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BreakPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BreakPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], BreakPeriodGroupByOutputType[P]>
        }
      >
    >


  export type BreakPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    professionalId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    label?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breakPeriod"]>

  export type BreakPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    professionalId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    label?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breakPeriod"]>

  export type BreakPeriodSelectScalar = {
    id?: boolean
    professionalId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    label?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BreakPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BreakPeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    professional?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BreakPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BreakPeriod"
    objects: {
      professional: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      professionalId: string
      dayOfWeek: number | null
      startTime: string
      endTime: string
      label: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["breakPeriod"]>
    composites: {}
  }

  type BreakPeriodGetPayload<S extends boolean | null | undefined | BreakPeriodDefaultArgs> = $Result.GetResult<Prisma.$BreakPeriodPayload, S>

  type BreakPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BreakPeriodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BreakPeriodCountAggregateInputType | true
    }

  export interface BreakPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BreakPeriod'], meta: { name: 'BreakPeriod' } }
    /**
     * Find zero or one BreakPeriod that matches the filter.
     * @param {BreakPeriodFindUniqueArgs} args - Arguments to find a BreakPeriod
     * @example
     * // Get one BreakPeriod
     * const breakPeriod = await prisma.breakPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BreakPeriodFindUniqueArgs>(args: SelectSubset<T, BreakPeriodFindUniqueArgs<ExtArgs>>): Prisma__BreakPeriodClient<$Result.GetResult<Prisma.$BreakPeriodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BreakPeriod that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BreakPeriodFindUniqueOrThrowArgs} args - Arguments to find a BreakPeriod
     * @example
     * // Get one BreakPeriod
     * const breakPeriod = await prisma.breakPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BreakPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, BreakPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BreakPeriodClient<$Result.GetResult<Prisma.$BreakPeriodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BreakPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakPeriodFindFirstArgs} args - Arguments to find a BreakPeriod
     * @example
     * // Get one BreakPeriod
     * const breakPeriod = await prisma.breakPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BreakPeriodFindFirstArgs>(args?: SelectSubset<T, BreakPeriodFindFirstArgs<ExtArgs>>): Prisma__BreakPeriodClient<$Result.GetResult<Prisma.$BreakPeriodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BreakPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakPeriodFindFirstOrThrowArgs} args - Arguments to find a BreakPeriod
     * @example
     * // Get one BreakPeriod
     * const breakPeriod = await prisma.breakPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BreakPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, BreakPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__BreakPeriodClient<$Result.GetResult<Prisma.$BreakPeriodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BreakPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BreakPeriods
     * const breakPeriods = await prisma.breakPeriod.findMany()
     * 
     * // Get first 10 BreakPeriods
     * const breakPeriods = await prisma.breakPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const breakPeriodWithIdOnly = await prisma.breakPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BreakPeriodFindManyArgs>(args?: SelectSubset<T, BreakPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakPeriodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BreakPeriod.
     * @param {BreakPeriodCreateArgs} args - Arguments to create a BreakPeriod.
     * @example
     * // Create one BreakPeriod
     * const BreakPeriod = await prisma.breakPeriod.create({
     *   data: {
     *     // ... data to create a BreakPeriod
     *   }
     * })
     * 
     */
    create<T extends BreakPeriodCreateArgs>(args: SelectSubset<T, BreakPeriodCreateArgs<ExtArgs>>): Prisma__BreakPeriodClient<$Result.GetResult<Prisma.$BreakPeriodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BreakPeriods.
     * @param {BreakPeriodCreateManyArgs} args - Arguments to create many BreakPeriods.
     * @example
     * // Create many BreakPeriods
     * const breakPeriod = await prisma.breakPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BreakPeriodCreateManyArgs>(args?: SelectSubset<T, BreakPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BreakPeriods and returns the data saved in the database.
     * @param {BreakPeriodCreateManyAndReturnArgs} args - Arguments to create many BreakPeriods.
     * @example
     * // Create many BreakPeriods
     * const breakPeriod = await prisma.breakPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BreakPeriods and only return the `id`
     * const breakPeriodWithIdOnly = await prisma.breakPeriod.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BreakPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, BreakPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakPeriodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BreakPeriod.
     * @param {BreakPeriodDeleteArgs} args - Arguments to delete one BreakPeriod.
     * @example
     * // Delete one BreakPeriod
     * const BreakPeriod = await prisma.breakPeriod.delete({
     *   where: {
     *     // ... filter to delete one BreakPeriod
     *   }
     * })
     * 
     */
    delete<T extends BreakPeriodDeleteArgs>(args: SelectSubset<T, BreakPeriodDeleteArgs<ExtArgs>>): Prisma__BreakPeriodClient<$Result.GetResult<Prisma.$BreakPeriodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BreakPeriod.
     * @param {BreakPeriodUpdateArgs} args - Arguments to update one BreakPeriod.
     * @example
     * // Update one BreakPeriod
     * const breakPeriod = await prisma.breakPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BreakPeriodUpdateArgs>(args: SelectSubset<T, BreakPeriodUpdateArgs<ExtArgs>>): Prisma__BreakPeriodClient<$Result.GetResult<Prisma.$BreakPeriodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BreakPeriods.
     * @param {BreakPeriodDeleteManyArgs} args - Arguments to filter BreakPeriods to delete.
     * @example
     * // Delete a few BreakPeriods
     * const { count } = await prisma.breakPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BreakPeriodDeleteManyArgs>(args?: SelectSubset<T, BreakPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreakPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BreakPeriods
     * const breakPeriod = await prisma.breakPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BreakPeriodUpdateManyArgs>(args: SelectSubset<T, BreakPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BreakPeriod.
     * @param {BreakPeriodUpsertArgs} args - Arguments to update or create a BreakPeriod.
     * @example
     * // Update or create a BreakPeriod
     * const breakPeriod = await prisma.breakPeriod.upsert({
     *   create: {
     *     // ... data to create a BreakPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BreakPeriod we want to update
     *   }
     * })
     */
    upsert<T extends BreakPeriodUpsertArgs>(args: SelectSubset<T, BreakPeriodUpsertArgs<ExtArgs>>): Prisma__BreakPeriodClient<$Result.GetResult<Prisma.$BreakPeriodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BreakPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakPeriodCountArgs} args - Arguments to filter BreakPeriods to count.
     * @example
     * // Count the number of BreakPeriods
     * const count = await prisma.breakPeriod.count({
     *   where: {
     *     // ... the filter for the BreakPeriods we want to count
     *   }
     * })
    **/
    count<T extends BreakPeriodCountArgs>(
      args?: Subset<T, BreakPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BreakPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BreakPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BreakPeriodAggregateArgs>(args: Subset<T, BreakPeriodAggregateArgs>): Prisma.PrismaPromise<GetBreakPeriodAggregateType<T>>

    /**
     * Group by BreakPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BreakPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BreakPeriodGroupByArgs['orderBy'] }
        : { orderBy?: BreakPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BreakPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBreakPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BreakPeriod model
   */
  readonly fields: BreakPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BreakPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BreakPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    professional<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BreakPeriod model
   */ 
  interface BreakPeriodFieldRefs {
    readonly id: FieldRef<"BreakPeriod", 'String'>
    readonly professionalId: FieldRef<"BreakPeriod", 'String'>
    readonly dayOfWeek: FieldRef<"BreakPeriod", 'Int'>
    readonly startTime: FieldRef<"BreakPeriod", 'String'>
    readonly endTime: FieldRef<"BreakPeriod", 'String'>
    readonly label: FieldRef<"BreakPeriod", 'String'>
    readonly isActive: FieldRef<"BreakPeriod", 'Boolean'>
    readonly createdAt: FieldRef<"BreakPeriod", 'DateTime'>
    readonly updatedAt: FieldRef<"BreakPeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BreakPeriod findUnique
   */
  export type BreakPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakPeriod
     */
    select?: BreakPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakPeriodInclude<ExtArgs> | null
    /**
     * Filter, which BreakPeriod to fetch.
     */
    where: BreakPeriodWhereUniqueInput
  }

  /**
   * BreakPeriod findUniqueOrThrow
   */
  export type BreakPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakPeriod
     */
    select?: BreakPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakPeriodInclude<ExtArgs> | null
    /**
     * Filter, which BreakPeriod to fetch.
     */
    where: BreakPeriodWhereUniqueInput
  }

  /**
   * BreakPeriod findFirst
   */
  export type BreakPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakPeriod
     */
    select?: BreakPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakPeriodInclude<ExtArgs> | null
    /**
     * Filter, which BreakPeriod to fetch.
     */
    where?: BreakPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakPeriods to fetch.
     */
    orderBy?: BreakPeriodOrderByWithRelationInput | BreakPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreakPeriods.
     */
    cursor?: BreakPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreakPeriods.
     */
    distinct?: BreakPeriodScalarFieldEnum | BreakPeriodScalarFieldEnum[]
  }

  /**
   * BreakPeriod findFirstOrThrow
   */
  export type BreakPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakPeriod
     */
    select?: BreakPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakPeriodInclude<ExtArgs> | null
    /**
     * Filter, which BreakPeriod to fetch.
     */
    where?: BreakPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakPeriods to fetch.
     */
    orderBy?: BreakPeriodOrderByWithRelationInput | BreakPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreakPeriods.
     */
    cursor?: BreakPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreakPeriods.
     */
    distinct?: BreakPeriodScalarFieldEnum | BreakPeriodScalarFieldEnum[]
  }

  /**
   * BreakPeriod findMany
   */
  export type BreakPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakPeriod
     */
    select?: BreakPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakPeriodInclude<ExtArgs> | null
    /**
     * Filter, which BreakPeriods to fetch.
     */
    where?: BreakPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakPeriods to fetch.
     */
    orderBy?: BreakPeriodOrderByWithRelationInput | BreakPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BreakPeriods.
     */
    cursor?: BreakPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakPeriods.
     */
    skip?: number
    distinct?: BreakPeriodScalarFieldEnum | BreakPeriodScalarFieldEnum[]
  }

  /**
   * BreakPeriod create
   */
  export type BreakPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakPeriod
     */
    select?: BreakPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a BreakPeriod.
     */
    data: XOR<BreakPeriodCreateInput, BreakPeriodUncheckedCreateInput>
  }

  /**
   * BreakPeriod createMany
   */
  export type BreakPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BreakPeriods.
     */
    data: BreakPeriodCreateManyInput | BreakPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BreakPeriod createManyAndReturn
   */
  export type BreakPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakPeriod
     */
    select?: BreakPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BreakPeriods.
     */
    data: BreakPeriodCreateManyInput | BreakPeriodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakPeriodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BreakPeriod update
   */
  export type BreakPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakPeriod
     */
    select?: BreakPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a BreakPeriod.
     */
    data: XOR<BreakPeriodUpdateInput, BreakPeriodUncheckedUpdateInput>
    /**
     * Choose, which BreakPeriod to update.
     */
    where: BreakPeriodWhereUniqueInput
  }

  /**
   * BreakPeriod updateMany
   */
  export type BreakPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BreakPeriods.
     */
    data: XOR<BreakPeriodUpdateManyMutationInput, BreakPeriodUncheckedUpdateManyInput>
    /**
     * Filter which BreakPeriods to update
     */
    where?: BreakPeriodWhereInput
  }

  /**
   * BreakPeriod upsert
   */
  export type BreakPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakPeriod
     */
    select?: BreakPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the BreakPeriod to update in case it exists.
     */
    where: BreakPeriodWhereUniqueInput
    /**
     * In case the BreakPeriod found by the `where` argument doesn't exist, create a new BreakPeriod with this data.
     */
    create: XOR<BreakPeriodCreateInput, BreakPeriodUncheckedCreateInput>
    /**
     * In case the BreakPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BreakPeriodUpdateInput, BreakPeriodUncheckedUpdateInput>
  }

  /**
   * BreakPeriod delete
   */
  export type BreakPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakPeriod
     */
    select?: BreakPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakPeriodInclude<ExtArgs> | null
    /**
     * Filter which BreakPeriod to delete.
     */
    where: BreakPeriodWhereUniqueInput
  }

  /**
   * BreakPeriod deleteMany
   */
  export type BreakPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreakPeriods to delete
     */
    where?: BreakPeriodWhereInput
  }

  /**
   * BreakPeriod without action
   */
  export type BreakPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakPeriod
     */
    select?: BreakPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakPeriodInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    recipientEmail: string | null
    recipientName: string | null
    bookingId: string | null
    subject: string | null
    message: string | null
    sent: boolean | null
    sentAt: Date | null
    error: string | null
    scheduledFor: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    recipientEmail: string | null
    recipientName: string | null
    bookingId: string | null
    subject: string | null
    message: string | null
    sent: boolean | null
    sentAt: Date | null
    error: string | null
    scheduledFor: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    recipientEmail: number
    recipientName: number
    bookingId: number
    subject: number
    message: number
    sent: number
    sentAt: number
    error: number
    scheduledFor: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    recipientEmail?: true
    recipientName?: true
    bookingId?: true
    subject?: true
    message?: true
    sent?: true
    sentAt?: true
    error?: true
    scheduledFor?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    recipientEmail?: true
    recipientName?: true
    bookingId?: true
    subject?: true
    message?: true
    sent?: true
    sentAt?: true
    error?: true
    scheduledFor?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    recipientEmail?: true
    recipientName?: true
    bookingId?: true
    subject?: true
    message?: true
    sent?: true
    sentAt?: true
    error?: true
    scheduledFor?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: $Enums.NotificationType
    recipientEmail: string
    recipientName: string | null
    bookingId: string | null
    subject: string
    message: string
    sent: boolean
    sentAt: Date | null
    error: string | null
    scheduledFor: Date | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    recipientEmail?: boolean
    recipientName?: boolean
    bookingId?: boolean
    subject?: boolean
    message?: boolean
    sent?: boolean
    sentAt?: boolean
    error?: boolean
    scheduledFor?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    recipientEmail?: boolean
    recipientName?: boolean
    bookingId?: boolean
    subject?: boolean
    message?: boolean
    sent?: boolean
    sentAt?: boolean
    error?: boolean
    scheduledFor?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    recipientEmail?: boolean
    recipientName?: boolean
    bookingId?: boolean
    subject?: boolean
    message?: boolean
    sent?: boolean
    sentAt?: boolean
    error?: boolean
    scheduledFor?: boolean
    createdAt?: boolean
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NotificationType
      recipientEmail: string
      recipientName: string | null
      bookingId: string | null
      subject: string
      message: string
      sent: boolean
      sentAt: Date | null
      error: string | null
      scheduledFor: Date | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly recipientEmail: FieldRef<"Notification", 'String'>
    readonly recipientName: FieldRef<"Notification", 'String'>
    readonly bookingId: FieldRef<"Notification", 'String'>
    readonly subject: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly sent: FieldRef<"Notification", 'Boolean'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly error: FieldRef<"Notification", 'String'>
    readonly scheduledFor: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
  }


  /**
   * Model SystemSettings
   */

  export type AggregateSystemSettings = {
    _count: SystemSettingsCountAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  export type SystemSettingsMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type SystemSettingsMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type SystemSettingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingsMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
  }

  export type SystemSettingsMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
  }

  export type SystemSettingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to aggregate.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type GetSystemSettingsAggregateType<T extends SystemSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSettings[P]>
      : GetScalarType<T[P], AggregateSystemSettings[P]>
  }




  export type SystemSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingsWhereInput
    orderBy?: SystemSettingsOrderByWithAggregationInput | SystemSettingsOrderByWithAggregationInput[]
    by: SystemSettingsScalarFieldEnum[] | SystemSettingsScalarFieldEnum
    having?: SystemSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingsCountAggregateInputType | true
    _min?: SystemSettingsMinAggregateInputType
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type SystemSettingsGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    updatedAt: Date
    _count: SystemSettingsCountAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  type GetSystemSettingsGroupByPayload<T extends SystemSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }


  export type $SystemSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      updatedAt: Date
    }, ExtArgs["result"]["systemSettings"]>
    composites: {}
  }

  type SystemSettingsGetPayload<S extends boolean | null | undefined | SystemSettingsDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingsPayload, S>

  type SystemSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemSettingsCountAggregateInputType | true
    }

  export interface SystemSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSettings'], meta: { name: 'SystemSettings' } }
    /**
     * Find zero or one SystemSettings that matches the filter.
     * @param {SystemSettingsFindUniqueArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingsFindUniqueArgs>(args: SelectSubset<T, SystemSettingsFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemSettingsFindUniqueOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingsFindFirstArgs>(args?: SelectSubset<T, SystemSettingsFindFirstArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingsFindManyArgs>(args?: SelectSubset<T, SystemSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemSettings.
     * @param {SystemSettingsCreateArgs} args - Arguments to create a SystemSettings.
     * @example
     * // Create one SystemSettings
     * const SystemSettings = await prisma.systemSettings.create({
     *   data: {
     *     // ... data to create a SystemSettings
     *   }
     * })
     * 
     */
    create<T extends SystemSettingsCreateArgs>(args: SelectSubset<T, SystemSettingsCreateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingsCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingsCreateManyArgs>(args?: SelectSubset<T, SystemSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingsCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemSettings.
     * @param {SystemSettingsDeleteArgs} args - Arguments to delete one SystemSettings.
     * @example
     * // Delete one SystemSettings
     * const SystemSettings = await prisma.systemSettings.delete({
     *   where: {
     *     // ... filter to delete one SystemSettings
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingsDeleteArgs>(args: SelectSubset<T, SystemSettingsDeleteArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemSettings.
     * @param {SystemSettingsUpdateArgs} args - Arguments to update one SystemSettings.
     * @example
     * // Update one SystemSettings
     * const systemSettings = await prisma.systemSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingsUpdateArgs>(args: SelectSubset<T, SystemSettingsUpdateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingsDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingsDeleteManyArgs>(args?: SelectSubset<T, SystemSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingsUpdateManyArgs>(args: SelectSubset<T, SystemSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemSettings.
     * @param {SystemSettingsUpsertArgs} args - Arguments to update or create a SystemSettings.
     * @example
     * // Update or create a SystemSettings
     * const systemSettings = await prisma.systemSettings.upsert({
     *   create: {
     *     // ... data to create a SystemSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSettings we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingsUpsertArgs>(args: SelectSubset<T, SystemSettingsUpsertArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSettings.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingsCountArgs>(
      args?: Subset<T, SystemSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingsAggregateArgs>(args: Subset<T, SystemSettingsAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingsAggregateType<T>>

    /**
     * Group by SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSettings model
   */
  readonly fields: SystemSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSettings model
   */ 
  interface SystemSettingsFieldRefs {
    readonly id: FieldRef<"SystemSettings", 'String'>
    readonly key: FieldRef<"SystemSettings", 'String'>
    readonly value: FieldRef<"SystemSettings", 'String'>
    readonly description: FieldRef<"SystemSettings", 'String'>
    readonly updatedAt: FieldRef<"SystemSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSettings findUnique
   */
  export type SystemSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findUniqueOrThrow
   */
  export type SystemSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findFirst
   */
  export type SystemSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findFirstOrThrow
   */
  export type SystemSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findMany
   */
  export type SystemSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings create
   */
  export type SystemSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemSettings.
     */
    data: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
  }

  /**
   * SystemSettings createMany
   */
  export type SystemSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings createManyAndReturn
   */
  export type SystemSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings update
   */
  export type SystemSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemSettings.
     */
    data: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
    /**
     * Choose, which SystemSettings to update.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings updateMany
   */
  export type SystemSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
  }

  /**
   * SystemSettings upsert
   */
  export type SystemSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemSettings to update in case it exists.
     */
    where: SystemSettingsWhereUniqueInput
    /**
     * In case the SystemSettings found by the `where` argument doesn't exist, create a new SystemSettings with this data.
     */
    create: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
    /**
     * In case the SystemSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
  }

  /**
   * SystemSettings delete
   */
  export type SystemSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter which SystemSettings to delete.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings deleteMany
   */
  export type SystemSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingsWhereInput
  }

  /**
   * SystemSettings without action
   */
  export type SystemSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    telephone: 'telephone',
    password: 'password',
    role: 'role',
    nom: 'nom',
    prenom: 'prenom',
    photoUrl: 'photoUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientProfileScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    prenom: 'prenom',
    adresse: 'adresse',
    ville: 'ville',
    codePostal: 'codePostal',
    telMaison: 'telMaison',
    telBureau: 'telBureau',
    telCellulaire: 'telCellulaire',
    courriel: 'courriel',
    dateNaissance: 'dateNaissance',
    occupation: 'occupation',
    gender: 'gender',
    serviceType: 'serviceType',
    assuranceCouvert: 'assuranceCouvert',
    autreMaladie: 'autreMaladie',
    autreMaladieDetails: 'autreMaladieDetails',
    raisonConsultation: 'raisonConsultation',
    diagnosticMedical: 'diagnosticMedical',
    diagnosticMedicalDetails: 'diagnosticMedicalDetails',
    medicaments: 'medicaments',
    medicamentsDetails: 'medicamentsDetails',
    accidents: 'accidents',
    accidentsDetails: 'accidentsDetails',
    operationsChirurgicales: 'operationsChirurgicales',
    operationsChirurgicalesDetails: 'operationsChirurgicalesDetails',
    traitementsActuels: 'traitementsActuels',
    problemesCardiaques: 'problemesCardiaques',
    problemesCardiaquesDetails: 'problemesCardiaquesDetails',
    maladiesGraves: 'maladiesGraves',
    maladiesGravesDetails: 'maladiesGravesDetails',
    ortheses: 'ortheses',
    orthesesDetails: 'orthesesDetails',
    allergies: 'allergies',
    allergiesDetails: 'allergiesDetails',
    raideurs: 'raideurs',
    arthrose: 'arthrose',
    hernieDiscale: 'hernieDiscale',
    oedeme: 'oedeme',
    tendinite: 'tendinite',
    mauxDeTete: 'mauxDeTete',
    flatulence: 'flatulence',
    troublesCirculatoires: 'troublesCirculatoires',
    hypothyroidie: 'hypothyroidie',
    diabete: 'diabete',
    stresse: 'stresse',
    premenopause: 'premenopause',
    douleurMusculaire: 'douleurMusculaire',
    fibromyalgie: 'fibromyalgie',
    rhumatisme: 'rhumatisme',
    sciatique: 'sciatique',
    bursite: 'bursite',
    migraine: 'migraine',
    diarrhee: 'diarrhee',
    phlebite: 'phlebite',
    hypertension: 'hypertension',
    hypoglycemie: 'hypoglycemie',
    burnOut: 'burnOut',
    menopause: 'menopause',
    inflammationAigue: 'inflammationAigue',
    arteriosclerose: 'arteriosclerose',
    osteoporose: 'osteoporose',
    mauxDeDos: 'mauxDeDos',
    fatigueDesJambes: 'fatigueDesJambes',
    troublesDigestifs: 'troublesDigestifs',
    constipation: 'constipation',
    hyperthyroidie: 'hyperthyroidie',
    hypotension: 'hypotension',
    insomnie: 'insomnie',
    depressionNerveuse: 'depressionNerveuse',
    autres: 'autres',
    lastVisitDate: 'lastVisitDate',
    lastEmailSent: 'lastEmailSent',
    feedbackEmailsSent: 'feedbackEmailsSent',
    promoEmailsSent: 'promoEmailsSent',
    zonesDouleur: 'zonesDouleur',
    etatPeau: 'etatPeau',
    etatPores: 'etatPores',
    coucheCornee: 'coucheCornee',
    irrigationSanguine: 'irrigationSanguine',
    impuretes: 'impuretes',
    sensibiliteCutanee: 'sensibiliteCutanee',
    fumeur: 'fumeur',
    niveauStress: 'niveauStress',
    expositionSoleil: 'expositionSoleil',
    protectionSolaire: 'protectionSolaire',
    suffisanceEau: 'suffisanceEau',
    travailExterieur: 'travailExterieur',
    bainChauds: 'bainChauds',
    routineSoins: 'routineSoins',
    changementsRecents: 'changementsRecents',
    preferencePeau: 'preferencePeau',
    diagnosticVisuelNotes: 'diagnosticVisuelNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientProfileScalarFieldEnum = (typeof ClientProfileScalarFieldEnum)[keyof typeof ClientProfileScalarFieldEnum]


  export const ClientFeedbackScalarFieldEnum: {
    id: 'id',
    token: 'token',
    noteId: 'noteId',
    clientEmail: 'clientEmail',
    clientName: 'clientName',
    rating: 'rating',
    comment: 'comment',
    wouldReturn: 'wouldReturn',
    wouldRecommend: 'wouldRecommend',
    hasResponded: 'hasResponded',
    respondedAt: 'respondedAt',
    createdAt: 'createdAt'
  };

  export type ClientFeedbackScalarFieldEnum = (typeof ClientFeedbackScalarFieldEnum)[keyof typeof ClientFeedbackScalarFieldEnum]


  export const EmailLogScalarFieldEnum: {
    id: 'id',
    type: 'type',
    clientEmail: 'clientEmail',
    clientName: 'clientName',
    subject: 'subject',
    htmlContent: 'htmlContent',
    noteId: 'noteId',
    promotionId: 'promotionId',
    sentAt: 'sentAt',
    opened: 'opened',
    clicked: 'clicked'
  };

  export type EmailLogScalarFieldEnum = (typeof EmailLogScalarFieldEnum)[keyof typeof EmailLogScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    id: 'id',
    content: 'content',
    clientId: 'clientId',
    authorId: 'authorId',
    emailSent: 'emailSent',
    emailSentAt: 'emailSentAt',
    feedbackToken: 'feedbackToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const AssignmentScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    professionalId: 'professionalId',
    assignedAt: 'assignedAt'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    rating: 'rating',
    comment: 'comment',
    professionalId: 'professionalId',
    isAnonymous: 'isAnonymous',
    createdAt: 'createdAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ServiceCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceCategoryScalarFieldEnum = (typeof ServiceCategoryScalarFieldEnum)[keyof typeof ServiceCategoryScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    duration: 'duration',
    price: 'price',
    categoryId: 'categoryId',
    imageUrl: 'imageUrl',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    requiresProfessional: 'requiresProfessional',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const PackageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    price: 'price',
    originalPrice: 'originalPrice',
    discount: 'discount',
    variant: 'variant',
    imageUrl: 'imageUrl',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PackageScalarFieldEnum = (typeof PackageScalarFieldEnum)[keyof typeof PackageScalarFieldEnum]


  export const PackageServiceScalarFieldEnum: {
    id: 'id',
    packageId: 'packageId',
    serviceId: 'serviceId',
    quantity: 'quantity',
    isOptional: 'isOptional',
    extraCost: 'extraCost',
    createdAt: 'createdAt'
  };

  export type PackageServiceScalarFieldEnum = (typeof PackageServiceScalarFieldEnum)[keyof typeof PackageServiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    stripePaymentId: 'stripePaymentId',
    stripeCustomerId: 'stripeCustomerId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    paymentMethod: 'paymentMethod',
    receiptUrl: 'receiptUrl',
    receiptPdfUrl: 'receiptPdfUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    bookingNumber: 'bookingNumber',
    type: 'type',
    serviceId: 'serviceId',
    packageId: 'packageId',
    clientEmail: 'clientEmail',
    clientName: 'clientName',
    clientPhone: 'clientPhone',
    specialNotes: 'specialNotes',
    bookingDate: 'bookingDate',
    startTime: 'startTime',
    endTime: 'endTime',
    professionalId: 'professionalId',
    subtotal: 'subtotal',
    taxTPS: 'taxTPS',
    taxTVQ: 'taxTVQ',
    total: 'total',
    giftCardId: 'giftCardId',
    giftCardAmount: 'giftCardAmount',
    status: 'status',
    paymentId: 'paymentId',
    reminderSent: 'reminderSent',
    googleCalendarEventId: 'googleCalendarEventId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const AvailabilityScalarFieldEnum: {
    id: 'id',
    professionalId: 'professionalId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    isAvailable: 'isAvailable',
    reason: 'reason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AvailabilityScalarFieldEnum = (typeof AvailabilityScalarFieldEnum)[keyof typeof AvailabilityScalarFieldEnum]


  export const GiftCardScalarFieldEnum: {
    id: 'id',
    code: 'code',
    amount: 'amount',
    balance: 'balance',
    purchasedBy: 'purchasedBy',
    recipientName: 'recipientName',
    recipientEmail: 'recipientEmail',
    message: 'message',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    paymentId: 'paymentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GiftCardScalarFieldEnum = (typeof GiftCardScalarFieldEnum)[keyof typeof GiftCardScalarFieldEnum]


  export const GymMembershipScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    price: 'price',
    duration: 'duration',
    description: 'description',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GymMembershipScalarFieldEnum = (typeof GymMembershipScalarFieldEnum)[keyof typeof GymMembershipScalarFieldEnum]


  export const GymSubscriptionScalarFieldEnum: {
    id: 'id',
    membershipId: 'membershipId',
    clientEmail: 'clientEmail',
    clientName: 'clientName',
    clientPhone: 'clientPhone',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    paymentId: 'paymentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GymSubscriptionScalarFieldEnum = (typeof GymSubscriptionScalarFieldEnum)[keyof typeof GymSubscriptionScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    price: 'price',
    stock: 'stock',
    category: 'category',
    imageUrl: 'imageUrl',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    clientEmail: 'clientEmail',
    clientName: 'clientName',
    clientPhone: 'clientPhone',
    shippingAddress: 'shippingAddress',
    subtotal: 'subtotal',
    taxTPS: 'taxTPS',
    taxTVQ: 'taxTVQ',
    total: 'total',
    status: 'status',
    paymentId: 'paymentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity',
    price: 'price',
    createdAt: 'createdAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    code: 'code',
    discountType: 'discountType',
    discountValue: 'discountValue',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const ServicePromotionScalarFieldEnum: {
    id: 'id',
    promotionId: 'promotionId',
    serviceId: 'serviceId',
    createdAt: 'createdAt'
  };

  export type ServicePromotionScalarFieldEnum = (typeof ServicePromotionScalarFieldEnum)[keyof typeof ServicePromotionScalarFieldEnum]


  export const PackagePromotionScalarFieldEnum: {
    id: 'id',
    promotionId: 'promotionId',
    packageId: 'packageId',
    createdAt: 'createdAt'
  };

  export type PackagePromotionScalarFieldEnum = (typeof PackagePromotionScalarFieldEnum)[keyof typeof PackagePromotionScalarFieldEnum]


  export const ProductPromotionScalarFieldEnum: {
    id: 'id',
    promotionId: 'promotionId',
    productId: 'productId',
    createdAt: 'createdAt'
  };

  export type ProductPromotionScalarFieldEnum = (typeof ProductPromotionScalarFieldEnum)[keyof typeof ProductPromotionScalarFieldEnum]


  export const BookingStatusHistoryScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    oldStatus: 'oldStatus',
    newStatus: 'newStatus',
    changedById: 'changedById',
    changedBy: 'changedBy',
    changedByRole: 'changedByRole',
    reason: 'reason',
    notes: 'notes',
    oldDate: 'oldDate',
    newDate: 'newDate',
    oldStartTime: 'oldStartTime',
    newStartTime: 'newStartTime',
    oldEndTime: 'oldEndTime',
    newEndTime: 'newEndTime',
    oldProfessionalId: 'oldProfessionalId',
    newProfessionalId: 'newProfessionalId',
    changedAt: 'changedAt'
  };

  export type BookingStatusHistoryScalarFieldEnum = (typeof BookingStatusHistoryScalarFieldEnum)[keyof typeof BookingStatusHistoryScalarFieldEnum]


  export const WorkingScheduleScalarFieldEnum: {
    id: 'id',
    professionalId: 'professionalId',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkingScheduleScalarFieldEnum = (typeof WorkingScheduleScalarFieldEnum)[keyof typeof WorkingScheduleScalarFieldEnum]


  export const BreakPeriodScalarFieldEnum: {
    id: 'id',
    professionalId: 'professionalId',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    label: 'label',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BreakPeriodScalarFieldEnum = (typeof BreakPeriodScalarFieldEnum)[keyof typeof BreakPeriodScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    recipientEmail: 'recipientEmail',
    recipientName: 'recipientName',
    bookingId: 'bookingId',
    subject: 'subject',
    message: 'message',
    sent: 'sent',
    sentAt: 'sentAt',
    error: 'error',
    scheduledFor: 'scheduledFor',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SystemSettingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingsScalarFieldEnum = (typeof SystemSettingsScalarFieldEnum)[keyof typeof SystemSettingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'ServiceType'
   */
  export type EnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType'>
    


  /**
   * Reference to a field of type 'ServiceType[]'
   */
  export type ListEnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'BookingType'
   */
  export type EnumBookingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingType'>
    


  /**
   * Reference to a field of type 'BookingType[]'
   */
  export type ListEnumBookingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingType[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'DiscountType[]'
   */
  export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    telephone?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    nom?: StringNullableFilter<"User"> | string | null
    prenom?: StringNullableFilter<"User"> | string | null
    photoUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    notesCreated?: NoteListRelationFilter
    assignedClients?: AssignmentListRelationFilter
    reviewsReceived?: ReviewListRelationFilter
    bookingsAsProfessional?: BookingListRelationFilter
    bookingsCreated?: BookingListRelationFilter
    availabilities?: AvailabilityListRelationFilter
    workingSchedules?: WorkingScheduleListRelationFilter
    breaks?: BreakPeriodListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    nom?: SortOrderInput | SortOrder
    prenom?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notesCreated?: NoteOrderByRelationAggregateInput
    assignedClients?: AssignmentOrderByRelationAggregateInput
    reviewsReceived?: ReviewOrderByRelationAggregateInput
    bookingsAsProfessional?: BookingOrderByRelationAggregateInput
    bookingsCreated?: BookingOrderByRelationAggregateInput
    availabilities?: AvailabilityOrderByRelationAggregateInput
    workingSchedules?: WorkingScheduleOrderByRelationAggregateInput
    breaks?: BreakPeriodOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    telephone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    nom?: StringNullableFilter<"User"> | string | null
    prenom?: StringNullableFilter<"User"> | string | null
    photoUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    notesCreated?: NoteListRelationFilter
    assignedClients?: AssignmentListRelationFilter
    reviewsReceived?: ReviewListRelationFilter
    bookingsAsProfessional?: BookingListRelationFilter
    bookingsCreated?: BookingListRelationFilter
    availabilities?: AvailabilityListRelationFilter
    workingSchedules?: WorkingScheduleListRelationFilter
    breaks?: BreakPeriodListRelationFilter
  }, "id" | "email" | "telephone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    nom?: SortOrderInput | SortOrder
    prenom?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    telephone?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    nom?: StringNullableWithAggregatesFilter<"User"> | string | null
    prenom?: StringNullableWithAggregatesFilter<"User"> | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ClientProfileWhereInput = {
    AND?: ClientProfileWhereInput | ClientProfileWhereInput[]
    OR?: ClientProfileWhereInput[]
    NOT?: ClientProfileWhereInput | ClientProfileWhereInput[]
    id?: StringFilter<"ClientProfile"> | string
    nom?: StringFilter<"ClientProfile"> | string
    prenom?: StringFilter<"ClientProfile"> | string
    adresse?: StringFilter<"ClientProfile"> | string
    ville?: StringFilter<"ClientProfile"> | string
    codePostal?: StringFilter<"ClientProfile"> | string
    telMaison?: StringNullableFilter<"ClientProfile"> | string | null
    telBureau?: StringNullableFilter<"ClientProfile"> | string | null
    telCellulaire?: StringFilter<"ClientProfile"> | string
    courriel?: StringFilter<"ClientProfile"> | string
    dateNaissance?: DateTimeFilter<"ClientProfile"> | Date | string
    occupation?: StringNullableFilter<"ClientProfile"> | string | null
    gender?: EnumGenderFilter<"ClientProfile"> | $Enums.Gender
    serviceType?: EnumServiceTypeFilter<"ClientProfile"> | $Enums.ServiceType
    assuranceCouvert?: BoolFilter<"ClientProfile"> | boolean
    autreMaladie?: BoolNullableFilter<"ClientProfile"> | boolean | null
    autreMaladieDetails?: StringNullableFilter<"ClientProfile"> | string | null
    raisonConsultation?: StringNullableFilter<"ClientProfile"> | string | null
    diagnosticMedical?: BoolNullableFilter<"ClientProfile"> | boolean | null
    diagnosticMedicalDetails?: StringNullableFilter<"ClientProfile"> | string | null
    medicaments?: BoolNullableFilter<"ClientProfile"> | boolean | null
    medicamentsDetails?: StringNullableFilter<"ClientProfile"> | string | null
    accidents?: BoolNullableFilter<"ClientProfile"> | boolean | null
    accidentsDetails?: StringNullableFilter<"ClientProfile"> | string | null
    operationsChirurgicales?: BoolNullableFilter<"ClientProfile"> | boolean | null
    operationsChirurgicalesDetails?: StringNullableFilter<"ClientProfile"> | string | null
    traitementsActuels?: StringNullableFilter<"ClientProfile"> | string | null
    problemesCardiaques?: BoolFilter<"ClientProfile"> | boolean
    problemesCardiaquesDetails?: StringNullableFilter<"ClientProfile"> | string | null
    maladiesGraves?: BoolFilter<"ClientProfile"> | boolean
    maladiesGravesDetails?: StringNullableFilter<"ClientProfile"> | string | null
    ortheses?: BoolFilter<"ClientProfile"> | boolean
    orthesesDetails?: StringNullableFilter<"ClientProfile"> | string | null
    allergies?: BoolFilter<"ClientProfile"> | boolean
    allergiesDetails?: StringNullableFilter<"ClientProfile"> | string | null
    raideurs?: BoolFilter<"ClientProfile"> | boolean
    arthrose?: BoolFilter<"ClientProfile"> | boolean
    hernieDiscale?: BoolFilter<"ClientProfile"> | boolean
    oedeme?: BoolFilter<"ClientProfile"> | boolean
    tendinite?: BoolFilter<"ClientProfile"> | boolean
    mauxDeTete?: BoolFilter<"ClientProfile"> | boolean
    flatulence?: BoolFilter<"ClientProfile"> | boolean
    troublesCirculatoires?: BoolFilter<"ClientProfile"> | boolean
    hypothyroidie?: BoolFilter<"ClientProfile"> | boolean
    diabete?: BoolFilter<"ClientProfile"> | boolean
    stresse?: BoolFilter<"ClientProfile"> | boolean
    premenopause?: BoolFilter<"ClientProfile"> | boolean
    douleurMusculaire?: BoolFilter<"ClientProfile"> | boolean
    fibromyalgie?: BoolFilter<"ClientProfile"> | boolean
    rhumatisme?: BoolFilter<"ClientProfile"> | boolean
    sciatique?: BoolFilter<"ClientProfile"> | boolean
    bursite?: BoolFilter<"ClientProfile"> | boolean
    migraine?: BoolFilter<"ClientProfile"> | boolean
    diarrhee?: BoolFilter<"ClientProfile"> | boolean
    phlebite?: BoolFilter<"ClientProfile"> | boolean
    hypertension?: BoolFilter<"ClientProfile"> | boolean
    hypoglycemie?: BoolFilter<"ClientProfile"> | boolean
    burnOut?: BoolFilter<"ClientProfile"> | boolean
    menopause?: BoolFilter<"ClientProfile"> | boolean
    inflammationAigue?: BoolFilter<"ClientProfile"> | boolean
    arteriosclerose?: BoolFilter<"ClientProfile"> | boolean
    osteoporose?: BoolFilter<"ClientProfile"> | boolean
    mauxDeDos?: BoolFilter<"ClientProfile"> | boolean
    fatigueDesJambes?: BoolFilter<"ClientProfile"> | boolean
    troublesDigestifs?: BoolFilter<"ClientProfile"> | boolean
    constipation?: BoolFilter<"ClientProfile"> | boolean
    hyperthyroidie?: BoolFilter<"ClientProfile"> | boolean
    hypotension?: BoolFilter<"ClientProfile"> | boolean
    insomnie?: BoolFilter<"ClientProfile"> | boolean
    depressionNerveuse?: BoolFilter<"ClientProfile"> | boolean
    autres?: StringNullableFilter<"ClientProfile"> | string | null
    lastVisitDate?: DateTimeNullableFilter<"ClientProfile"> | Date | string | null
    lastEmailSent?: DateTimeNullableFilter<"ClientProfile"> | Date | string | null
    feedbackEmailsSent?: IntFilter<"ClientProfile"> | number
    promoEmailsSent?: IntFilter<"ClientProfile"> | number
    zonesDouleur?: StringNullableListFilter<"ClientProfile">
    etatPeau?: StringNullableFilter<"ClientProfile"> | string | null
    etatPores?: StringNullableFilter<"ClientProfile"> | string | null
    coucheCornee?: StringNullableFilter<"ClientProfile"> | string | null
    irrigationSanguine?: StringNullableFilter<"ClientProfile"> | string | null
    impuretes?: StringNullableFilter<"ClientProfile"> | string | null
    sensibiliteCutanee?: StringNullableFilter<"ClientProfile"> | string | null
    fumeur?: StringNullableFilter<"ClientProfile"> | string | null
    niveauStress?: StringNullableFilter<"ClientProfile"> | string | null
    expositionSoleil?: StringNullableFilter<"ClientProfile"> | string | null
    protectionSolaire?: StringNullableFilter<"ClientProfile"> | string | null
    suffisanceEau?: StringNullableFilter<"ClientProfile"> | string | null
    travailExterieur?: StringNullableFilter<"ClientProfile"> | string | null
    bainChauds?: StringNullableFilter<"ClientProfile"> | string | null
    routineSoins?: StringNullableFilter<"ClientProfile"> | string | null
    changementsRecents?: StringNullableFilter<"ClientProfile"> | string | null
    preferencePeau?: StringNullableFilter<"ClientProfile"> | string | null
    diagnosticVisuelNotes?: StringNullableFilter<"ClientProfile"> | string | null
    createdAt?: DateTimeFilter<"ClientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"ClientProfile"> | Date | string
    notes?: NoteListRelationFilter
    assignments?: AssignmentListRelationFilter
  }

  export type ClientProfileOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    adresse?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrder
    telMaison?: SortOrderInput | SortOrder
    telBureau?: SortOrderInput | SortOrder
    telCellulaire?: SortOrder
    courriel?: SortOrder
    dateNaissance?: SortOrder
    occupation?: SortOrderInput | SortOrder
    gender?: SortOrder
    serviceType?: SortOrder
    assuranceCouvert?: SortOrder
    autreMaladie?: SortOrderInput | SortOrder
    autreMaladieDetails?: SortOrderInput | SortOrder
    raisonConsultation?: SortOrderInput | SortOrder
    diagnosticMedical?: SortOrderInput | SortOrder
    diagnosticMedicalDetails?: SortOrderInput | SortOrder
    medicaments?: SortOrderInput | SortOrder
    medicamentsDetails?: SortOrderInput | SortOrder
    accidents?: SortOrderInput | SortOrder
    accidentsDetails?: SortOrderInput | SortOrder
    operationsChirurgicales?: SortOrderInput | SortOrder
    operationsChirurgicalesDetails?: SortOrderInput | SortOrder
    traitementsActuels?: SortOrderInput | SortOrder
    problemesCardiaques?: SortOrder
    problemesCardiaquesDetails?: SortOrderInput | SortOrder
    maladiesGraves?: SortOrder
    maladiesGravesDetails?: SortOrderInput | SortOrder
    ortheses?: SortOrder
    orthesesDetails?: SortOrderInput | SortOrder
    allergies?: SortOrder
    allergiesDetails?: SortOrderInput | SortOrder
    raideurs?: SortOrder
    arthrose?: SortOrder
    hernieDiscale?: SortOrder
    oedeme?: SortOrder
    tendinite?: SortOrder
    mauxDeTete?: SortOrder
    flatulence?: SortOrder
    troublesCirculatoires?: SortOrder
    hypothyroidie?: SortOrder
    diabete?: SortOrder
    stresse?: SortOrder
    premenopause?: SortOrder
    douleurMusculaire?: SortOrder
    fibromyalgie?: SortOrder
    rhumatisme?: SortOrder
    sciatique?: SortOrder
    bursite?: SortOrder
    migraine?: SortOrder
    diarrhee?: SortOrder
    phlebite?: SortOrder
    hypertension?: SortOrder
    hypoglycemie?: SortOrder
    burnOut?: SortOrder
    menopause?: SortOrder
    inflammationAigue?: SortOrder
    arteriosclerose?: SortOrder
    osteoporose?: SortOrder
    mauxDeDos?: SortOrder
    fatigueDesJambes?: SortOrder
    troublesDigestifs?: SortOrder
    constipation?: SortOrder
    hyperthyroidie?: SortOrder
    hypotension?: SortOrder
    insomnie?: SortOrder
    depressionNerveuse?: SortOrder
    autres?: SortOrderInput | SortOrder
    lastVisitDate?: SortOrderInput | SortOrder
    lastEmailSent?: SortOrderInput | SortOrder
    feedbackEmailsSent?: SortOrder
    promoEmailsSent?: SortOrder
    zonesDouleur?: SortOrder
    etatPeau?: SortOrderInput | SortOrder
    etatPores?: SortOrderInput | SortOrder
    coucheCornee?: SortOrderInput | SortOrder
    irrigationSanguine?: SortOrderInput | SortOrder
    impuretes?: SortOrderInput | SortOrder
    sensibiliteCutanee?: SortOrderInput | SortOrder
    fumeur?: SortOrderInput | SortOrder
    niveauStress?: SortOrderInput | SortOrder
    expositionSoleil?: SortOrderInput | SortOrder
    protectionSolaire?: SortOrderInput | SortOrder
    suffisanceEau?: SortOrderInput | SortOrder
    travailExterieur?: SortOrderInput | SortOrder
    bainChauds?: SortOrderInput | SortOrder
    routineSoins?: SortOrderInput | SortOrder
    changementsRecents?: SortOrderInput | SortOrder
    preferencePeau?: SortOrderInput | SortOrder
    diagnosticVisuelNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notes?: NoteOrderByRelationAggregateInput
    assignments?: AssignmentOrderByRelationAggregateInput
  }

  export type ClientProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    telCellulaire?: string
    courriel?: string
    AND?: ClientProfileWhereInput | ClientProfileWhereInput[]
    OR?: ClientProfileWhereInput[]
    NOT?: ClientProfileWhereInput | ClientProfileWhereInput[]
    nom?: StringFilter<"ClientProfile"> | string
    prenom?: StringFilter<"ClientProfile"> | string
    adresse?: StringFilter<"ClientProfile"> | string
    ville?: StringFilter<"ClientProfile"> | string
    codePostal?: StringFilter<"ClientProfile"> | string
    telMaison?: StringNullableFilter<"ClientProfile"> | string | null
    telBureau?: StringNullableFilter<"ClientProfile"> | string | null
    dateNaissance?: DateTimeFilter<"ClientProfile"> | Date | string
    occupation?: StringNullableFilter<"ClientProfile"> | string | null
    gender?: EnumGenderFilter<"ClientProfile"> | $Enums.Gender
    serviceType?: EnumServiceTypeFilter<"ClientProfile"> | $Enums.ServiceType
    assuranceCouvert?: BoolFilter<"ClientProfile"> | boolean
    autreMaladie?: BoolNullableFilter<"ClientProfile"> | boolean | null
    autreMaladieDetails?: StringNullableFilter<"ClientProfile"> | string | null
    raisonConsultation?: StringNullableFilter<"ClientProfile"> | string | null
    diagnosticMedical?: BoolNullableFilter<"ClientProfile"> | boolean | null
    diagnosticMedicalDetails?: StringNullableFilter<"ClientProfile"> | string | null
    medicaments?: BoolNullableFilter<"ClientProfile"> | boolean | null
    medicamentsDetails?: StringNullableFilter<"ClientProfile"> | string | null
    accidents?: BoolNullableFilter<"ClientProfile"> | boolean | null
    accidentsDetails?: StringNullableFilter<"ClientProfile"> | string | null
    operationsChirurgicales?: BoolNullableFilter<"ClientProfile"> | boolean | null
    operationsChirurgicalesDetails?: StringNullableFilter<"ClientProfile"> | string | null
    traitementsActuels?: StringNullableFilter<"ClientProfile"> | string | null
    problemesCardiaques?: BoolFilter<"ClientProfile"> | boolean
    problemesCardiaquesDetails?: StringNullableFilter<"ClientProfile"> | string | null
    maladiesGraves?: BoolFilter<"ClientProfile"> | boolean
    maladiesGravesDetails?: StringNullableFilter<"ClientProfile"> | string | null
    ortheses?: BoolFilter<"ClientProfile"> | boolean
    orthesesDetails?: StringNullableFilter<"ClientProfile"> | string | null
    allergies?: BoolFilter<"ClientProfile"> | boolean
    allergiesDetails?: StringNullableFilter<"ClientProfile"> | string | null
    raideurs?: BoolFilter<"ClientProfile"> | boolean
    arthrose?: BoolFilter<"ClientProfile"> | boolean
    hernieDiscale?: BoolFilter<"ClientProfile"> | boolean
    oedeme?: BoolFilter<"ClientProfile"> | boolean
    tendinite?: BoolFilter<"ClientProfile"> | boolean
    mauxDeTete?: BoolFilter<"ClientProfile"> | boolean
    flatulence?: BoolFilter<"ClientProfile"> | boolean
    troublesCirculatoires?: BoolFilter<"ClientProfile"> | boolean
    hypothyroidie?: BoolFilter<"ClientProfile"> | boolean
    diabete?: BoolFilter<"ClientProfile"> | boolean
    stresse?: BoolFilter<"ClientProfile"> | boolean
    premenopause?: BoolFilter<"ClientProfile"> | boolean
    douleurMusculaire?: BoolFilter<"ClientProfile"> | boolean
    fibromyalgie?: BoolFilter<"ClientProfile"> | boolean
    rhumatisme?: BoolFilter<"ClientProfile"> | boolean
    sciatique?: BoolFilter<"ClientProfile"> | boolean
    bursite?: BoolFilter<"ClientProfile"> | boolean
    migraine?: BoolFilter<"ClientProfile"> | boolean
    diarrhee?: BoolFilter<"ClientProfile"> | boolean
    phlebite?: BoolFilter<"ClientProfile"> | boolean
    hypertension?: BoolFilter<"ClientProfile"> | boolean
    hypoglycemie?: BoolFilter<"ClientProfile"> | boolean
    burnOut?: BoolFilter<"ClientProfile"> | boolean
    menopause?: BoolFilter<"ClientProfile"> | boolean
    inflammationAigue?: BoolFilter<"ClientProfile"> | boolean
    arteriosclerose?: BoolFilter<"ClientProfile"> | boolean
    osteoporose?: BoolFilter<"ClientProfile"> | boolean
    mauxDeDos?: BoolFilter<"ClientProfile"> | boolean
    fatigueDesJambes?: BoolFilter<"ClientProfile"> | boolean
    troublesDigestifs?: BoolFilter<"ClientProfile"> | boolean
    constipation?: BoolFilter<"ClientProfile"> | boolean
    hyperthyroidie?: BoolFilter<"ClientProfile"> | boolean
    hypotension?: BoolFilter<"ClientProfile"> | boolean
    insomnie?: BoolFilter<"ClientProfile"> | boolean
    depressionNerveuse?: BoolFilter<"ClientProfile"> | boolean
    autres?: StringNullableFilter<"ClientProfile"> | string | null
    lastVisitDate?: DateTimeNullableFilter<"ClientProfile"> | Date | string | null
    lastEmailSent?: DateTimeNullableFilter<"ClientProfile"> | Date | string | null
    feedbackEmailsSent?: IntFilter<"ClientProfile"> | number
    promoEmailsSent?: IntFilter<"ClientProfile"> | number
    zonesDouleur?: StringNullableListFilter<"ClientProfile">
    etatPeau?: StringNullableFilter<"ClientProfile"> | string | null
    etatPores?: StringNullableFilter<"ClientProfile"> | string | null
    coucheCornee?: StringNullableFilter<"ClientProfile"> | string | null
    irrigationSanguine?: StringNullableFilter<"ClientProfile"> | string | null
    impuretes?: StringNullableFilter<"ClientProfile"> | string | null
    sensibiliteCutanee?: StringNullableFilter<"ClientProfile"> | string | null
    fumeur?: StringNullableFilter<"ClientProfile"> | string | null
    niveauStress?: StringNullableFilter<"ClientProfile"> | string | null
    expositionSoleil?: StringNullableFilter<"ClientProfile"> | string | null
    protectionSolaire?: StringNullableFilter<"ClientProfile"> | string | null
    suffisanceEau?: StringNullableFilter<"ClientProfile"> | string | null
    travailExterieur?: StringNullableFilter<"ClientProfile"> | string | null
    bainChauds?: StringNullableFilter<"ClientProfile"> | string | null
    routineSoins?: StringNullableFilter<"ClientProfile"> | string | null
    changementsRecents?: StringNullableFilter<"ClientProfile"> | string | null
    preferencePeau?: StringNullableFilter<"ClientProfile"> | string | null
    diagnosticVisuelNotes?: StringNullableFilter<"ClientProfile"> | string | null
    createdAt?: DateTimeFilter<"ClientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"ClientProfile"> | Date | string
    notes?: NoteListRelationFilter
    assignments?: AssignmentListRelationFilter
  }, "id" | "telCellulaire" | "courriel">

  export type ClientProfileOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    adresse?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrder
    telMaison?: SortOrderInput | SortOrder
    telBureau?: SortOrderInput | SortOrder
    telCellulaire?: SortOrder
    courriel?: SortOrder
    dateNaissance?: SortOrder
    occupation?: SortOrderInput | SortOrder
    gender?: SortOrder
    serviceType?: SortOrder
    assuranceCouvert?: SortOrder
    autreMaladie?: SortOrderInput | SortOrder
    autreMaladieDetails?: SortOrderInput | SortOrder
    raisonConsultation?: SortOrderInput | SortOrder
    diagnosticMedical?: SortOrderInput | SortOrder
    diagnosticMedicalDetails?: SortOrderInput | SortOrder
    medicaments?: SortOrderInput | SortOrder
    medicamentsDetails?: SortOrderInput | SortOrder
    accidents?: SortOrderInput | SortOrder
    accidentsDetails?: SortOrderInput | SortOrder
    operationsChirurgicales?: SortOrderInput | SortOrder
    operationsChirurgicalesDetails?: SortOrderInput | SortOrder
    traitementsActuels?: SortOrderInput | SortOrder
    problemesCardiaques?: SortOrder
    problemesCardiaquesDetails?: SortOrderInput | SortOrder
    maladiesGraves?: SortOrder
    maladiesGravesDetails?: SortOrderInput | SortOrder
    ortheses?: SortOrder
    orthesesDetails?: SortOrderInput | SortOrder
    allergies?: SortOrder
    allergiesDetails?: SortOrderInput | SortOrder
    raideurs?: SortOrder
    arthrose?: SortOrder
    hernieDiscale?: SortOrder
    oedeme?: SortOrder
    tendinite?: SortOrder
    mauxDeTete?: SortOrder
    flatulence?: SortOrder
    troublesCirculatoires?: SortOrder
    hypothyroidie?: SortOrder
    diabete?: SortOrder
    stresse?: SortOrder
    premenopause?: SortOrder
    douleurMusculaire?: SortOrder
    fibromyalgie?: SortOrder
    rhumatisme?: SortOrder
    sciatique?: SortOrder
    bursite?: SortOrder
    migraine?: SortOrder
    diarrhee?: SortOrder
    phlebite?: SortOrder
    hypertension?: SortOrder
    hypoglycemie?: SortOrder
    burnOut?: SortOrder
    menopause?: SortOrder
    inflammationAigue?: SortOrder
    arteriosclerose?: SortOrder
    osteoporose?: SortOrder
    mauxDeDos?: SortOrder
    fatigueDesJambes?: SortOrder
    troublesDigestifs?: SortOrder
    constipation?: SortOrder
    hyperthyroidie?: SortOrder
    hypotension?: SortOrder
    insomnie?: SortOrder
    depressionNerveuse?: SortOrder
    autres?: SortOrderInput | SortOrder
    lastVisitDate?: SortOrderInput | SortOrder
    lastEmailSent?: SortOrderInput | SortOrder
    feedbackEmailsSent?: SortOrder
    promoEmailsSent?: SortOrder
    zonesDouleur?: SortOrder
    etatPeau?: SortOrderInput | SortOrder
    etatPores?: SortOrderInput | SortOrder
    coucheCornee?: SortOrderInput | SortOrder
    irrigationSanguine?: SortOrderInput | SortOrder
    impuretes?: SortOrderInput | SortOrder
    sensibiliteCutanee?: SortOrderInput | SortOrder
    fumeur?: SortOrderInput | SortOrder
    niveauStress?: SortOrderInput | SortOrder
    expositionSoleil?: SortOrderInput | SortOrder
    protectionSolaire?: SortOrderInput | SortOrder
    suffisanceEau?: SortOrderInput | SortOrder
    travailExterieur?: SortOrderInput | SortOrder
    bainChauds?: SortOrderInput | SortOrder
    routineSoins?: SortOrderInput | SortOrder
    changementsRecents?: SortOrderInput | SortOrder
    preferencePeau?: SortOrderInput | SortOrder
    diagnosticVisuelNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientProfileCountOrderByAggregateInput
    _avg?: ClientProfileAvgOrderByAggregateInput
    _max?: ClientProfileMaxOrderByAggregateInput
    _min?: ClientProfileMinOrderByAggregateInput
    _sum?: ClientProfileSumOrderByAggregateInput
  }

  export type ClientProfileScalarWhereWithAggregatesInput = {
    AND?: ClientProfileScalarWhereWithAggregatesInput | ClientProfileScalarWhereWithAggregatesInput[]
    OR?: ClientProfileScalarWhereWithAggregatesInput[]
    NOT?: ClientProfileScalarWhereWithAggregatesInput | ClientProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientProfile"> | string
    nom?: StringWithAggregatesFilter<"ClientProfile"> | string
    prenom?: StringWithAggregatesFilter<"ClientProfile"> | string
    adresse?: StringWithAggregatesFilter<"ClientProfile"> | string
    ville?: StringWithAggregatesFilter<"ClientProfile"> | string
    codePostal?: StringWithAggregatesFilter<"ClientProfile"> | string
    telMaison?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    telBureau?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    telCellulaire?: StringWithAggregatesFilter<"ClientProfile"> | string
    courriel?: StringWithAggregatesFilter<"ClientProfile"> | string
    dateNaissance?: DateTimeWithAggregatesFilter<"ClientProfile"> | Date | string
    occupation?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    gender?: EnumGenderWithAggregatesFilter<"ClientProfile"> | $Enums.Gender
    serviceType?: EnumServiceTypeWithAggregatesFilter<"ClientProfile"> | $Enums.ServiceType
    assuranceCouvert?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    autreMaladie?: BoolNullableWithAggregatesFilter<"ClientProfile"> | boolean | null
    autreMaladieDetails?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    raisonConsultation?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    diagnosticMedical?: BoolNullableWithAggregatesFilter<"ClientProfile"> | boolean | null
    diagnosticMedicalDetails?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    medicaments?: BoolNullableWithAggregatesFilter<"ClientProfile"> | boolean | null
    medicamentsDetails?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    accidents?: BoolNullableWithAggregatesFilter<"ClientProfile"> | boolean | null
    accidentsDetails?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    operationsChirurgicales?: BoolNullableWithAggregatesFilter<"ClientProfile"> | boolean | null
    operationsChirurgicalesDetails?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    traitementsActuels?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    problemesCardiaques?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    problemesCardiaquesDetails?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    maladiesGraves?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    maladiesGravesDetails?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    ortheses?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    orthesesDetails?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    allergies?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    allergiesDetails?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    raideurs?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    arthrose?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    hernieDiscale?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    oedeme?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    tendinite?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    mauxDeTete?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    flatulence?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    troublesCirculatoires?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    hypothyroidie?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    diabete?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    stresse?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    premenopause?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    douleurMusculaire?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    fibromyalgie?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    rhumatisme?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    sciatique?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    bursite?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    migraine?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    diarrhee?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    phlebite?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    hypertension?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    hypoglycemie?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    burnOut?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    menopause?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    inflammationAigue?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    arteriosclerose?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    osteoporose?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    mauxDeDos?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    fatigueDesJambes?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    troublesDigestifs?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    constipation?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    hyperthyroidie?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    hypotension?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    insomnie?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    depressionNerveuse?: BoolWithAggregatesFilter<"ClientProfile"> | boolean
    autres?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    lastVisitDate?: DateTimeNullableWithAggregatesFilter<"ClientProfile"> | Date | string | null
    lastEmailSent?: DateTimeNullableWithAggregatesFilter<"ClientProfile"> | Date | string | null
    feedbackEmailsSent?: IntWithAggregatesFilter<"ClientProfile"> | number
    promoEmailsSent?: IntWithAggregatesFilter<"ClientProfile"> | number
    zonesDouleur?: StringNullableListFilter<"ClientProfile">
    etatPeau?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    etatPores?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    coucheCornee?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    irrigationSanguine?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    impuretes?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    sensibiliteCutanee?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    fumeur?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    niveauStress?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    expositionSoleil?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    protectionSolaire?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    suffisanceEau?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    travailExterieur?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    bainChauds?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    routineSoins?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    changementsRecents?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    preferencePeau?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    diagnosticVisuelNotes?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientProfile"> | Date | string
  }

  export type ClientFeedbackWhereInput = {
    AND?: ClientFeedbackWhereInput | ClientFeedbackWhereInput[]
    OR?: ClientFeedbackWhereInput[]
    NOT?: ClientFeedbackWhereInput | ClientFeedbackWhereInput[]
    id?: StringFilter<"ClientFeedback"> | string
    token?: StringFilter<"ClientFeedback"> | string
    noteId?: StringFilter<"ClientFeedback"> | string
    clientEmail?: StringNullableFilter<"ClientFeedback"> | string | null
    clientName?: StringNullableFilter<"ClientFeedback"> | string | null
    rating?: IntNullableFilter<"ClientFeedback"> | number | null
    comment?: StringNullableFilter<"ClientFeedback"> | string | null
    wouldReturn?: BoolNullableFilter<"ClientFeedback"> | boolean | null
    wouldRecommend?: BoolNullableFilter<"ClientFeedback"> | boolean | null
    hasResponded?: BoolFilter<"ClientFeedback"> | boolean
    respondedAt?: DateTimeNullableFilter<"ClientFeedback"> | Date | string | null
    createdAt?: DateTimeFilter<"ClientFeedback"> | Date | string
  }

  export type ClientFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    noteId?: SortOrder
    clientEmail?: SortOrderInput | SortOrder
    clientName?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    wouldReturn?: SortOrderInput | SortOrder
    wouldRecommend?: SortOrderInput | SortOrder
    hasResponded?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ClientFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    noteId?: string
    AND?: ClientFeedbackWhereInput | ClientFeedbackWhereInput[]
    OR?: ClientFeedbackWhereInput[]
    NOT?: ClientFeedbackWhereInput | ClientFeedbackWhereInput[]
    clientEmail?: StringNullableFilter<"ClientFeedback"> | string | null
    clientName?: StringNullableFilter<"ClientFeedback"> | string | null
    rating?: IntNullableFilter<"ClientFeedback"> | number | null
    comment?: StringNullableFilter<"ClientFeedback"> | string | null
    wouldReturn?: BoolNullableFilter<"ClientFeedback"> | boolean | null
    wouldRecommend?: BoolNullableFilter<"ClientFeedback"> | boolean | null
    hasResponded?: BoolFilter<"ClientFeedback"> | boolean
    respondedAt?: DateTimeNullableFilter<"ClientFeedback"> | Date | string | null
    createdAt?: DateTimeFilter<"ClientFeedback"> | Date | string
  }, "id" | "token" | "noteId">

  export type ClientFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    noteId?: SortOrder
    clientEmail?: SortOrderInput | SortOrder
    clientName?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    wouldReturn?: SortOrderInput | SortOrder
    wouldRecommend?: SortOrderInput | SortOrder
    hasResponded?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ClientFeedbackCountOrderByAggregateInput
    _avg?: ClientFeedbackAvgOrderByAggregateInput
    _max?: ClientFeedbackMaxOrderByAggregateInput
    _min?: ClientFeedbackMinOrderByAggregateInput
    _sum?: ClientFeedbackSumOrderByAggregateInput
  }

  export type ClientFeedbackScalarWhereWithAggregatesInput = {
    AND?: ClientFeedbackScalarWhereWithAggregatesInput | ClientFeedbackScalarWhereWithAggregatesInput[]
    OR?: ClientFeedbackScalarWhereWithAggregatesInput[]
    NOT?: ClientFeedbackScalarWhereWithAggregatesInput | ClientFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientFeedback"> | string
    token?: StringWithAggregatesFilter<"ClientFeedback"> | string
    noteId?: StringWithAggregatesFilter<"ClientFeedback"> | string
    clientEmail?: StringNullableWithAggregatesFilter<"ClientFeedback"> | string | null
    clientName?: StringNullableWithAggregatesFilter<"ClientFeedback"> | string | null
    rating?: IntNullableWithAggregatesFilter<"ClientFeedback"> | number | null
    comment?: StringNullableWithAggregatesFilter<"ClientFeedback"> | string | null
    wouldReturn?: BoolNullableWithAggregatesFilter<"ClientFeedback"> | boolean | null
    wouldRecommend?: BoolNullableWithAggregatesFilter<"ClientFeedback"> | boolean | null
    hasResponded?: BoolWithAggregatesFilter<"ClientFeedback"> | boolean
    respondedAt?: DateTimeNullableWithAggregatesFilter<"ClientFeedback"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientFeedback"> | Date | string
  }

  export type EmailLogWhereInput = {
    AND?: EmailLogWhereInput | EmailLogWhereInput[]
    OR?: EmailLogWhereInput[]
    NOT?: EmailLogWhereInput | EmailLogWhereInput[]
    id?: StringFilter<"EmailLog"> | string
    type?: StringFilter<"EmailLog"> | string
    clientEmail?: StringFilter<"EmailLog"> | string
    clientName?: StringNullableFilter<"EmailLog"> | string | null
    subject?: StringFilter<"EmailLog"> | string
    htmlContent?: StringFilter<"EmailLog"> | string
    noteId?: StringNullableFilter<"EmailLog"> | string | null
    promotionId?: StringNullableFilter<"EmailLog"> | string | null
    sentAt?: DateTimeFilter<"EmailLog"> | Date | string
    opened?: BoolFilter<"EmailLog"> | boolean
    clicked?: BoolFilter<"EmailLog"> | boolean
  }

  export type EmailLogOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrderInput | SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    noteId?: SortOrderInput | SortOrder
    promotionId?: SortOrderInput | SortOrder
    sentAt?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
  }

  export type EmailLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailLogWhereInput | EmailLogWhereInput[]
    OR?: EmailLogWhereInput[]
    NOT?: EmailLogWhereInput | EmailLogWhereInput[]
    type?: StringFilter<"EmailLog"> | string
    clientEmail?: StringFilter<"EmailLog"> | string
    clientName?: StringNullableFilter<"EmailLog"> | string | null
    subject?: StringFilter<"EmailLog"> | string
    htmlContent?: StringFilter<"EmailLog"> | string
    noteId?: StringNullableFilter<"EmailLog"> | string | null
    promotionId?: StringNullableFilter<"EmailLog"> | string | null
    sentAt?: DateTimeFilter<"EmailLog"> | Date | string
    opened?: BoolFilter<"EmailLog"> | boolean
    clicked?: BoolFilter<"EmailLog"> | boolean
  }, "id">

  export type EmailLogOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrderInput | SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    noteId?: SortOrderInput | SortOrder
    promotionId?: SortOrderInput | SortOrder
    sentAt?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
    _count?: EmailLogCountOrderByAggregateInput
    _max?: EmailLogMaxOrderByAggregateInput
    _min?: EmailLogMinOrderByAggregateInput
  }

  export type EmailLogScalarWhereWithAggregatesInput = {
    AND?: EmailLogScalarWhereWithAggregatesInput | EmailLogScalarWhereWithAggregatesInput[]
    OR?: EmailLogScalarWhereWithAggregatesInput[]
    NOT?: EmailLogScalarWhereWithAggregatesInput | EmailLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailLog"> | string
    type?: StringWithAggregatesFilter<"EmailLog"> | string
    clientEmail?: StringWithAggregatesFilter<"EmailLog"> | string
    clientName?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    subject?: StringWithAggregatesFilter<"EmailLog"> | string
    htmlContent?: StringWithAggregatesFilter<"EmailLog"> | string
    noteId?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    promotionId?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    sentAt?: DateTimeWithAggregatesFilter<"EmailLog"> | Date | string
    opened?: BoolWithAggregatesFilter<"EmailLog"> | boolean
    clicked?: BoolWithAggregatesFilter<"EmailLog"> | boolean
  }

  export type NoteWhereInput = {
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    id?: StringFilter<"Note"> | string
    content?: StringFilter<"Note"> | string
    clientId?: StringFilter<"Note"> | string
    authorId?: StringFilter<"Note"> | string
    emailSent?: BoolFilter<"Note"> | boolean
    emailSentAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    feedbackToken?: StringNullableFilter<"Note"> | string | null
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NoteOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    clientId?: SortOrder
    authorId?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    feedbackToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientProfileOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    feedbackToken?: string
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    content?: StringFilter<"Note"> | string
    clientId?: StringFilter<"Note"> | string
    authorId?: StringFilter<"Note"> | string
    emailSent?: BoolFilter<"Note"> | boolean
    emailSentAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "feedbackToken">

  export type NoteOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    clientId?: SortOrder
    authorId?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    feedbackToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NoteCountOrderByAggregateInput
    _max?: NoteMaxOrderByAggregateInput
    _min?: NoteMinOrderByAggregateInput
  }

  export type NoteScalarWhereWithAggregatesInput = {
    AND?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    OR?: NoteScalarWhereWithAggregatesInput[]
    NOT?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Note"> | string
    content?: StringWithAggregatesFilter<"Note"> | string
    clientId?: StringWithAggregatesFilter<"Note"> | string
    authorId?: StringWithAggregatesFilter<"Note"> | string
    emailSent?: BoolWithAggregatesFilter<"Note"> | boolean
    emailSentAt?: DateTimeNullableWithAggregatesFilter<"Note"> | Date | string | null
    feedbackToken?: StringNullableWithAggregatesFilter<"Note"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
  }

  export type AssignmentWhereInput = {
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    id?: StringFilter<"Assignment"> | string
    clientId?: StringFilter<"Assignment"> | string
    professionalId?: StringFilter<"Assignment"> | string
    assignedAt?: DateTimeFilter<"Assignment"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
    professional?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AssignmentOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    professionalId?: SortOrder
    assignedAt?: SortOrder
    client?: ClientProfileOrderByWithRelationInput
    professional?: UserOrderByWithRelationInput
  }

  export type AssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    clientId?: StringFilter<"Assignment"> | string
    professionalId?: StringFilter<"Assignment"> | string
    assignedAt?: DateTimeFilter<"Assignment"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
    professional?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    professionalId?: SortOrder
    assignedAt?: SortOrder
    _count?: AssignmentCountOrderByAggregateInput
    _max?: AssignmentMaxOrderByAggregateInput
    _min?: AssignmentMinOrderByAggregateInput
  }

  export type AssignmentScalarWhereWithAggregatesInput = {
    AND?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    OR?: AssignmentScalarWhereWithAggregatesInput[]
    NOT?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Assignment"> | string
    clientId?: StringWithAggregatesFilter<"Assignment"> | string
    professionalId?: StringWithAggregatesFilter<"Assignment"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    professionalId?: StringFilter<"Review"> | string
    isAnonymous?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    professional?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    professionalId?: SortOrder
    isAnonymous?: SortOrder
    createdAt?: SortOrder
    professional?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    professionalId?: StringFilter<"Review"> | string
    isAnonymous?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    professional?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    professionalId?: SortOrder
    isAnonymous?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    professionalId?: StringWithAggregatesFilter<"Review"> | string
    isAnonymous?: BoolWithAggregatesFilter<"Review"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type ServiceCategoryWhereInput = {
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    id?: StringFilter<"ServiceCategory"> | string
    name?: StringFilter<"ServiceCategory"> | string
    description?: StringNullableFilter<"ServiceCategory"> | string | null
    displayOrder?: IntFilter<"ServiceCategory"> | number
    isActive?: BoolFilter<"ServiceCategory"> | boolean
    createdAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    services?: ServiceListRelationFilter
  }

  export type ServiceCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
  }

  export type ServiceCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    OR?: ServiceCategoryWhereInput[]
    NOT?: ServiceCategoryWhereInput | ServiceCategoryWhereInput[]
    description?: StringNullableFilter<"ServiceCategory"> | string | null
    displayOrder?: IntFilter<"ServiceCategory"> | number
    isActive?: BoolFilter<"ServiceCategory"> | boolean
    createdAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceCategory"> | Date | string
    services?: ServiceListRelationFilter
  }, "id" | "name">

  export type ServiceCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCategoryCountOrderByAggregateInput
    _avg?: ServiceCategoryAvgOrderByAggregateInput
    _max?: ServiceCategoryMaxOrderByAggregateInput
    _min?: ServiceCategoryMinOrderByAggregateInput
    _sum?: ServiceCategorySumOrderByAggregateInput
  }

  export type ServiceCategoryScalarWhereWithAggregatesInput = {
    AND?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    OR?: ServiceCategoryScalarWhereWithAggregatesInput[]
    NOT?: ServiceCategoryScalarWhereWithAggregatesInput | ServiceCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceCategory"> | string
    name?: StringWithAggregatesFilter<"ServiceCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ServiceCategory"> | string | null
    displayOrder?: IntWithAggregatesFilter<"ServiceCategory"> | number
    isActive?: BoolWithAggregatesFilter<"ServiceCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ServiceCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceCategory"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    slug?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    duration?: IntFilter<"Service"> | number
    price?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    categoryId?: StringFilter<"Service"> | string
    imageUrl?: StringNullableFilter<"Service"> | string | null
    displayOrder?: IntFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    requiresProfessional?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    category?: XOR<ServiceCategoryRelationFilter, ServiceCategoryWhereInput>
    bookings?: BookingListRelationFilter
    packageServices?: PackageServiceListRelationFilter
    promotions?: ServicePromotionListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    duration?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    requiresProfessional?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: ServiceCategoryOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    packageServices?: PackageServiceOrderByRelationAggregateInput
    promotions?: ServicePromotionOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    duration?: IntFilter<"Service"> | number
    price?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    categoryId?: StringFilter<"Service"> | string
    imageUrl?: StringNullableFilter<"Service"> | string | null
    displayOrder?: IntFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    requiresProfessional?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    category?: XOR<ServiceCategoryRelationFilter, ServiceCategoryWhereInput>
    bookings?: BookingListRelationFilter
    packageServices?: PackageServiceListRelationFilter
    promotions?: ServicePromotionListRelationFilter
  }, "id" | "slug">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    duration?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    requiresProfessional?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    slug?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    duration?: IntWithAggregatesFilter<"Service"> | number
    price?: DecimalWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string
    categoryId?: StringWithAggregatesFilter<"Service"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Service"> | string | null
    displayOrder?: IntWithAggregatesFilter<"Service"> | number
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    requiresProfessional?: BoolWithAggregatesFilter<"Service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type PackageWhereInput = {
    AND?: PackageWhereInput | PackageWhereInput[]
    OR?: PackageWhereInput[]
    NOT?: PackageWhereInput | PackageWhereInput[]
    id?: StringFilter<"Package"> | string
    name?: StringFilter<"Package"> | string
    slug?: StringFilter<"Package"> | string
    description?: StringNullableFilter<"Package"> | string | null
    price?: DecimalFilter<"Package"> | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalNullableFilter<"Package"> | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalNullableFilter<"Package"> | Decimal | DecimalJsLike | number | string | null
    variant?: StringNullableFilter<"Package"> | string | null
    imageUrl?: StringNullableFilter<"Package"> | string | null
    displayOrder?: IntFilter<"Package"> | number
    isActive?: BoolFilter<"Package"> | boolean
    createdAt?: DateTimeFilter<"Package"> | Date | string
    updatedAt?: DateTimeFilter<"Package"> | Date | string
    services?: PackageServiceListRelationFilter
    bookings?: BookingListRelationFilter
    promotions?: PackagePromotionListRelationFilter
  }

  export type PackageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    originalPrice?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    variant?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    services?: PackageServiceOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    promotions?: PackagePromotionOrderByRelationAggregateInput
  }

  export type PackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PackageWhereInput | PackageWhereInput[]
    OR?: PackageWhereInput[]
    NOT?: PackageWhereInput | PackageWhereInput[]
    name?: StringFilter<"Package"> | string
    description?: StringNullableFilter<"Package"> | string | null
    price?: DecimalFilter<"Package"> | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalNullableFilter<"Package"> | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalNullableFilter<"Package"> | Decimal | DecimalJsLike | number | string | null
    variant?: StringNullableFilter<"Package"> | string | null
    imageUrl?: StringNullableFilter<"Package"> | string | null
    displayOrder?: IntFilter<"Package"> | number
    isActive?: BoolFilter<"Package"> | boolean
    createdAt?: DateTimeFilter<"Package"> | Date | string
    updatedAt?: DateTimeFilter<"Package"> | Date | string
    services?: PackageServiceListRelationFilter
    bookings?: BookingListRelationFilter
    promotions?: PackagePromotionListRelationFilter
  }, "id" | "slug">

  export type PackageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    originalPrice?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    variant?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PackageCountOrderByAggregateInput
    _avg?: PackageAvgOrderByAggregateInput
    _max?: PackageMaxOrderByAggregateInput
    _min?: PackageMinOrderByAggregateInput
    _sum?: PackageSumOrderByAggregateInput
  }

  export type PackageScalarWhereWithAggregatesInput = {
    AND?: PackageScalarWhereWithAggregatesInput | PackageScalarWhereWithAggregatesInput[]
    OR?: PackageScalarWhereWithAggregatesInput[]
    NOT?: PackageScalarWhereWithAggregatesInput | PackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Package"> | string
    name?: StringWithAggregatesFilter<"Package"> | string
    slug?: StringWithAggregatesFilter<"Package"> | string
    description?: StringNullableWithAggregatesFilter<"Package"> | string | null
    price?: DecimalWithAggregatesFilter<"Package"> | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalNullableWithAggregatesFilter<"Package"> | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalNullableWithAggregatesFilter<"Package"> | Decimal | DecimalJsLike | number | string | null
    variant?: StringNullableWithAggregatesFilter<"Package"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Package"> | string | null
    displayOrder?: IntWithAggregatesFilter<"Package"> | number
    isActive?: BoolWithAggregatesFilter<"Package"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Package"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Package"> | Date | string
  }

  export type PackageServiceWhereInput = {
    AND?: PackageServiceWhereInput | PackageServiceWhereInput[]
    OR?: PackageServiceWhereInput[]
    NOT?: PackageServiceWhereInput | PackageServiceWhereInput[]
    id?: StringFilter<"PackageService"> | string
    packageId?: StringFilter<"PackageService"> | string
    serviceId?: StringFilter<"PackageService"> | string
    quantity?: IntFilter<"PackageService"> | number
    isOptional?: BoolFilter<"PackageService"> | boolean
    extraCost?: DecimalNullableFilter<"PackageService"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PackageService"> | Date | string
    package?: XOR<PackageRelationFilter, PackageWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }

  export type PackageServiceOrderByWithRelationInput = {
    id?: SortOrder
    packageId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    isOptional?: SortOrder
    extraCost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    package?: PackageOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type PackageServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PackageServiceWhereInput | PackageServiceWhereInput[]
    OR?: PackageServiceWhereInput[]
    NOT?: PackageServiceWhereInput | PackageServiceWhereInput[]
    packageId?: StringFilter<"PackageService"> | string
    serviceId?: StringFilter<"PackageService"> | string
    quantity?: IntFilter<"PackageService"> | number
    isOptional?: BoolFilter<"PackageService"> | boolean
    extraCost?: DecimalNullableFilter<"PackageService"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PackageService"> | Date | string
    package?: XOR<PackageRelationFilter, PackageWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }, "id">

  export type PackageServiceOrderByWithAggregationInput = {
    id?: SortOrder
    packageId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    isOptional?: SortOrder
    extraCost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PackageServiceCountOrderByAggregateInput
    _avg?: PackageServiceAvgOrderByAggregateInput
    _max?: PackageServiceMaxOrderByAggregateInput
    _min?: PackageServiceMinOrderByAggregateInput
    _sum?: PackageServiceSumOrderByAggregateInput
  }

  export type PackageServiceScalarWhereWithAggregatesInput = {
    AND?: PackageServiceScalarWhereWithAggregatesInput | PackageServiceScalarWhereWithAggregatesInput[]
    OR?: PackageServiceScalarWhereWithAggregatesInput[]
    NOT?: PackageServiceScalarWhereWithAggregatesInput | PackageServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PackageService"> | string
    packageId?: StringWithAggregatesFilter<"PackageService"> | string
    serviceId?: StringWithAggregatesFilter<"PackageService"> | string
    quantity?: IntWithAggregatesFilter<"PackageService"> | number
    isOptional?: BoolWithAggregatesFilter<"PackageService"> | boolean
    extraCost?: DecimalNullableWithAggregatesFilter<"PackageService"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PackageService"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    stripePaymentId?: StringNullableFilter<"Payment"> | string | null
    stripeCustomerId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    receiptUrl?: StringNullableFilter<"Payment"> | string | null
    receiptPdfUrl?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingNullableRelationFilter, BookingWhereInput> | null
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
    giftCard?: XOR<GiftCardNullableRelationFilter, GiftCardWhereInput> | null
    gymSubscription?: XOR<GymSubscriptionNullableRelationFilter, GymSubscriptionWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    stripePaymentId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    receiptPdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    giftCard?: GiftCardOrderByWithRelationInput
    gymSubscription?: GymSubscriptionOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripePaymentId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    stripeCustomerId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    receiptUrl?: StringNullableFilter<"Payment"> | string | null
    receiptPdfUrl?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingNullableRelationFilter, BookingWhereInput> | null
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
    giftCard?: XOR<GiftCardNullableRelationFilter, GiftCardWhereInput> | null
    gymSubscription?: XOR<GymSubscriptionNullableRelationFilter, GymSubscriptionWhereInput> | null
  }, "id" | "stripePaymentId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    stripePaymentId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    receiptPdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    stripePaymentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    receiptUrl?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    receiptPdfUrl?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    bookingNumber?: StringFilter<"Booking"> | string
    type?: EnumBookingTypeFilter<"Booking"> | $Enums.BookingType
    serviceId?: StringNullableFilter<"Booking"> | string | null
    packageId?: StringNullableFilter<"Booking"> | string | null
    clientEmail?: StringFilter<"Booking"> | string
    clientName?: StringFilter<"Booking"> | string
    clientPhone?: StringFilter<"Booking"> | string
    specialNotes?: StringNullableFilter<"Booking"> | string | null
    bookingDate?: DateTimeFilter<"Booking"> | Date | string
    startTime?: StringFilter<"Booking"> | string
    endTime?: StringFilter<"Booking"> | string
    professionalId?: StringNullableFilter<"Booking"> | string | null
    subtotal?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    giftCardId?: StringNullableFilter<"Booking"> | string | null
    giftCardAmount?: DecimalNullableFilter<"Booking"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    paymentId?: StringFilter<"Booking"> | string
    reminderSent?: BoolFilter<"Booking"> | boolean
    googleCalendarEventId?: StringNullableFilter<"Booking"> | string | null
    createdById?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
    package?: XOR<PackageNullableRelationFilter, PackageWhereInput> | null
    professional?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    giftCard?: XOR<GiftCardNullableRelationFilter, GiftCardWhereInput> | null
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    statusHistory?: BookingStatusHistoryListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    bookingNumber?: SortOrder
    type?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    packageId?: SortOrderInput | SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    specialNotes?: SortOrderInput | SortOrder
    bookingDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    professionalId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxTPS?: SortOrder
    taxTVQ?: SortOrder
    total?: SortOrder
    giftCardId?: SortOrderInput | SortOrder
    giftCardAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    reminderSent?: SortOrder
    googleCalendarEventId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
    package?: PackageOrderByWithRelationInput
    professional?: UserOrderByWithRelationInput
    giftCard?: GiftCardOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    statusHistory?: BookingStatusHistoryOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingNumber?: string
    paymentId?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    type?: EnumBookingTypeFilter<"Booking"> | $Enums.BookingType
    serviceId?: StringNullableFilter<"Booking"> | string | null
    packageId?: StringNullableFilter<"Booking"> | string | null
    clientEmail?: StringFilter<"Booking"> | string
    clientName?: StringFilter<"Booking"> | string
    clientPhone?: StringFilter<"Booking"> | string
    specialNotes?: StringNullableFilter<"Booking"> | string | null
    bookingDate?: DateTimeFilter<"Booking"> | Date | string
    startTime?: StringFilter<"Booking"> | string
    endTime?: StringFilter<"Booking"> | string
    professionalId?: StringNullableFilter<"Booking"> | string | null
    subtotal?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    giftCardId?: StringNullableFilter<"Booking"> | string | null
    giftCardAmount?: DecimalNullableFilter<"Booking"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    reminderSent?: BoolFilter<"Booking"> | boolean
    googleCalendarEventId?: StringNullableFilter<"Booking"> | string | null
    createdById?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
    package?: XOR<PackageNullableRelationFilter, PackageWhereInput> | null
    professional?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    giftCard?: XOR<GiftCardNullableRelationFilter, GiftCardWhereInput> | null
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    statusHistory?: BookingStatusHistoryListRelationFilter
  }, "id" | "bookingNumber" | "paymentId">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    bookingNumber?: SortOrder
    type?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    packageId?: SortOrderInput | SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    specialNotes?: SortOrderInput | SortOrder
    bookingDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    professionalId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxTPS?: SortOrder
    taxTVQ?: SortOrder
    total?: SortOrder
    giftCardId?: SortOrderInput | SortOrder
    giftCardAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    reminderSent?: SortOrder
    googleCalendarEventId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    bookingNumber?: StringWithAggregatesFilter<"Booking"> | string
    type?: EnumBookingTypeWithAggregatesFilter<"Booking"> | $Enums.BookingType
    serviceId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    packageId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    clientEmail?: StringWithAggregatesFilter<"Booking"> | string
    clientName?: StringWithAggregatesFilter<"Booking"> | string
    clientPhone?: StringWithAggregatesFilter<"Booking"> | string
    specialNotes?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    bookingDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    startTime?: StringWithAggregatesFilter<"Booking"> | string
    endTime?: StringWithAggregatesFilter<"Booking"> | string
    professionalId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalWithAggregatesFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalWithAggregatesFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    giftCardId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    giftCardAmount?: DecimalNullableWithAggregatesFilter<"Booking"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    paymentId?: StringWithAggregatesFilter<"Booking"> | string
    reminderSent?: BoolWithAggregatesFilter<"Booking"> | boolean
    googleCalendarEventId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type AvailabilityWhereInput = {
    AND?: AvailabilityWhereInput | AvailabilityWhereInput[]
    OR?: AvailabilityWhereInput[]
    NOT?: AvailabilityWhereInput | AvailabilityWhereInput[]
    id?: StringFilter<"Availability"> | string
    professionalId?: StringFilter<"Availability"> | string
    date?: DateTimeFilter<"Availability"> | Date | string
    startTime?: StringNullableFilter<"Availability"> | string | null
    endTime?: StringNullableFilter<"Availability"> | string | null
    isAvailable?: BoolFilter<"Availability"> | boolean
    reason?: StringNullableFilter<"Availability"> | string | null
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
    professional?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AvailabilityOrderByWithRelationInput = {
    id?: SortOrder
    professionalId?: SortOrder
    date?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    professional?: UserOrderByWithRelationInput
  }

  export type AvailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    professionalId_date?: AvailabilityProfessionalIdDateCompoundUniqueInput
    AND?: AvailabilityWhereInput | AvailabilityWhereInput[]
    OR?: AvailabilityWhereInput[]
    NOT?: AvailabilityWhereInput | AvailabilityWhereInput[]
    professionalId?: StringFilter<"Availability"> | string
    date?: DateTimeFilter<"Availability"> | Date | string
    startTime?: StringNullableFilter<"Availability"> | string | null
    endTime?: StringNullableFilter<"Availability"> | string | null
    isAvailable?: BoolFilter<"Availability"> | boolean
    reason?: StringNullableFilter<"Availability"> | string | null
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
    professional?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "professionalId_date">

  export type AvailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    professionalId?: SortOrder
    date?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AvailabilityCountOrderByAggregateInput
    _max?: AvailabilityMaxOrderByAggregateInput
    _min?: AvailabilityMinOrderByAggregateInput
  }

  export type AvailabilityScalarWhereWithAggregatesInput = {
    AND?: AvailabilityScalarWhereWithAggregatesInput | AvailabilityScalarWhereWithAggregatesInput[]
    OR?: AvailabilityScalarWhereWithAggregatesInput[]
    NOT?: AvailabilityScalarWhereWithAggregatesInput | AvailabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Availability"> | string
    professionalId?: StringWithAggregatesFilter<"Availability"> | string
    date?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
    startTime?: StringNullableWithAggregatesFilter<"Availability"> | string | null
    endTime?: StringNullableWithAggregatesFilter<"Availability"> | string | null
    isAvailable?: BoolWithAggregatesFilter<"Availability"> | boolean
    reason?: StringNullableWithAggregatesFilter<"Availability"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
  }

  export type GiftCardWhereInput = {
    AND?: GiftCardWhereInput | GiftCardWhereInput[]
    OR?: GiftCardWhereInput[]
    NOT?: GiftCardWhereInput | GiftCardWhereInput[]
    id?: StringFilter<"GiftCard"> | string
    code?: StringFilter<"GiftCard"> | string
    amount?: DecimalFilter<"GiftCard"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalFilter<"GiftCard"> | Decimal | DecimalJsLike | number | string
    purchasedBy?: StringNullableFilter<"GiftCard"> | string | null
    recipientName?: StringNullableFilter<"GiftCard"> | string | null
    recipientEmail?: StringNullableFilter<"GiftCard"> | string | null
    message?: StringNullableFilter<"GiftCard"> | string | null
    isActive?: BoolFilter<"GiftCard"> | boolean
    expiresAt?: DateTimeNullableFilter<"GiftCard"> | Date | string | null
    paymentId?: StringFilter<"GiftCard"> | string
    createdAt?: DateTimeFilter<"GiftCard"> | Date | string
    updatedAt?: DateTimeFilter<"GiftCard"> | Date | string
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
    usedInBookings?: BookingListRelationFilter
  }

  export type GiftCardOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    purchasedBy?: SortOrderInput | SortOrder
    recipientName?: SortOrderInput | SortOrder
    recipientEmail?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payment?: PaymentOrderByWithRelationInput
    usedInBookings?: BookingOrderByRelationAggregateInput
  }

  export type GiftCardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    paymentId?: string
    AND?: GiftCardWhereInput | GiftCardWhereInput[]
    OR?: GiftCardWhereInput[]
    NOT?: GiftCardWhereInput | GiftCardWhereInput[]
    amount?: DecimalFilter<"GiftCard"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalFilter<"GiftCard"> | Decimal | DecimalJsLike | number | string
    purchasedBy?: StringNullableFilter<"GiftCard"> | string | null
    recipientName?: StringNullableFilter<"GiftCard"> | string | null
    recipientEmail?: StringNullableFilter<"GiftCard"> | string | null
    message?: StringNullableFilter<"GiftCard"> | string | null
    isActive?: BoolFilter<"GiftCard"> | boolean
    expiresAt?: DateTimeNullableFilter<"GiftCard"> | Date | string | null
    createdAt?: DateTimeFilter<"GiftCard"> | Date | string
    updatedAt?: DateTimeFilter<"GiftCard"> | Date | string
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
    usedInBookings?: BookingListRelationFilter
  }, "id" | "code" | "paymentId">

  export type GiftCardOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    purchasedBy?: SortOrderInput | SortOrder
    recipientName?: SortOrderInput | SortOrder
    recipientEmail?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GiftCardCountOrderByAggregateInput
    _avg?: GiftCardAvgOrderByAggregateInput
    _max?: GiftCardMaxOrderByAggregateInput
    _min?: GiftCardMinOrderByAggregateInput
    _sum?: GiftCardSumOrderByAggregateInput
  }

  export type GiftCardScalarWhereWithAggregatesInput = {
    AND?: GiftCardScalarWhereWithAggregatesInput | GiftCardScalarWhereWithAggregatesInput[]
    OR?: GiftCardScalarWhereWithAggregatesInput[]
    NOT?: GiftCardScalarWhereWithAggregatesInput | GiftCardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GiftCard"> | string
    code?: StringWithAggregatesFilter<"GiftCard"> | string
    amount?: DecimalWithAggregatesFilter<"GiftCard"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalWithAggregatesFilter<"GiftCard"> | Decimal | DecimalJsLike | number | string
    purchasedBy?: StringNullableWithAggregatesFilter<"GiftCard"> | string | null
    recipientName?: StringNullableWithAggregatesFilter<"GiftCard"> | string | null
    recipientEmail?: StringNullableWithAggregatesFilter<"GiftCard"> | string | null
    message?: StringNullableWithAggregatesFilter<"GiftCard"> | string | null
    isActive?: BoolWithAggregatesFilter<"GiftCard"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"GiftCard"> | Date | string | null
    paymentId?: StringWithAggregatesFilter<"GiftCard"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GiftCard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GiftCard"> | Date | string
  }

  export type GymMembershipWhereInput = {
    AND?: GymMembershipWhereInput | GymMembershipWhereInput[]
    OR?: GymMembershipWhereInput[]
    NOT?: GymMembershipWhereInput | GymMembershipWhereInput[]
    id?: StringFilter<"GymMembership"> | string
    type?: StringFilter<"GymMembership"> | string
    name?: StringFilter<"GymMembership"> | string
    price?: DecimalFilter<"GymMembership"> | Decimal | DecimalJsLike | number | string
    duration?: IntFilter<"GymMembership"> | number
    description?: StringNullableFilter<"GymMembership"> | string | null
    displayOrder?: IntFilter<"GymMembership"> | number
    isActive?: BoolFilter<"GymMembership"> | boolean
    createdAt?: DateTimeFilter<"GymMembership"> | Date | string
    updatedAt?: DateTimeFilter<"GymMembership"> | Date | string
    subscriptions?: GymSubscriptionListRelationFilter
  }

  export type GymMembershipOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: GymSubscriptionOrderByRelationAggregateInput
  }

  export type GymMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    type?: string
    AND?: GymMembershipWhereInput | GymMembershipWhereInput[]
    OR?: GymMembershipWhereInput[]
    NOT?: GymMembershipWhereInput | GymMembershipWhereInput[]
    name?: StringFilter<"GymMembership"> | string
    price?: DecimalFilter<"GymMembership"> | Decimal | DecimalJsLike | number | string
    duration?: IntFilter<"GymMembership"> | number
    description?: StringNullableFilter<"GymMembership"> | string | null
    displayOrder?: IntFilter<"GymMembership"> | number
    isActive?: BoolFilter<"GymMembership"> | boolean
    createdAt?: DateTimeFilter<"GymMembership"> | Date | string
    updatedAt?: DateTimeFilter<"GymMembership"> | Date | string
    subscriptions?: GymSubscriptionListRelationFilter
  }, "id" | "type">

  export type GymMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    description?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GymMembershipCountOrderByAggregateInput
    _avg?: GymMembershipAvgOrderByAggregateInput
    _max?: GymMembershipMaxOrderByAggregateInput
    _min?: GymMembershipMinOrderByAggregateInput
    _sum?: GymMembershipSumOrderByAggregateInput
  }

  export type GymMembershipScalarWhereWithAggregatesInput = {
    AND?: GymMembershipScalarWhereWithAggregatesInput | GymMembershipScalarWhereWithAggregatesInput[]
    OR?: GymMembershipScalarWhereWithAggregatesInput[]
    NOT?: GymMembershipScalarWhereWithAggregatesInput | GymMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GymMembership"> | string
    type?: StringWithAggregatesFilter<"GymMembership"> | string
    name?: StringWithAggregatesFilter<"GymMembership"> | string
    price?: DecimalWithAggregatesFilter<"GymMembership"> | Decimal | DecimalJsLike | number | string
    duration?: IntWithAggregatesFilter<"GymMembership"> | number
    description?: StringNullableWithAggregatesFilter<"GymMembership"> | string | null
    displayOrder?: IntWithAggregatesFilter<"GymMembership"> | number
    isActive?: BoolWithAggregatesFilter<"GymMembership"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GymMembership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GymMembership"> | Date | string
  }

  export type GymSubscriptionWhereInput = {
    AND?: GymSubscriptionWhereInput | GymSubscriptionWhereInput[]
    OR?: GymSubscriptionWhereInput[]
    NOT?: GymSubscriptionWhereInput | GymSubscriptionWhereInput[]
    id?: StringFilter<"GymSubscription"> | string
    membershipId?: StringFilter<"GymSubscription"> | string
    clientEmail?: StringFilter<"GymSubscription"> | string
    clientName?: StringFilter<"GymSubscription"> | string
    clientPhone?: StringFilter<"GymSubscription"> | string
    startDate?: DateTimeFilter<"GymSubscription"> | Date | string
    endDate?: DateTimeFilter<"GymSubscription"> | Date | string
    isActive?: BoolFilter<"GymSubscription"> | boolean
    paymentId?: StringFilter<"GymSubscription"> | string
    createdAt?: DateTimeFilter<"GymSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"GymSubscription"> | Date | string
    membership?: XOR<GymMembershipRelationFilter, GymMembershipWhereInput>
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
  }

  export type GymSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    membershipId?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    membership?: GymMembershipOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
  }

  export type GymSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentId?: string
    AND?: GymSubscriptionWhereInput | GymSubscriptionWhereInput[]
    OR?: GymSubscriptionWhereInput[]
    NOT?: GymSubscriptionWhereInput | GymSubscriptionWhereInput[]
    membershipId?: StringFilter<"GymSubscription"> | string
    clientEmail?: StringFilter<"GymSubscription"> | string
    clientName?: StringFilter<"GymSubscription"> | string
    clientPhone?: StringFilter<"GymSubscription"> | string
    startDate?: DateTimeFilter<"GymSubscription"> | Date | string
    endDate?: DateTimeFilter<"GymSubscription"> | Date | string
    isActive?: BoolFilter<"GymSubscription"> | boolean
    createdAt?: DateTimeFilter<"GymSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"GymSubscription"> | Date | string
    membership?: XOR<GymMembershipRelationFilter, GymMembershipWhereInput>
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
  }, "id" | "paymentId">

  export type GymSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    membershipId?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GymSubscriptionCountOrderByAggregateInput
    _max?: GymSubscriptionMaxOrderByAggregateInput
    _min?: GymSubscriptionMinOrderByAggregateInput
  }

  export type GymSubscriptionScalarWhereWithAggregatesInput = {
    AND?: GymSubscriptionScalarWhereWithAggregatesInput | GymSubscriptionScalarWhereWithAggregatesInput[]
    OR?: GymSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: GymSubscriptionScalarWhereWithAggregatesInput | GymSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GymSubscription"> | string
    membershipId?: StringWithAggregatesFilter<"GymSubscription"> | string
    clientEmail?: StringWithAggregatesFilter<"GymSubscription"> | string
    clientName?: StringWithAggregatesFilter<"GymSubscription"> | string
    clientPhone?: StringWithAggregatesFilter<"GymSubscription"> | string
    startDate?: DateTimeWithAggregatesFilter<"GymSubscription"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"GymSubscription"> | Date | string
    isActive?: BoolWithAggregatesFilter<"GymSubscription"> | boolean
    paymentId?: StringWithAggregatesFilter<"GymSubscription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GymSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GymSubscription"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    stock?: IntFilter<"Product"> | number
    category?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    displayOrder?: IntFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    orderItems?: OrderItemListRelationFilter
    promotions?: ProductPromotionListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    promotions?: ProductPromotionOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    stock?: IntFilter<"Product"> | number
    category?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    displayOrder?: IntFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    orderItems?: OrderItemListRelationFilter
    promotions?: ProductPromotionListRelationFilter
  }, "id" | "slug">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    slug?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    stock?: IntWithAggregatesFilter<"Product"> | number
    category?: StringNullableWithAggregatesFilter<"Product"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    displayOrder?: IntWithAggregatesFilter<"Product"> | number
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    clientEmail?: StringFilter<"Order"> | string
    clientName?: StringFilter<"Order"> | string
    clientPhone?: StringFilter<"Order"> | string
    shippingAddress?: StringNullableFilter<"Order"> | string | null
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    paymentId?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
    items?: OrderItemListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxTPS?: SortOrder
    taxTVQ?: SortOrder
    total?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payment?: PaymentOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    paymentId?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    clientEmail?: StringFilter<"Order"> | string
    clientName?: StringFilter<"Order"> | string
    clientPhone?: StringFilter<"Order"> | string
    shippingAddress?: StringNullableFilter<"Order"> | string | null
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
    items?: OrderItemListRelationFilter
  }, "id" | "orderNumber" | "paymentId">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxTPS?: SortOrder
    taxTVQ?: SortOrder
    total?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    clientEmail?: StringWithAggregatesFilter<"Order"> | string
    clientName?: StringWithAggregatesFilter<"Order"> | string
    clientPhone?: StringWithAggregatesFilter<"Order"> | string
    shippingAddress?: StringNullableWithAggregatesFilter<"Order"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    paymentId?: StringWithAggregatesFilter<"Order"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    price?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: StringFilter<"Promotion"> | string
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    code?: StringNullableFilter<"Promotion"> | string | null
    discountType?: EnumDiscountTypeFilter<"Promotion"> | $Enums.DiscountType
    discountValue?: DecimalFilter<"Promotion"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    isActive?: BoolFilter<"Promotion"> | boolean
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    services?: ServicePromotionListRelationFilter
    packages?: PackagePromotionListRelationFilter
    products?: ProductPromotionListRelationFilter
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    services?: ServicePromotionOrderByRelationAggregateInput
    packages?: PackagePromotionOrderByRelationAggregateInput
    products?: ProductPromotionOrderByRelationAggregateInput
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    discountType?: EnumDiscountTypeFilter<"Promotion"> | $Enums.DiscountType
    discountValue?: DecimalFilter<"Promotion"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    isActive?: BoolFilter<"Promotion"> | boolean
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    services?: ServicePromotionListRelationFilter
    packages?: PackagePromotionListRelationFilter
    products?: ProductPromotionListRelationFilter
  }, "id" | "code">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _avg?: PromotionAvgOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
    _sum?: PromotionSumOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Promotion"> | string
    name?: StringWithAggregatesFilter<"Promotion"> | string
    description?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    code?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    discountType?: EnumDiscountTypeWithAggregatesFilter<"Promotion"> | $Enums.DiscountType
    discountValue?: DecimalWithAggregatesFilter<"Promotion"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Promotion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
  }

  export type ServicePromotionWhereInput = {
    AND?: ServicePromotionWhereInput | ServicePromotionWhereInput[]
    OR?: ServicePromotionWhereInput[]
    NOT?: ServicePromotionWhereInput | ServicePromotionWhereInput[]
    id?: StringFilter<"ServicePromotion"> | string
    promotionId?: StringFilter<"ServicePromotion"> | string
    serviceId?: StringFilter<"ServicePromotion"> | string
    createdAt?: DateTimeFilter<"ServicePromotion"> | Date | string
    promotion?: XOR<PromotionRelationFilter, PromotionWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }

  export type ServicePromotionOrderByWithRelationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    promotion?: PromotionOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type ServicePromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    promotionId_serviceId?: ServicePromotionPromotionIdServiceIdCompoundUniqueInput
    AND?: ServicePromotionWhereInput | ServicePromotionWhereInput[]
    OR?: ServicePromotionWhereInput[]
    NOT?: ServicePromotionWhereInput | ServicePromotionWhereInput[]
    promotionId?: StringFilter<"ServicePromotion"> | string
    serviceId?: StringFilter<"ServicePromotion"> | string
    createdAt?: DateTimeFilter<"ServicePromotion"> | Date | string
    promotion?: XOR<PromotionRelationFilter, PromotionWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }, "id" | "promotionId_serviceId">

  export type ServicePromotionOrderByWithAggregationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    _count?: ServicePromotionCountOrderByAggregateInput
    _max?: ServicePromotionMaxOrderByAggregateInput
    _min?: ServicePromotionMinOrderByAggregateInput
  }

  export type ServicePromotionScalarWhereWithAggregatesInput = {
    AND?: ServicePromotionScalarWhereWithAggregatesInput | ServicePromotionScalarWhereWithAggregatesInput[]
    OR?: ServicePromotionScalarWhereWithAggregatesInput[]
    NOT?: ServicePromotionScalarWhereWithAggregatesInput | ServicePromotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServicePromotion"> | string
    promotionId?: StringWithAggregatesFilter<"ServicePromotion"> | string
    serviceId?: StringWithAggregatesFilter<"ServicePromotion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ServicePromotion"> | Date | string
  }

  export type PackagePromotionWhereInput = {
    AND?: PackagePromotionWhereInput | PackagePromotionWhereInput[]
    OR?: PackagePromotionWhereInput[]
    NOT?: PackagePromotionWhereInput | PackagePromotionWhereInput[]
    id?: StringFilter<"PackagePromotion"> | string
    promotionId?: StringFilter<"PackagePromotion"> | string
    packageId?: StringFilter<"PackagePromotion"> | string
    createdAt?: DateTimeFilter<"PackagePromotion"> | Date | string
    promotion?: XOR<PromotionRelationFilter, PromotionWhereInput>
    package?: XOR<PackageRelationFilter, PackageWhereInput>
  }

  export type PackagePromotionOrderByWithRelationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    packageId?: SortOrder
    createdAt?: SortOrder
    promotion?: PromotionOrderByWithRelationInput
    package?: PackageOrderByWithRelationInput
  }

  export type PackagePromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    promotionId_packageId?: PackagePromotionPromotionIdPackageIdCompoundUniqueInput
    AND?: PackagePromotionWhereInput | PackagePromotionWhereInput[]
    OR?: PackagePromotionWhereInput[]
    NOT?: PackagePromotionWhereInput | PackagePromotionWhereInput[]
    promotionId?: StringFilter<"PackagePromotion"> | string
    packageId?: StringFilter<"PackagePromotion"> | string
    createdAt?: DateTimeFilter<"PackagePromotion"> | Date | string
    promotion?: XOR<PromotionRelationFilter, PromotionWhereInput>
    package?: XOR<PackageRelationFilter, PackageWhereInput>
  }, "id" | "promotionId_packageId">

  export type PackagePromotionOrderByWithAggregationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    packageId?: SortOrder
    createdAt?: SortOrder
    _count?: PackagePromotionCountOrderByAggregateInput
    _max?: PackagePromotionMaxOrderByAggregateInput
    _min?: PackagePromotionMinOrderByAggregateInput
  }

  export type PackagePromotionScalarWhereWithAggregatesInput = {
    AND?: PackagePromotionScalarWhereWithAggregatesInput | PackagePromotionScalarWhereWithAggregatesInput[]
    OR?: PackagePromotionScalarWhereWithAggregatesInput[]
    NOT?: PackagePromotionScalarWhereWithAggregatesInput | PackagePromotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PackagePromotion"> | string
    promotionId?: StringWithAggregatesFilter<"PackagePromotion"> | string
    packageId?: StringWithAggregatesFilter<"PackagePromotion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PackagePromotion"> | Date | string
  }

  export type ProductPromotionWhereInput = {
    AND?: ProductPromotionWhereInput | ProductPromotionWhereInput[]
    OR?: ProductPromotionWhereInput[]
    NOT?: ProductPromotionWhereInput | ProductPromotionWhereInput[]
    id?: StringFilter<"ProductPromotion"> | string
    promotionId?: StringFilter<"ProductPromotion"> | string
    productId?: StringFilter<"ProductPromotion"> | string
    createdAt?: DateTimeFilter<"ProductPromotion"> | Date | string
    promotion?: XOR<PromotionRelationFilter, PromotionWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type ProductPromotionOrderByWithRelationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    promotion?: PromotionOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ProductPromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    promotionId_productId?: ProductPromotionPromotionIdProductIdCompoundUniqueInput
    AND?: ProductPromotionWhereInput | ProductPromotionWhereInput[]
    OR?: ProductPromotionWhereInput[]
    NOT?: ProductPromotionWhereInput | ProductPromotionWhereInput[]
    promotionId?: StringFilter<"ProductPromotion"> | string
    productId?: StringFilter<"ProductPromotion"> | string
    createdAt?: DateTimeFilter<"ProductPromotion"> | Date | string
    promotion?: XOR<PromotionRelationFilter, PromotionWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id" | "promotionId_productId">

  export type ProductPromotionOrderByWithAggregationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    _count?: ProductPromotionCountOrderByAggregateInput
    _max?: ProductPromotionMaxOrderByAggregateInput
    _min?: ProductPromotionMinOrderByAggregateInput
  }

  export type ProductPromotionScalarWhereWithAggregatesInput = {
    AND?: ProductPromotionScalarWhereWithAggregatesInput | ProductPromotionScalarWhereWithAggregatesInput[]
    OR?: ProductPromotionScalarWhereWithAggregatesInput[]
    NOT?: ProductPromotionScalarWhereWithAggregatesInput | ProductPromotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductPromotion"> | string
    promotionId?: StringWithAggregatesFilter<"ProductPromotion"> | string
    productId?: StringWithAggregatesFilter<"ProductPromotion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductPromotion"> | Date | string
  }

  export type BookingStatusHistoryWhereInput = {
    AND?: BookingStatusHistoryWhereInput | BookingStatusHistoryWhereInput[]
    OR?: BookingStatusHistoryWhereInput[]
    NOT?: BookingStatusHistoryWhereInput | BookingStatusHistoryWhereInput[]
    id?: StringFilter<"BookingStatusHistory"> | string
    bookingId?: StringFilter<"BookingStatusHistory"> | string
    oldStatus?: EnumBookingStatusNullableFilter<"BookingStatusHistory"> | $Enums.BookingStatus | null
    newStatus?: EnumBookingStatusFilter<"BookingStatusHistory"> | $Enums.BookingStatus
    changedById?: StringFilter<"BookingStatusHistory"> | string
    changedBy?: StringFilter<"BookingStatusHistory"> | string
    changedByRole?: StringFilter<"BookingStatusHistory"> | string
    reason?: StringNullableFilter<"BookingStatusHistory"> | string | null
    notes?: StringNullableFilter<"BookingStatusHistory"> | string | null
    oldDate?: DateTimeNullableFilter<"BookingStatusHistory"> | Date | string | null
    newDate?: DateTimeNullableFilter<"BookingStatusHistory"> | Date | string | null
    oldStartTime?: StringNullableFilter<"BookingStatusHistory"> | string | null
    newStartTime?: StringNullableFilter<"BookingStatusHistory"> | string | null
    oldEndTime?: StringNullableFilter<"BookingStatusHistory"> | string | null
    newEndTime?: StringNullableFilter<"BookingStatusHistory"> | string | null
    oldProfessionalId?: StringNullableFilter<"BookingStatusHistory"> | string | null
    newProfessionalId?: StringNullableFilter<"BookingStatusHistory"> | string | null
    changedAt?: DateTimeFilter<"BookingStatusHistory"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }

  export type BookingStatusHistoryOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    oldStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    changedById?: SortOrder
    changedBy?: SortOrder
    changedByRole?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    oldDate?: SortOrderInput | SortOrder
    newDate?: SortOrderInput | SortOrder
    oldStartTime?: SortOrderInput | SortOrder
    newStartTime?: SortOrderInput | SortOrder
    oldEndTime?: SortOrderInput | SortOrder
    newEndTime?: SortOrderInput | SortOrder
    oldProfessionalId?: SortOrderInput | SortOrder
    newProfessionalId?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type BookingStatusHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingStatusHistoryWhereInput | BookingStatusHistoryWhereInput[]
    OR?: BookingStatusHistoryWhereInput[]
    NOT?: BookingStatusHistoryWhereInput | BookingStatusHistoryWhereInput[]
    bookingId?: StringFilter<"BookingStatusHistory"> | string
    oldStatus?: EnumBookingStatusNullableFilter<"BookingStatusHistory"> | $Enums.BookingStatus | null
    newStatus?: EnumBookingStatusFilter<"BookingStatusHistory"> | $Enums.BookingStatus
    changedById?: StringFilter<"BookingStatusHistory"> | string
    changedBy?: StringFilter<"BookingStatusHistory"> | string
    changedByRole?: StringFilter<"BookingStatusHistory"> | string
    reason?: StringNullableFilter<"BookingStatusHistory"> | string | null
    notes?: StringNullableFilter<"BookingStatusHistory"> | string | null
    oldDate?: DateTimeNullableFilter<"BookingStatusHistory"> | Date | string | null
    newDate?: DateTimeNullableFilter<"BookingStatusHistory"> | Date | string | null
    oldStartTime?: StringNullableFilter<"BookingStatusHistory"> | string | null
    newStartTime?: StringNullableFilter<"BookingStatusHistory"> | string | null
    oldEndTime?: StringNullableFilter<"BookingStatusHistory"> | string | null
    newEndTime?: StringNullableFilter<"BookingStatusHistory"> | string | null
    oldProfessionalId?: StringNullableFilter<"BookingStatusHistory"> | string | null
    newProfessionalId?: StringNullableFilter<"BookingStatusHistory"> | string | null
    changedAt?: DateTimeFilter<"BookingStatusHistory"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }, "id">

  export type BookingStatusHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    oldStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    changedById?: SortOrder
    changedBy?: SortOrder
    changedByRole?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    oldDate?: SortOrderInput | SortOrder
    newDate?: SortOrderInput | SortOrder
    oldStartTime?: SortOrderInput | SortOrder
    newStartTime?: SortOrderInput | SortOrder
    oldEndTime?: SortOrderInput | SortOrder
    newEndTime?: SortOrderInput | SortOrder
    oldProfessionalId?: SortOrderInput | SortOrder
    newProfessionalId?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    _count?: BookingStatusHistoryCountOrderByAggregateInput
    _max?: BookingStatusHistoryMaxOrderByAggregateInput
    _min?: BookingStatusHistoryMinOrderByAggregateInput
  }

  export type BookingStatusHistoryScalarWhereWithAggregatesInput = {
    AND?: BookingStatusHistoryScalarWhereWithAggregatesInput | BookingStatusHistoryScalarWhereWithAggregatesInput[]
    OR?: BookingStatusHistoryScalarWhereWithAggregatesInput[]
    NOT?: BookingStatusHistoryScalarWhereWithAggregatesInput | BookingStatusHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingStatusHistory"> | string
    bookingId?: StringWithAggregatesFilter<"BookingStatusHistory"> | string
    oldStatus?: EnumBookingStatusNullableWithAggregatesFilter<"BookingStatusHistory"> | $Enums.BookingStatus | null
    newStatus?: EnumBookingStatusWithAggregatesFilter<"BookingStatusHistory"> | $Enums.BookingStatus
    changedById?: StringWithAggregatesFilter<"BookingStatusHistory"> | string
    changedBy?: StringWithAggregatesFilter<"BookingStatusHistory"> | string
    changedByRole?: StringWithAggregatesFilter<"BookingStatusHistory"> | string
    reason?: StringNullableWithAggregatesFilter<"BookingStatusHistory"> | string | null
    notes?: StringNullableWithAggregatesFilter<"BookingStatusHistory"> | string | null
    oldDate?: DateTimeNullableWithAggregatesFilter<"BookingStatusHistory"> | Date | string | null
    newDate?: DateTimeNullableWithAggregatesFilter<"BookingStatusHistory"> | Date | string | null
    oldStartTime?: StringNullableWithAggregatesFilter<"BookingStatusHistory"> | string | null
    newStartTime?: StringNullableWithAggregatesFilter<"BookingStatusHistory"> | string | null
    oldEndTime?: StringNullableWithAggregatesFilter<"BookingStatusHistory"> | string | null
    newEndTime?: StringNullableWithAggregatesFilter<"BookingStatusHistory"> | string | null
    oldProfessionalId?: StringNullableWithAggregatesFilter<"BookingStatusHistory"> | string | null
    newProfessionalId?: StringNullableWithAggregatesFilter<"BookingStatusHistory"> | string | null
    changedAt?: DateTimeWithAggregatesFilter<"BookingStatusHistory"> | Date | string
  }

  export type WorkingScheduleWhereInput = {
    AND?: WorkingScheduleWhereInput | WorkingScheduleWhereInput[]
    OR?: WorkingScheduleWhereInput[]
    NOT?: WorkingScheduleWhereInput | WorkingScheduleWhereInput[]
    id?: StringFilter<"WorkingSchedule"> | string
    professionalId?: StringFilter<"WorkingSchedule"> | string
    dayOfWeek?: IntFilter<"WorkingSchedule"> | number
    startTime?: StringFilter<"WorkingSchedule"> | string
    endTime?: StringFilter<"WorkingSchedule"> | string
    isActive?: BoolFilter<"WorkingSchedule"> | boolean
    createdAt?: DateTimeFilter<"WorkingSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"WorkingSchedule"> | Date | string
    professional?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WorkingScheduleOrderByWithRelationInput = {
    id?: SortOrder
    professionalId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    professional?: UserOrderByWithRelationInput
  }

  export type WorkingScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    professionalId_dayOfWeek?: WorkingScheduleProfessionalIdDayOfWeekCompoundUniqueInput
    AND?: WorkingScheduleWhereInput | WorkingScheduleWhereInput[]
    OR?: WorkingScheduleWhereInput[]
    NOT?: WorkingScheduleWhereInput | WorkingScheduleWhereInput[]
    professionalId?: StringFilter<"WorkingSchedule"> | string
    dayOfWeek?: IntFilter<"WorkingSchedule"> | number
    startTime?: StringFilter<"WorkingSchedule"> | string
    endTime?: StringFilter<"WorkingSchedule"> | string
    isActive?: BoolFilter<"WorkingSchedule"> | boolean
    createdAt?: DateTimeFilter<"WorkingSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"WorkingSchedule"> | Date | string
    professional?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "professionalId_dayOfWeek">

  export type WorkingScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    professionalId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkingScheduleCountOrderByAggregateInput
    _avg?: WorkingScheduleAvgOrderByAggregateInput
    _max?: WorkingScheduleMaxOrderByAggregateInput
    _min?: WorkingScheduleMinOrderByAggregateInput
    _sum?: WorkingScheduleSumOrderByAggregateInput
  }

  export type WorkingScheduleScalarWhereWithAggregatesInput = {
    AND?: WorkingScheduleScalarWhereWithAggregatesInput | WorkingScheduleScalarWhereWithAggregatesInput[]
    OR?: WorkingScheduleScalarWhereWithAggregatesInput[]
    NOT?: WorkingScheduleScalarWhereWithAggregatesInput | WorkingScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkingSchedule"> | string
    professionalId?: StringWithAggregatesFilter<"WorkingSchedule"> | string
    dayOfWeek?: IntWithAggregatesFilter<"WorkingSchedule"> | number
    startTime?: StringWithAggregatesFilter<"WorkingSchedule"> | string
    endTime?: StringWithAggregatesFilter<"WorkingSchedule"> | string
    isActive?: BoolWithAggregatesFilter<"WorkingSchedule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WorkingSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkingSchedule"> | Date | string
  }

  export type BreakPeriodWhereInput = {
    AND?: BreakPeriodWhereInput | BreakPeriodWhereInput[]
    OR?: BreakPeriodWhereInput[]
    NOT?: BreakPeriodWhereInput | BreakPeriodWhereInput[]
    id?: StringFilter<"BreakPeriod"> | string
    professionalId?: StringFilter<"BreakPeriod"> | string
    dayOfWeek?: IntNullableFilter<"BreakPeriod"> | number | null
    startTime?: StringFilter<"BreakPeriod"> | string
    endTime?: StringFilter<"BreakPeriod"> | string
    label?: StringNullableFilter<"BreakPeriod"> | string | null
    isActive?: BoolFilter<"BreakPeriod"> | boolean
    createdAt?: DateTimeFilter<"BreakPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"BreakPeriod"> | Date | string
    professional?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BreakPeriodOrderByWithRelationInput = {
    id?: SortOrder
    professionalId?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    label?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    professional?: UserOrderByWithRelationInput
  }

  export type BreakPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BreakPeriodWhereInput | BreakPeriodWhereInput[]
    OR?: BreakPeriodWhereInput[]
    NOT?: BreakPeriodWhereInput | BreakPeriodWhereInput[]
    professionalId?: StringFilter<"BreakPeriod"> | string
    dayOfWeek?: IntNullableFilter<"BreakPeriod"> | number | null
    startTime?: StringFilter<"BreakPeriod"> | string
    endTime?: StringFilter<"BreakPeriod"> | string
    label?: StringNullableFilter<"BreakPeriod"> | string | null
    isActive?: BoolFilter<"BreakPeriod"> | boolean
    createdAt?: DateTimeFilter<"BreakPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"BreakPeriod"> | Date | string
    professional?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type BreakPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    professionalId?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    label?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BreakPeriodCountOrderByAggregateInput
    _avg?: BreakPeriodAvgOrderByAggregateInput
    _max?: BreakPeriodMaxOrderByAggregateInput
    _min?: BreakPeriodMinOrderByAggregateInput
    _sum?: BreakPeriodSumOrderByAggregateInput
  }

  export type BreakPeriodScalarWhereWithAggregatesInput = {
    AND?: BreakPeriodScalarWhereWithAggregatesInput | BreakPeriodScalarWhereWithAggregatesInput[]
    OR?: BreakPeriodScalarWhereWithAggregatesInput[]
    NOT?: BreakPeriodScalarWhereWithAggregatesInput | BreakPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BreakPeriod"> | string
    professionalId?: StringWithAggregatesFilter<"BreakPeriod"> | string
    dayOfWeek?: IntNullableWithAggregatesFilter<"BreakPeriod"> | number | null
    startTime?: StringWithAggregatesFilter<"BreakPeriod"> | string
    endTime?: StringWithAggregatesFilter<"BreakPeriod"> | string
    label?: StringNullableWithAggregatesFilter<"BreakPeriod"> | string | null
    isActive?: BoolWithAggregatesFilter<"BreakPeriod"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BreakPeriod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BreakPeriod"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    recipientEmail?: StringFilter<"Notification"> | string
    recipientName?: StringNullableFilter<"Notification"> | string | null
    bookingId?: StringNullableFilter<"Notification"> | string | null
    subject?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    sent?: BoolFilter<"Notification"> | boolean
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    error?: StringNullableFilter<"Notification"> | string | null
    scheduledFor?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    subject?: SortOrder
    message?: SortOrder
    sent?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    recipientEmail?: StringFilter<"Notification"> | string
    recipientName?: StringNullableFilter<"Notification"> | string | null
    bookingId?: StringNullableFilter<"Notification"> | string | null
    subject?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    sent?: BoolFilter<"Notification"> | boolean
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    error?: StringNullableFilter<"Notification"> | string | null
    scheduledFor?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    subject?: SortOrder
    message?: SortOrder
    sent?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    recipientEmail?: StringWithAggregatesFilter<"Notification"> | string
    recipientName?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    bookingId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    subject?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    sent?: BoolWithAggregatesFilter<"Notification"> | boolean
    sentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type SystemSettingsWhereInput = {
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    id?: StringFilter<"SystemSettings"> | string
    key?: StringFilter<"SystemSettings"> | string
    value?: StringFilter<"SystemSettings"> | string
    description?: StringNullableFilter<"SystemSettings"> | string | null
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }

  export type SystemSettingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    value?: StringFilter<"SystemSettings"> | string
    description?: StringNullableFilter<"SystemSettings"> | string | null
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }, "id" | "key">

  export type SystemSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingsCountOrderByAggregateInput
    _max?: SystemSettingsMaxOrderByAggregateInput
    _min?: SystemSettingsMinOrderByAggregateInput
  }

  export type SystemSettingsScalarWhereWithAggregatesInput = {
    AND?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    OR?: SystemSettingsScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSettings"> | string
    key?: StringWithAggregatesFilter<"SystemSettings"> | string
    value?: StringWithAggregatesFilter<"SystemSettings"> | string
    description?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteCreateNestedManyWithoutAuthorInput
    assignedClients?: AssignmentCreateNestedManyWithoutProfessionalInput
    reviewsReceived?: ReviewCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingCreateNestedManyWithoutCreatedByInput
    availabilities?: AvailabilityCreateNestedManyWithoutProfessionalInput
    workingSchedules?: WorkingScheduleCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodCreateNestedManyWithoutProfessionalInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedClients?: AssignmentUncheckedCreateNestedManyWithoutProfessionalInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingUncheckedCreateNestedManyWithoutCreatedByInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutProfessionalInput
    workingSchedules?: WorkingScheduleUncheckedCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodUncheckedCreateNestedManyWithoutProfessionalInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUpdateManyWithoutAuthorNestedInput
    assignedClients?: AssignmentUpdateManyWithoutProfessionalNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUpdateManyWithoutCreatedByNestedInput
    availabilities?: AvailabilityUpdateManyWithoutProfessionalNestedInput
    workingSchedules?: WorkingScheduleUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUpdateManyWithoutProfessionalNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedClients?: AssignmentUncheckedUpdateManyWithoutProfessionalNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUncheckedUpdateManyWithoutCreatedByNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutProfessionalNestedInput
    workingSchedules?: WorkingScheduleUncheckedUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUncheckedUpdateManyWithoutProfessionalNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientProfileCreateInput = {
    id?: string
    nom: string
    prenom: string
    adresse: string
    ville: string
    codePostal: string
    telMaison?: string | null
    telBureau?: string | null
    telCellulaire: string
    courriel: string
    dateNaissance: Date | string
    occupation?: string | null
    gender: $Enums.Gender
    serviceType: $Enums.ServiceType
    assuranceCouvert: boolean
    autreMaladie?: boolean | null
    autreMaladieDetails?: string | null
    raisonConsultation?: string | null
    diagnosticMedical?: boolean | null
    diagnosticMedicalDetails?: string | null
    medicaments?: boolean | null
    medicamentsDetails?: string | null
    accidents?: boolean | null
    accidentsDetails?: string | null
    operationsChirurgicales?: boolean | null
    operationsChirurgicalesDetails?: string | null
    traitementsActuels?: string | null
    problemesCardiaques?: boolean
    problemesCardiaquesDetails?: string | null
    maladiesGraves?: boolean
    maladiesGravesDetails?: string | null
    ortheses?: boolean
    orthesesDetails?: string | null
    allergies?: boolean
    allergiesDetails?: string | null
    raideurs?: boolean
    arthrose?: boolean
    hernieDiscale?: boolean
    oedeme?: boolean
    tendinite?: boolean
    mauxDeTete?: boolean
    flatulence?: boolean
    troublesCirculatoires?: boolean
    hypothyroidie?: boolean
    diabete?: boolean
    stresse?: boolean
    premenopause?: boolean
    douleurMusculaire?: boolean
    fibromyalgie?: boolean
    rhumatisme?: boolean
    sciatique?: boolean
    bursite?: boolean
    migraine?: boolean
    diarrhee?: boolean
    phlebite?: boolean
    hypertension?: boolean
    hypoglycemie?: boolean
    burnOut?: boolean
    menopause?: boolean
    inflammationAigue?: boolean
    arteriosclerose?: boolean
    osteoporose?: boolean
    mauxDeDos?: boolean
    fatigueDesJambes?: boolean
    troublesDigestifs?: boolean
    constipation?: boolean
    hyperthyroidie?: boolean
    hypotension?: boolean
    insomnie?: boolean
    depressionNerveuse?: boolean
    autres?: string | null
    lastVisitDate?: Date | string | null
    lastEmailSent?: Date | string | null
    feedbackEmailsSent?: number
    promoEmailsSent?: number
    zonesDouleur?: ClientProfileCreatezonesDouleurInput | string[]
    etatPeau?: string | null
    etatPores?: string | null
    coucheCornee?: string | null
    irrigationSanguine?: string | null
    impuretes?: string | null
    sensibiliteCutanee?: string | null
    fumeur?: string | null
    niveauStress?: string | null
    expositionSoleil?: string | null
    protectionSolaire?: string | null
    suffisanceEau?: string | null
    travailExterieur?: string | null
    bainChauds?: string | null
    routineSoins?: string | null
    changementsRecents?: string | null
    preferencePeau?: string | null
    diagnosticVisuelNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: NoteCreateNestedManyWithoutClientInput
    assignments?: AssignmentCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateInput = {
    id?: string
    nom: string
    prenom: string
    adresse: string
    ville: string
    codePostal: string
    telMaison?: string | null
    telBureau?: string | null
    telCellulaire: string
    courriel: string
    dateNaissance: Date | string
    occupation?: string | null
    gender: $Enums.Gender
    serviceType: $Enums.ServiceType
    assuranceCouvert: boolean
    autreMaladie?: boolean | null
    autreMaladieDetails?: string | null
    raisonConsultation?: string | null
    diagnosticMedical?: boolean | null
    diagnosticMedicalDetails?: string | null
    medicaments?: boolean | null
    medicamentsDetails?: string | null
    accidents?: boolean | null
    accidentsDetails?: string | null
    operationsChirurgicales?: boolean | null
    operationsChirurgicalesDetails?: string | null
    traitementsActuels?: string | null
    problemesCardiaques?: boolean
    problemesCardiaquesDetails?: string | null
    maladiesGraves?: boolean
    maladiesGravesDetails?: string | null
    ortheses?: boolean
    orthesesDetails?: string | null
    allergies?: boolean
    allergiesDetails?: string | null
    raideurs?: boolean
    arthrose?: boolean
    hernieDiscale?: boolean
    oedeme?: boolean
    tendinite?: boolean
    mauxDeTete?: boolean
    flatulence?: boolean
    troublesCirculatoires?: boolean
    hypothyroidie?: boolean
    diabete?: boolean
    stresse?: boolean
    premenopause?: boolean
    douleurMusculaire?: boolean
    fibromyalgie?: boolean
    rhumatisme?: boolean
    sciatique?: boolean
    bursite?: boolean
    migraine?: boolean
    diarrhee?: boolean
    phlebite?: boolean
    hypertension?: boolean
    hypoglycemie?: boolean
    burnOut?: boolean
    menopause?: boolean
    inflammationAigue?: boolean
    arteriosclerose?: boolean
    osteoporose?: boolean
    mauxDeDos?: boolean
    fatigueDesJambes?: boolean
    troublesDigestifs?: boolean
    constipation?: boolean
    hyperthyroidie?: boolean
    hypotension?: boolean
    insomnie?: boolean
    depressionNerveuse?: boolean
    autres?: string | null
    lastVisitDate?: Date | string | null
    lastEmailSent?: Date | string | null
    feedbackEmailsSent?: number
    promoEmailsSent?: number
    zonesDouleur?: ClientProfileCreatezonesDouleurInput | string[]
    etatPeau?: string | null
    etatPores?: string | null
    coucheCornee?: string | null
    irrigationSanguine?: string | null
    impuretes?: string | null
    sensibiliteCutanee?: string | null
    fumeur?: string | null
    niveauStress?: string | null
    expositionSoleil?: string | null
    protectionSolaire?: string | null
    suffisanceEau?: string | null
    travailExterieur?: string | null
    bainChauds?: string | null
    routineSoins?: string | null
    changementsRecents?: string | null
    preferencePeau?: string | null
    diagnosticVisuelNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: NoteUncheckedCreateNestedManyWithoutClientInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    telMaison?: NullableStringFieldUpdateOperationsInput | string | null
    telBureau?: NullableStringFieldUpdateOperationsInput | string | null
    telCellulaire?: StringFieldUpdateOperationsInput | string
    courriel?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    assuranceCouvert?: BoolFieldUpdateOperationsInput | boolean
    autreMaladie?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autreMaladieDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raisonConsultation?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticMedical?: NullableBoolFieldUpdateOperationsInput | boolean | null
    diagnosticMedicalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    medicaments?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicamentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    accidents?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accidentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    operationsChirurgicales?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operationsChirurgicalesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    traitementsActuels?: NullableStringFieldUpdateOperationsInput | string | null
    problemesCardiaques?: BoolFieldUpdateOperationsInput | boolean
    problemesCardiaquesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    maladiesGraves?: BoolFieldUpdateOperationsInput | boolean
    maladiesGravesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    ortheses?: BoolFieldUpdateOperationsInput | boolean
    orthesesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: BoolFieldUpdateOperationsInput | boolean
    allergiesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raideurs?: BoolFieldUpdateOperationsInput | boolean
    arthrose?: BoolFieldUpdateOperationsInput | boolean
    hernieDiscale?: BoolFieldUpdateOperationsInput | boolean
    oedeme?: BoolFieldUpdateOperationsInput | boolean
    tendinite?: BoolFieldUpdateOperationsInput | boolean
    mauxDeTete?: BoolFieldUpdateOperationsInput | boolean
    flatulence?: BoolFieldUpdateOperationsInput | boolean
    troublesCirculatoires?: BoolFieldUpdateOperationsInput | boolean
    hypothyroidie?: BoolFieldUpdateOperationsInput | boolean
    diabete?: BoolFieldUpdateOperationsInput | boolean
    stresse?: BoolFieldUpdateOperationsInput | boolean
    premenopause?: BoolFieldUpdateOperationsInput | boolean
    douleurMusculaire?: BoolFieldUpdateOperationsInput | boolean
    fibromyalgie?: BoolFieldUpdateOperationsInput | boolean
    rhumatisme?: BoolFieldUpdateOperationsInput | boolean
    sciatique?: BoolFieldUpdateOperationsInput | boolean
    bursite?: BoolFieldUpdateOperationsInput | boolean
    migraine?: BoolFieldUpdateOperationsInput | boolean
    diarrhee?: BoolFieldUpdateOperationsInput | boolean
    phlebite?: BoolFieldUpdateOperationsInput | boolean
    hypertension?: BoolFieldUpdateOperationsInput | boolean
    hypoglycemie?: BoolFieldUpdateOperationsInput | boolean
    burnOut?: BoolFieldUpdateOperationsInput | boolean
    menopause?: BoolFieldUpdateOperationsInput | boolean
    inflammationAigue?: BoolFieldUpdateOperationsInput | boolean
    arteriosclerose?: BoolFieldUpdateOperationsInput | boolean
    osteoporose?: BoolFieldUpdateOperationsInput | boolean
    mauxDeDos?: BoolFieldUpdateOperationsInput | boolean
    fatigueDesJambes?: BoolFieldUpdateOperationsInput | boolean
    troublesDigestifs?: BoolFieldUpdateOperationsInput | boolean
    constipation?: BoolFieldUpdateOperationsInput | boolean
    hyperthyroidie?: BoolFieldUpdateOperationsInput | boolean
    hypotension?: BoolFieldUpdateOperationsInput | boolean
    insomnie?: BoolFieldUpdateOperationsInput | boolean
    depressionNerveuse?: BoolFieldUpdateOperationsInput | boolean
    autres?: NullableStringFieldUpdateOperationsInput | string | null
    lastVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackEmailsSent?: IntFieldUpdateOperationsInput | number
    promoEmailsSent?: IntFieldUpdateOperationsInput | number
    zonesDouleur?: ClientProfileUpdatezonesDouleurInput | string[]
    etatPeau?: NullableStringFieldUpdateOperationsInput | string | null
    etatPores?: NullableStringFieldUpdateOperationsInput | string | null
    coucheCornee?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationSanguine?: NullableStringFieldUpdateOperationsInput | string | null
    impuretes?: NullableStringFieldUpdateOperationsInput | string | null
    sensibiliteCutanee?: NullableStringFieldUpdateOperationsInput | string | null
    fumeur?: NullableStringFieldUpdateOperationsInput | string | null
    niveauStress?: NullableStringFieldUpdateOperationsInput | string | null
    expositionSoleil?: NullableStringFieldUpdateOperationsInput | string | null
    protectionSolaire?: NullableStringFieldUpdateOperationsInput | string | null
    suffisanceEau?: NullableStringFieldUpdateOperationsInput | string | null
    travailExterieur?: NullableStringFieldUpdateOperationsInput | string | null
    bainChauds?: NullableStringFieldUpdateOperationsInput | string | null
    routineSoins?: NullableStringFieldUpdateOperationsInput | string | null
    changementsRecents?: NullableStringFieldUpdateOperationsInput | string | null
    preferencePeau?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticVisuelNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NoteUpdateManyWithoutClientNestedInput
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    telMaison?: NullableStringFieldUpdateOperationsInput | string | null
    telBureau?: NullableStringFieldUpdateOperationsInput | string | null
    telCellulaire?: StringFieldUpdateOperationsInput | string
    courriel?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    assuranceCouvert?: BoolFieldUpdateOperationsInput | boolean
    autreMaladie?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autreMaladieDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raisonConsultation?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticMedical?: NullableBoolFieldUpdateOperationsInput | boolean | null
    diagnosticMedicalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    medicaments?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicamentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    accidents?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accidentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    operationsChirurgicales?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operationsChirurgicalesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    traitementsActuels?: NullableStringFieldUpdateOperationsInput | string | null
    problemesCardiaques?: BoolFieldUpdateOperationsInput | boolean
    problemesCardiaquesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    maladiesGraves?: BoolFieldUpdateOperationsInput | boolean
    maladiesGravesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    ortheses?: BoolFieldUpdateOperationsInput | boolean
    orthesesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: BoolFieldUpdateOperationsInput | boolean
    allergiesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raideurs?: BoolFieldUpdateOperationsInput | boolean
    arthrose?: BoolFieldUpdateOperationsInput | boolean
    hernieDiscale?: BoolFieldUpdateOperationsInput | boolean
    oedeme?: BoolFieldUpdateOperationsInput | boolean
    tendinite?: BoolFieldUpdateOperationsInput | boolean
    mauxDeTete?: BoolFieldUpdateOperationsInput | boolean
    flatulence?: BoolFieldUpdateOperationsInput | boolean
    troublesCirculatoires?: BoolFieldUpdateOperationsInput | boolean
    hypothyroidie?: BoolFieldUpdateOperationsInput | boolean
    diabete?: BoolFieldUpdateOperationsInput | boolean
    stresse?: BoolFieldUpdateOperationsInput | boolean
    premenopause?: BoolFieldUpdateOperationsInput | boolean
    douleurMusculaire?: BoolFieldUpdateOperationsInput | boolean
    fibromyalgie?: BoolFieldUpdateOperationsInput | boolean
    rhumatisme?: BoolFieldUpdateOperationsInput | boolean
    sciatique?: BoolFieldUpdateOperationsInput | boolean
    bursite?: BoolFieldUpdateOperationsInput | boolean
    migraine?: BoolFieldUpdateOperationsInput | boolean
    diarrhee?: BoolFieldUpdateOperationsInput | boolean
    phlebite?: BoolFieldUpdateOperationsInput | boolean
    hypertension?: BoolFieldUpdateOperationsInput | boolean
    hypoglycemie?: BoolFieldUpdateOperationsInput | boolean
    burnOut?: BoolFieldUpdateOperationsInput | boolean
    menopause?: BoolFieldUpdateOperationsInput | boolean
    inflammationAigue?: BoolFieldUpdateOperationsInput | boolean
    arteriosclerose?: BoolFieldUpdateOperationsInput | boolean
    osteoporose?: BoolFieldUpdateOperationsInput | boolean
    mauxDeDos?: BoolFieldUpdateOperationsInput | boolean
    fatigueDesJambes?: BoolFieldUpdateOperationsInput | boolean
    troublesDigestifs?: BoolFieldUpdateOperationsInput | boolean
    constipation?: BoolFieldUpdateOperationsInput | boolean
    hyperthyroidie?: BoolFieldUpdateOperationsInput | boolean
    hypotension?: BoolFieldUpdateOperationsInput | boolean
    insomnie?: BoolFieldUpdateOperationsInput | boolean
    depressionNerveuse?: BoolFieldUpdateOperationsInput | boolean
    autres?: NullableStringFieldUpdateOperationsInput | string | null
    lastVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackEmailsSent?: IntFieldUpdateOperationsInput | number
    promoEmailsSent?: IntFieldUpdateOperationsInput | number
    zonesDouleur?: ClientProfileUpdatezonesDouleurInput | string[]
    etatPeau?: NullableStringFieldUpdateOperationsInput | string | null
    etatPores?: NullableStringFieldUpdateOperationsInput | string | null
    coucheCornee?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationSanguine?: NullableStringFieldUpdateOperationsInput | string | null
    impuretes?: NullableStringFieldUpdateOperationsInput | string | null
    sensibiliteCutanee?: NullableStringFieldUpdateOperationsInput | string | null
    fumeur?: NullableStringFieldUpdateOperationsInput | string | null
    niveauStress?: NullableStringFieldUpdateOperationsInput | string | null
    expositionSoleil?: NullableStringFieldUpdateOperationsInput | string | null
    protectionSolaire?: NullableStringFieldUpdateOperationsInput | string | null
    suffisanceEau?: NullableStringFieldUpdateOperationsInput | string | null
    travailExterieur?: NullableStringFieldUpdateOperationsInput | string | null
    bainChauds?: NullableStringFieldUpdateOperationsInput | string | null
    routineSoins?: NullableStringFieldUpdateOperationsInput | string | null
    changementsRecents?: NullableStringFieldUpdateOperationsInput | string | null
    preferencePeau?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticVisuelNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NoteUncheckedUpdateManyWithoutClientNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileCreateManyInput = {
    id?: string
    nom: string
    prenom: string
    adresse: string
    ville: string
    codePostal: string
    telMaison?: string | null
    telBureau?: string | null
    telCellulaire: string
    courriel: string
    dateNaissance: Date | string
    occupation?: string | null
    gender: $Enums.Gender
    serviceType: $Enums.ServiceType
    assuranceCouvert: boolean
    autreMaladie?: boolean | null
    autreMaladieDetails?: string | null
    raisonConsultation?: string | null
    diagnosticMedical?: boolean | null
    diagnosticMedicalDetails?: string | null
    medicaments?: boolean | null
    medicamentsDetails?: string | null
    accidents?: boolean | null
    accidentsDetails?: string | null
    operationsChirurgicales?: boolean | null
    operationsChirurgicalesDetails?: string | null
    traitementsActuels?: string | null
    problemesCardiaques?: boolean
    problemesCardiaquesDetails?: string | null
    maladiesGraves?: boolean
    maladiesGravesDetails?: string | null
    ortheses?: boolean
    orthesesDetails?: string | null
    allergies?: boolean
    allergiesDetails?: string | null
    raideurs?: boolean
    arthrose?: boolean
    hernieDiscale?: boolean
    oedeme?: boolean
    tendinite?: boolean
    mauxDeTete?: boolean
    flatulence?: boolean
    troublesCirculatoires?: boolean
    hypothyroidie?: boolean
    diabete?: boolean
    stresse?: boolean
    premenopause?: boolean
    douleurMusculaire?: boolean
    fibromyalgie?: boolean
    rhumatisme?: boolean
    sciatique?: boolean
    bursite?: boolean
    migraine?: boolean
    diarrhee?: boolean
    phlebite?: boolean
    hypertension?: boolean
    hypoglycemie?: boolean
    burnOut?: boolean
    menopause?: boolean
    inflammationAigue?: boolean
    arteriosclerose?: boolean
    osteoporose?: boolean
    mauxDeDos?: boolean
    fatigueDesJambes?: boolean
    troublesDigestifs?: boolean
    constipation?: boolean
    hyperthyroidie?: boolean
    hypotension?: boolean
    insomnie?: boolean
    depressionNerveuse?: boolean
    autres?: string | null
    lastVisitDate?: Date | string | null
    lastEmailSent?: Date | string | null
    feedbackEmailsSent?: number
    promoEmailsSent?: number
    zonesDouleur?: ClientProfileCreatezonesDouleurInput | string[]
    etatPeau?: string | null
    etatPores?: string | null
    coucheCornee?: string | null
    irrigationSanguine?: string | null
    impuretes?: string | null
    sensibiliteCutanee?: string | null
    fumeur?: string | null
    niveauStress?: string | null
    expositionSoleil?: string | null
    protectionSolaire?: string | null
    suffisanceEau?: string | null
    travailExterieur?: string | null
    bainChauds?: string | null
    routineSoins?: string | null
    changementsRecents?: string | null
    preferencePeau?: string | null
    diagnosticVisuelNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    telMaison?: NullableStringFieldUpdateOperationsInput | string | null
    telBureau?: NullableStringFieldUpdateOperationsInput | string | null
    telCellulaire?: StringFieldUpdateOperationsInput | string
    courriel?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    assuranceCouvert?: BoolFieldUpdateOperationsInput | boolean
    autreMaladie?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autreMaladieDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raisonConsultation?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticMedical?: NullableBoolFieldUpdateOperationsInput | boolean | null
    diagnosticMedicalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    medicaments?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicamentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    accidents?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accidentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    operationsChirurgicales?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operationsChirurgicalesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    traitementsActuels?: NullableStringFieldUpdateOperationsInput | string | null
    problemesCardiaques?: BoolFieldUpdateOperationsInput | boolean
    problemesCardiaquesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    maladiesGraves?: BoolFieldUpdateOperationsInput | boolean
    maladiesGravesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    ortheses?: BoolFieldUpdateOperationsInput | boolean
    orthesesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: BoolFieldUpdateOperationsInput | boolean
    allergiesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raideurs?: BoolFieldUpdateOperationsInput | boolean
    arthrose?: BoolFieldUpdateOperationsInput | boolean
    hernieDiscale?: BoolFieldUpdateOperationsInput | boolean
    oedeme?: BoolFieldUpdateOperationsInput | boolean
    tendinite?: BoolFieldUpdateOperationsInput | boolean
    mauxDeTete?: BoolFieldUpdateOperationsInput | boolean
    flatulence?: BoolFieldUpdateOperationsInput | boolean
    troublesCirculatoires?: BoolFieldUpdateOperationsInput | boolean
    hypothyroidie?: BoolFieldUpdateOperationsInput | boolean
    diabete?: BoolFieldUpdateOperationsInput | boolean
    stresse?: BoolFieldUpdateOperationsInput | boolean
    premenopause?: BoolFieldUpdateOperationsInput | boolean
    douleurMusculaire?: BoolFieldUpdateOperationsInput | boolean
    fibromyalgie?: BoolFieldUpdateOperationsInput | boolean
    rhumatisme?: BoolFieldUpdateOperationsInput | boolean
    sciatique?: BoolFieldUpdateOperationsInput | boolean
    bursite?: BoolFieldUpdateOperationsInput | boolean
    migraine?: BoolFieldUpdateOperationsInput | boolean
    diarrhee?: BoolFieldUpdateOperationsInput | boolean
    phlebite?: BoolFieldUpdateOperationsInput | boolean
    hypertension?: BoolFieldUpdateOperationsInput | boolean
    hypoglycemie?: BoolFieldUpdateOperationsInput | boolean
    burnOut?: BoolFieldUpdateOperationsInput | boolean
    menopause?: BoolFieldUpdateOperationsInput | boolean
    inflammationAigue?: BoolFieldUpdateOperationsInput | boolean
    arteriosclerose?: BoolFieldUpdateOperationsInput | boolean
    osteoporose?: BoolFieldUpdateOperationsInput | boolean
    mauxDeDos?: BoolFieldUpdateOperationsInput | boolean
    fatigueDesJambes?: BoolFieldUpdateOperationsInput | boolean
    troublesDigestifs?: BoolFieldUpdateOperationsInput | boolean
    constipation?: BoolFieldUpdateOperationsInput | boolean
    hyperthyroidie?: BoolFieldUpdateOperationsInput | boolean
    hypotension?: BoolFieldUpdateOperationsInput | boolean
    insomnie?: BoolFieldUpdateOperationsInput | boolean
    depressionNerveuse?: BoolFieldUpdateOperationsInput | boolean
    autres?: NullableStringFieldUpdateOperationsInput | string | null
    lastVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackEmailsSent?: IntFieldUpdateOperationsInput | number
    promoEmailsSent?: IntFieldUpdateOperationsInput | number
    zonesDouleur?: ClientProfileUpdatezonesDouleurInput | string[]
    etatPeau?: NullableStringFieldUpdateOperationsInput | string | null
    etatPores?: NullableStringFieldUpdateOperationsInput | string | null
    coucheCornee?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationSanguine?: NullableStringFieldUpdateOperationsInput | string | null
    impuretes?: NullableStringFieldUpdateOperationsInput | string | null
    sensibiliteCutanee?: NullableStringFieldUpdateOperationsInput | string | null
    fumeur?: NullableStringFieldUpdateOperationsInput | string | null
    niveauStress?: NullableStringFieldUpdateOperationsInput | string | null
    expositionSoleil?: NullableStringFieldUpdateOperationsInput | string | null
    protectionSolaire?: NullableStringFieldUpdateOperationsInput | string | null
    suffisanceEau?: NullableStringFieldUpdateOperationsInput | string | null
    travailExterieur?: NullableStringFieldUpdateOperationsInput | string | null
    bainChauds?: NullableStringFieldUpdateOperationsInput | string | null
    routineSoins?: NullableStringFieldUpdateOperationsInput | string | null
    changementsRecents?: NullableStringFieldUpdateOperationsInput | string | null
    preferencePeau?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticVisuelNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    telMaison?: NullableStringFieldUpdateOperationsInput | string | null
    telBureau?: NullableStringFieldUpdateOperationsInput | string | null
    telCellulaire?: StringFieldUpdateOperationsInput | string
    courriel?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    assuranceCouvert?: BoolFieldUpdateOperationsInput | boolean
    autreMaladie?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autreMaladieDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raisonConsultation?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticMedical?: NullableBoolFieldUpdateOperationsInput | boolean | null
    diagnosticMedicalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    medicaments?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicamentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    accidents?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accidentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    operationsChirurgicales?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operationsChirurgicalesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    traitementsActuels?: NullableStringFieldUpdateOperationsInput | string | null
    problemesCardiaques?: BoolFieldUpdateOperationsInput | boolean
    problemesCardiaquesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    maladiesGraves?: BoolFieldUpdateOperationsInput | boolean
    maladiesGravesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    ortheses?: BoolFieldUpdateOperationsInput | boolean
    orthesesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: BoolFieldUpdateOperationsInput | boolean
    allergiesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raideurs?: BoolFieldUpdateOperationsInput | boolean
    arthrose?: BoolFieldUpdateOperationsInput | boolean
    hernieDiscale?: BoolFieldUpdateOperationsInput | boolean
    oedeme?: BoolFieldUpdateOperationsInput | boolean
    tendinite?: BoolFieldUpdateOperationsInput | boolean
    mauxDeTete?: BoolFieldUpdateOperationsInput | boolean
    flatulence?: BoolFieldUpdateOperationsInput | boolean
    troublesCirculatoires?: BoolFieldUpdateOperationsInput | boolean
    hypothyroidie?: BoolFieldUpdateOperationsInput | boolean
    diabete?: BoolFieldUpdateOperationsInput | boolean
    stresse?: BoolFieldUpdateOperationsInput | boolean
    premenopause?: BoolFieldUpdateOperationsInput | boolean
    douleurMusculaire?: BoolFieldUpdateOperationsInput | boolean
    fibromyalgie?: BoolFieldUpdateOperationsInput | boolean
    rhumatisme?: BoolFieldUpdateOperationsInput | boolean
    sciatique?: BoolFieldUpdateOperationsInput | boolean
    bursite?: BoolFieldUpdateOperationsInput | boolean
    migraine?: BoolFieldUpdateOperationsInput | boolean
    diarrhee?: BoolFieldUpdateOperationsInput | boolean
    phlebite?: BoolFieldUpdateOperationsInput | boolean
    hypertension?: BoolFieldUpdateOperationsInput | boolean
    hypoglycemie?: BoolFieldUpdateOperationsInput | boolean
    burnOut?: BoolFieldUpdateOperationsInput | boolean
    menopause?: BoolFieldUpdateOperationsInput | boolean
    inflammationAigue?: BoolFieldUpdateOperationsInput | boolean
    arteriosclerose?: BoolFieldUpdateOperationsInput | boolean
    osteoporose?: BoolFieldUpdateOperationsInput | boolean
    mauxDeDos?: BoolFieldUpdateOperationsInput | boolean
    fatigueDesJambes?: BoolFieldUpdateOperationsInput | boolean
    troublesDigestifs?: BoolFieldUpdateOperationsInput | boolean
    constipation?: BoolFieldUpdateOperationsInput | boolean
    hyperthyroidie?: BoolFieldUpdateOperationsInput | boolean
    hypotension?: BoolFieldUpdateOperationsInput | boolean
    insomnie?: BoolFieldUpdateOperationsInput | boolean
    depressionNerveuse?: BoolFieldUpdateOperationsInput | boolean
    autres?: NullableStringFieldUpdateOperationsInput | string | null
    lastVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackEmailsSent?: IntFieldUpdateOperationsInput | number
    promoEmailsSent?: IntFieldUpdateOperationsInput | number
    zonesDouleur?: ClientProfileUpdatezonesDouleurInput | string[]
    etatPeau?: NullableStringFieldUpdateOperationsInput | string | null
    etatPores?: NullableStringFieldUpdateOperationsInput | string | null
    coucheCornee?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationSanguine?: NullableStringFieldUpdateOperationsInput | string | null
    impuretes?: NullableStringFieldUpdateOperationsInput | string | null
    sensibiliteCutanee?: NullableStringFieldUpdateOperationsInput | string | null
    fumeur?: NullableStringFieldUpdateOperationsInput | string | null
    niveauStress?: NullableStringFieldUpdateOperationsInput | string | null
    expositionSoleil?: NullableStringFieldUpdateOperationsInput | string | null
    protectionSolaire?: NullableStringFieldUpdateOperationsInput | string | null
    suffisanceEau?: NullableStringFieldUpdateOperationsInput | string | null
    travailExterieur?: NullableStringFieldUpdateOperationsInput | string | null
    bainChauds?: NullableStringFieldUpdateOperationsInput | string | null
    routineSoins?: NullableStringFieldUpdateOperationsInput | string | null
    changementsRecents?: NullableStringFieldUpdateOperationsInput | string | null
    preferencePeau?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticVisuelNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientFeedbackCreateInput = {
    id?: string
    token: string
    noteId: string
    clientEmail?: string | null
    clientName?: string | null
    rating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    wouldRecommend?: boolean | null
    hasResponded?: boolean
    respondedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ClientFeedbackUncheckedCreateInput = {
    id?: string
    token: string
    noteId: string
    clientEmail?: string | null
    clientName?: string | null
    rating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    wouldRecommend?: boolean | null
    hasResponded?: boolean
    respondedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ClientFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasResponded?: BoolFieldUpdateOperationsInput | boolean
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasResponded?: BoolFieldUpdateOperationsInput | boolean
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientFeedbackCreateManyInput = {
    id?: string
    token: string
    noteId: string
    clientEmail?: string | null
    clientName?: string | null
    rating?: number | null
    comment?: string | null
    wouldReturn?: boolean | null
    wouldRecommend?: boolean | null
    hasResponded?: boolean
    respondedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ClientFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasResponded?: BoolFieldUpdateOperationsInput | boolean
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    noteId?: StringFieldUpdateOperationsInput | string
    clientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    wouldReturn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wouldRecommend?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasResponded?: BoolFieldUpdateOperationsInput | boolean
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogCreateInput = {
    id?: string
    type: string
    clientEmail: string
    clientName?: string | null
    subject: string
    htmlContent: string
    noteId?: string | null
    promotionId?: string | null
    sentAt?: Date | string
    opened?: boolean
    clicked?: boolean
  }

  export type EmailLogUncheckedCreateInput = {
    id?: string
    type: string
    clientEmail: string
    clientName?: string | null
    subject: string
    htmlContent: string
    noteId?: string | null
    promotionId?: string | null
    sentAt?: Date | string
    opened?: boolean
    clicked?: boolean
  }

  export type EmailLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opened?: BoolFieldUpdateOperationsInput | boolean
    clicked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opened?: BoolFieldUpdateOperationsInput | boolean
    clicked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailLogCreateManyInput = {
    id?: string
    type: string
    clientEmail: string
    clientName?: string | null
    subject: string
    htmlContent: string
    noteId?: string | null
    promotionId?: string | null
    sentAt?: Date | string
    opened?: boolean
    clicked?: boolean
  }

  export type EmailLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opened?: BoolFieldUpdateOperationsInput | boolean
    clicked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    noteId?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opened?: BoolFieldUpdateOperationsInput | boolean
    clicked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoteCreateInput = {
    id?: string
    content: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    feedbackToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutNotesInput
    author: UserCreateNestedOneWithoutNotesCreatedInput
  }

  export type NoteUncheckedCreateInput = {
    id?: string
    content: string
    clientId: string
    authorId: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    feedbackToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutNotesNestedInput
    author?: UserUpdateOneRequiredWithoutNotesCreatedNestedInput
  }

  export type NoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteCreateManyInput = {
    id?: string
    content: string
    clientId: string
    authorId: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    feedbackToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateInput = {
    id?: string
    assignedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutAssignmentsInput
    professional: UserCreateNestedOneWithoutAssignedClientsInput
  }

  export type AssignmentUncheckedCreateInput = {
    id?: string
    clientId: string
    professionalId: string
    assignedAt?: Date | string
  }

  export type AssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutAssignmentsNestedInput
    professional?: UserUpdateOneRequiredWithoutAssignedClientsNestedInput
  }

  export type AssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    professionalId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateManyInput = {
    id?: string
    clientId: string
    professionalId: string
    assignedAt?: Date | string
  }

  export type AssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    professionalId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
    professional: UserCreateNestedOneWithoutReviewsReceivedInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    professionalId: string
    isAnonymous?: boolean
    createdAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    professional?: UserUpdateOneRequiredWithoutReviewsReceivedNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    professionalId?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    rating: number
    comment?: string | null
    professionalId: string
    isAnonymous?: boolean
    createdAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    professionalId?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ServiceCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    duration: number
    price: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
    packageServices?: PackageServiceCreateNestedManyWithoutServiceInput
    promotions?: ServicePromotionCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    duration: number
    price: Decimal | DecimalJsLike | number | string
    categoryId: string
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
    packageServices?: PackageServiceUncheckedCreateNestedManyWithoutServiceInput
    promotions?: ServicePromotionUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresProfessional?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
    packageServices?: PackageServiceUpdateManyWithoutServiceNestedInput
    promotions?: ServicePromotionUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresProfessional?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
    packageServices?: PackageServiceUncheckedUpdateManyWithoutServiceNestedInput
    promotions?: ServicePromotionUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    duration: number
    price: Decimal | DecimalJsLike | number | string
    categoryId: string
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresProfessional?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresProfessional?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    variant?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: PackageServiceCreateNestedManyWithoutPackageInput
    bookings?: BookingCreateNestedManyWithoutPackageInput
    promotions?: PackagePromotionCreateNestedManyWithoutPackageInput
  }

  export type PackageUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    variant?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: PackageServiceUncheckedCreateNestedManyWithoutPackageInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPackageInput
    promotions?: PackagePromotionUncheckedCreateNestedManyWithoutPackageInput
  }

  export type PackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: PackageServiceUpdateManyWithoutPackageNestedInput
    bookings?: BookingUpdateManyWithoutPackageNestedInput
    promotions?: PackagePromotionUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: PackageServiceUncheckedUpdateManyWithoutPackageNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPackageNestedInput
    promotions?: PackagePromotionUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type PackageCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    variant?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageServiceCreateInput = {
    id?: string
    quantity?: number
    isOptional?: boolean
    extraCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    package: PackageCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutPackageServicesInput
  }

  export type PackageServiceUncheckedCreateInput = {
    id?: string
    packageId: string
    serviceId: string
    quantity?: number
    isOptional?: boolean
    extraCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PackageServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    extraCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    package?: PackageUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutPackageServicesNestedInput
  }

  export type PackageServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    extraCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageServiceCreateManyInput = {
    id?: string
    packageId: string
    serviceId: string
    quantity?: number
    isOptional?: boolean
    extraCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PackageServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    extraCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    extraCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    stripePaymentId?: string | null
    stripeCustomerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    receiptUrl?: string | null
    receiptPdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedOneWithoutPaymentInput
    order?: OrderCreateNestedOneWithoutPaymentInput
    giftCard?: GiftCardCreateNestedOneWithoutPaymentInput
    gymSubscription?: GymSubscriptionCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    stripePaymentId?: string | null
    stripeCustomerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    receiptUrl?: string | null
    receiptPdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedOneWithoutPaymentInput
    order?: OrderUncheckedCreateNestedOneWithoutPaymentInput
    giftCard?: GiftCardUncheckedCreateNestedOneWithoutPaymentInput
    gymSubscription?: GymSubscriptionUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutPaymentNestedInput
    order?: OrderUpdateOneWithoutPaymentNestedInput
    giftCard?: GiftCardUpdateOneWithoutPaymentNestedInput
    gymSubscription?: GymSubscriptionUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateOneWithoutPaymentNestedInput
    order?: OrderUncheckedUpdateOneWithoutPaymentNestedInput
    giftCard?: GiftCardUncheckedUpdateOneWithoutPaymentNestedInput
    gymSubscription?: GymSubscriptionUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    stripePaymentId?: string | null
    stripeCustomerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    receiptUrl?: string | null
    receiptPdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutBookingsInput
    package?: PackageCreateNestedOneWithoutBookingsInput
    professional?: UserCreateNestedOneWithoutBookingsAsProfessionalInput
    giftCard?: GiftCardCreateNestedOneWithoutUsedInBookingsInput
    payment: PaymentCreateNestedOneWithoutBookingInput
    createdBy?: UserCreateNestedOneWithoutBookingsCreatedInput
    statusHistory?: BookingStatusHistoryCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    serviceId?: string | null
    packageId?: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    professionalId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardId?: string | null
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    paymentId: string
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: BookingStatusHistoryUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutBookingsNestedInput
    package?: PackageUpdateOneWithoutBookingsNestedInput
    professional?: UserUpdateOneWithoutBookingsAsProfessionalNestedInput
    giftCard?: GiftCardUpdateOneWithoutUsedInBookingsNestedInput
    payment?: PaymentUpdateOneRequiredWithoutBookingNestedInput
    createdBy?: UserUpdateOneWithoutBookingsCreatedNestedInput
    statusHistory?: BookingStatusHistoryUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    professionalId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardId?: NullableStringFieldUpdateOperationsInput | string | null
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: BookingStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    serviceId?: string | null
    packageId?: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    professionalId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardId?: string | null
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    paymentId: string
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    professionalId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardId?: NullableStringFieldUpdateOperationsInput | string | null
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityCreateInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    isAvailable?: boolean
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    professional: UserCreateNestedOneWithoutAvailabilitiesInput
  }

  export type AvailabilityUncheckedCreateInput = {
    id?: string
    professionalId: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    isAvailable?: boolean
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    professional?: UserUpdateOneRequiredWithoutAvailabilitiesNestedInput
  }

  export type AvailabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    professionalId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityCreateManyInput = {
    id?: string
    professionalId: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    isAvailable?: boolean
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    professionalId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GiftCardCreateInput = {
    id?: string
    code: string
    amount: Decimal | DecimalJsLike | number | string
    balance: Decimal | DecimalJsLike | number | string
    purchasedBy?: string | null
    recipientName?: string | null
    recipientEmail?: string | null
    message?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment: PaymentCreateNestedOneWithoutGiftCardInput
    usedInBookings?: BookingCreateNestedManyWithoutGiftCardInput
  }

  export type GiftCardUncheckedCreateInput = {
    id?: string
    code: string
    amount: Decimal | DecimalJsLike | number | string
    balance: Decimal | DecimalJsLike | number | string
    purchasedBy?: string | null
    recipientName?: string | null
    recipientEmail?: string | null
    message?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    paymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usedInBookings?: BookingUncheckedCreateNestedManyWithoutGiftCardInput
  }

  export type GiftCardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchasedBy?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutGiftCardNestedInput
    usedInBookings?: BookingUpdateManyWithoutGiftCardNestedInput
  }

  export type GiftCardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchasedBy?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedInBookings?: BookingUncheckedUpdateManyWithoutGiftCardNestedInput
  }

  export type GiftCardCreateManyInput = {
    id?: string
    code: string
    amount: Decimal | DecimalJsLike | number | string
    balance: Decimal | DecimalJsLike | number | string
    purchasedBy?: string | null
    recipientName?: string | null
    recipientEmail?: string | null
    message?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    paymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GiftCardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchasedBy?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GiftCardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchasedBy?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymMembershipCreateInput = {
    id?: string
    type: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration: number
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: GymSubscriptionCreateNestedManyWithoutMembershipInput
  }

  export type GymMembershipUncheckedCreateInput = {
    id?: string
    type: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration: number
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: GymSubscriptionUncheckedCreateNestedManyWithoutMembershipInput
  }

  export type GymMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: GymSubscriptionUpdateManyWithoutMembershipNestedInput
  }

  export type GymMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: GymSubscriptionUncheckedUpdateManyWithoutMembershipNestedInput
  }

  export type GymMembershipCreateManyInput = {
    id?: string
    type: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration: number
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymSubscriptionCreateInput = {
    id?: string
    clientEmail: string
    clientName: string
    clientPhone: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    membership: GymMembershipCreateNestedOneWithoutSubscriptionsInput
    payment: PaymentCreateNestedOneWithoutGymSubscriptionInput
  }

  export type GymSubscriptionUncheckedCreateInput = {
    id?: string
    membershipId: string
    clientEmail: string
    clientName: string
    clientPhone: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    paymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: GymMembershipUpdateOneRequiredWithoutSubscriptionsNestedInput
    payment?: PaymentUpdateOneRequiredWithoutGymSubscriptionNestedInput
  }

  export type GymSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    membershipId?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymSubscriptionCreateManyInput = {
    id?: string
    membershipId: string
    clientEmail: string
    clientName: string
    clientPhone: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    paymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    membershipId?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    stock?: number
    category?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    promotions?: ProductPromotionCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    stock?: number
    category?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    promotions?: ProductPromotionUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    promotions?: ProductPromotionUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    promotions?: ProductPromotionUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    stock?: number
    category?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    orderNumber: string
    clientEmail: string
    clientName: string
    clientPhone: string
    shippingAddress?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payment: PaymentCreateNestedOneWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    clientEmail: string
    clientName: string
    clientPhone: string
    shippingAddress?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    paymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    orderNumber: string
    clientEmail: string
    clientName: string
    clientPhone: string
    shippingAddress?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    paymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    productId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    productId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCreateInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    discountType: $Enums.DiscountType
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServicePromotionCreateNestedManyWithoutPromotionInput
    packages?: PackagePromotionCreateNestedManyWithoutPromotionInput
    products?: ProductPromotionCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    discountType: $Enums.DiscountType
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServicePromotionUncheckedCreateNestedManyWithoutPromotionInput
    packages?: PackagePromotionUncheckedCreateNestedManyWithoutPromotionInput
    products?: ProductPromotionUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServicePromotionUpdateManyWithoutPromotionNestedInput
    packages?: PackagePromotionUpdateManyWithoutPromotionNestedInput
    products?: ProductPromotionUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServicePromotionUncheckedUpdateManyWithoutPromotionNestedInput
    packages?: PackagePromotionUncheckedUpdateManyWithoutPromotionNestedInput
    products?: ProductPromotionUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    discountType: $Enums.DiscountType
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePromotionCreateInput = {
    id?: string
    createdAt?: Date | string
    promotion: PromotionCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutPromotionsInput
  }

  export type ServicePromotionUncheckedCreateInput = {
    id?: string
    promotionId: string
    serviceId: string
    createdAt?: Date | string
  }

  export type ServicePromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotion?: PromotionUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutPromotionsNestedInput
  }

  export type ServicePromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePromotionCreateManyInput = {
    id?: string
    promotionId: string
    serviceId: string
    createdAt?: Date | string
  }

  export type ServicePromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagePromotionCreateInput = {
    id?: string
    createdAt?: Date | string
    promotion: PromotionCreateNestedOneWithoutPackagesInput
    package: PackageCreateNestedOneWithoutPromotionsInput
  }

  export type PackagePromotionUncheckedCreateInput = {
    id?: string
    promotionId: string
    packageId: string
    createdAt?: Date | string
  }

  export type PackagePromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotion?: PromotionUpdateOneRequiredWithoutPackagesNestedInput
    package?: PackageUpdateOneRequiredWithoutPromotionsNestedInput
  }

  export type PackagePromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagePromotionCreateManyInput = {
    id?: string
    promotionId: string
    packageId: string
    createdAt?: Date | string
  }

  export type PackagePromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagePromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPromotionCreateInput = {
    id?: string
    createdAt?: Date | string
    promotion: PromotionCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutPromotionsInput
  }

  export type ProductPromotionUncheckedCreateInput = {
    id?: string
    promotionId: string
    productId: string
    createdAt?: Date | string
  }

  export type ProductPromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotion?: PromotionUpdateOneRequiredWithoutProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutPromotionsNestedInput
  }

  export type ProductPromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPromotionCreateManyInput = {
    id?: string
    promotionId: string
    productId: string
    createdAt?: Date | string
  }

  export type ProductPromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingStatusHistoryCreateInput = {
    id?: string
    oldStatus?: $Enums.BookingStatus | null
    newStatus: $Enums.BookingStatus
    changedById: string
    changedBy: string
    changedByRole: string
    reason?: string | null
    notes?: string | null
    oldDate?: Date | string | null
    newDate?: Date | string | null
    oldStartTime?: string | null
    newStartTime?: string | null
    oldEndTime?: string | null
    newEndTime?: string | null
    oldProfessionalId?: string | null
    newProfessionalId?: string | null
    changedAt?: Date | string
    booking: BookingCreateNestedOneWithoutStatusHistoryInput
  }

  export type BookingStatusHistoryUncheckedCreateInput = {
    id?: string
    bookingId: string
    oldStatus?: $Enums.BookingStatus | null
    newStatus: $Enums.BookingStatus
    changedById: string
    changedBy: string
    changedByRole: string
    reason?: string | null
    notes?: string | null
    oldDate?: Date | string | null
    newDate?: Date | string | null
    oldStartTime?: string | null
    newStartTime?: string | null
    oldEndTime?: string | null
    newEndTime?: string | null
    oldProfessionalId?: string | null
    newProfessionalId?: string | null
    changedAt?: Date | string
  }

  export type BookingStatusHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    newStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    changedById?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changedByRole?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    oldDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oldStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    newStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    oldEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    newEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    oldProfessionalId?: NullableStringFieldUpdateOperationsInput | string | null
    newProfessionalId?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutStatusHistoryNestedInput
  }

  export type BookingStatusHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    newStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    changedById?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changedByRole?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    oldDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oldStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    newStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    oldEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    newEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    oldProfessionalId?: NullableStringFieldUpdateOperationsInput | string | null
    newProfessionalId?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingStatusHistoryCreateManyInput = {
    id?: string
    bookingId: string
    oldStatus?: $Enums.BookingStatus | null
    newStatus: $Enums.BookingStatus
    changedById: string
    changedBy: string
    changedByRole: string
    reason?: string | null
    notes?: string | null
    oldDate?: Date | string | null
    newDate?: Date | string | null
    oldStartTime?: string | null
    newStartTime?: string | null
    oldEndTime?: string | null
    newEndTime?: string | null
    oldProfessionalId?: string | null
    newProfessionalId?: string | null
    changedAt?: Date | string
  }

  export type BookingStatusHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    newStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    changedById?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changedByRole?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    oldDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oldStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    newStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    oldEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    newEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    oldProfessionalId?: NullableStringFieldUpdateOperationsInput | string | null
    newProfessionalId?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingStatusHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    newStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    changedById?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changedByRole?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    oldDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oldStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    newStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    oldEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    newEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    oldProfessionalId?: NullableStringFieldUpdateOperationsInput | string | null
    newProfessionalId?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingScheduleCreateInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    professional: UserCreateNestedOneWithoutWorkingSchedulesInput
  }

  export type WorkingScheduleUncheckedCreateInput = {
    id?: string
    professionalId: string
    dayOfWeek: number
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkingScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    professional?: UserUpdateOneRequiredWithoutWorkingSchedulesNestedInput
  }

  export type WorkingScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    professionalId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingScheduleCreateManyInput = {
    id?: string
    professionalId: string
    dayOfWeek: number
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkingScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    professionalId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakPeriodCreateInput = {
    id?: string
    dayOfWeek?: number | null
    startTime: string
    endTime: string
    label?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    professional: UserCreateNestedOneWithoutBreaksInput
  }

  export type BreakPeriodUncheckedCreateInput = {
    id?: string
    professionalId: string
    dayOfWeek?: number | null
    startTime: string
    endTime: string
    label?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreakPeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    professional?: UserUpdateOneRequiredWithoutBreaksNestedInput
  }

  export type BreakPeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    professionalId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakPeriodCreateManyInput = {
    id?: string
    professionalId: string
    dayOfWeek?: number | null
    startTime: string
    endTime: string
    label?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreakPeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakPeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    professionalId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    recipientEmail: string
    recipientName?: string | null
    bookingId?: string | null
    subject: string
    message: string
    sent?: boolean
    sentAt?: Date | string | null
    error?: string | null
    scheduledFor?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: $Enums.NotificationType
    recipientEmail: string
    recipientName?: string | null
    bookingId?: string | null
    subject: string
    message: string
    sent?: boolean
    sentAt?: Date | string | null
    error?: string | null
    scheduledFor?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: $Enums.NotificationType
    recipientEmail: string
    recipientName?: string | null
    bookingId?: string | null
    subject: string
    message: string
    sent?: boolean
    sentAt?: Date | string | null
    error?: string | null
    scheduledFor?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemSettingsUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateManyInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NoteListRelationFilter = {
    every?: NoteWhereInput
    some?: NoteWhereInput
    none?: NoteWhereInput
  }

  export type AssignmentListRelationFilter = {
    every?: AssignmentWhereInput
    some?: AssignmentWhereInput
    none?: AssignmentWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type AvailabilityListRelationFilter = {
    every?: AvailabilityWhereInput
    some?: AvailabilityWhereInput
    none?: AvailabilityWhereInput
  }

  export type WorkingScheduleListRelationFilter = {
    every?: WorkingScheduleWhereInput
    some?: WorkingScheduleWhereInput
    none?: WorkingScheduleWhereInput
  }

  export type BreakPeriodListRelationFilter = {
    every?: BreakPeriodWhereInput
    some?: BreakPeriodWhereInput
    none?: BreakPeriodWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkingScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BreakPeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    photoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    photoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    photoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type EnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ClientProfileCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    adresse?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrder
    telMaison?: SortOrder
    telBureau?: SortOrder
    telCellulaire?: SortOrder
    courriel?: SortOrder
    dateNaissance?: SortOrder
    occupation?: SortOrder
    gender?: SortOrder
    serviceType?: SortOrder
    assuranceCouvert?: SortOrder
    autreMaladie?: SortOrder
    autreMaladieDetails?: SortOrder
    raisonConsultation?: SortOrder
    diagnosticMedical?: SortOrder
    diagnosticMedicalDetails?: SortOrder
    medicaments?: SortOrder
    medicamentsDetails?: SortOrder
    accidents?: SortOrder
    accidentsDetails?: SortOrder
    operationsChirurgicales?: SortOrder
    operationsChirurgicalesDetails?: SortOrder
    traitementsActuels?: SortOrder
    problemesCardiaques?: SortOrder
    problemesCardiaquesDetails?: SortOrder
    maladiesGraves?: SortOrder
    maladiesGravesDetails?: SortOrder
    ortheses?: SortOrder
    orthesesDetails?: SortOrder
    allergies?: SortOrder
    allergiesDetails?: SortOrder
    raideurs?: SortOrder
    arthrose?: SortOrder
    hernieDiscale?: SortOrder
    oedeme?: SortOrder
    tendinite?: SortOrder
    mauxDeTete?: SortOrder
    flatulence?: SortOrder
    troublesCirculatoires?: SortOrder
    hypothyroidie?: SortOrder
    diabete?: SortOrder
    stresse?: SortOrder
    premenopause?: SortOrder
    douleurMusculaire?: SortOrder
    fibromyalgie?: SortOrder
    rhumatisme?: SortOrder
    sciatique?: SortOrder
    bursite?: SortOrder
    migraine?: SortOrder
    diarrhee?: SortOrder
    phlebite?: SortOrder
    hypertension?: SortOrder
    hypoglycemie?: SortOrder
    burnOut?: SortOrder
    menopause?: SortOrder
    inflammationAigue?: SortOrder
    arteriosclerose?: SortOrder
    osteoporose?: SortOrder
    mauxDeDos?: SortOrder
    fatigueDesJambes?: SortOrder
    troublesDigestifs?: SortOrder
    constipation?: SortOrder
    hyperthyroidie?: SortOrder
    hypotension?: SortOrder
    insomnie?: SortOrder
    depressionNerveuse?: SortOrder
    autres?: SortOrder
    lastVisitDate?: SortOrder
    lastEmailSent?: SortOrder
    feedbackEmailsSent?: SortOrder
    promoEmailsSent?: SortOrder
    zonesDouleur?: SortOrder
    etatPeau?: SortOrder
    etatPores?: SortOrder
    coucheCornee?: SortOrder
    irrigationSanguine?: SortOrder
    impuretes?: SortOrder
    sensibiliteCutanee?: SortOrder
    fumeur?: SortOrder
    niveauStress?: SortOrder
    expositionSoleil?: SortOrder
    protectionSolaire?: SortOrder
    suffisanceEau?: SortOrder
    travailExterieur?: SortOrder
    bainChauds?: SortOrder
    routineSoins?: SortOrder
    changementsRecents?: SortOrder
    preferencePeau?: SortOrder
    diagnosticVisuelNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientProfileAvgOrderByAggregateInput = {
    feedbackEmailsSent?: SortOrder
    promoEmailsSent?: SortOrder
  }

  export type ClientProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    adresse?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrder
    telMaison?: SortOrder
    telBureau?: SortOrder
    telCellulaire?: SortOrder
    courriel?: SortOrder
    dateNaissance?: SortOrder
    occupation?: SortOrder
    gender?: SortOrder
    serviceType?: SortOrder
    assuranceCouvert?: SortOrder
    autreMaladie?: SortOrder
    autreMaladieDetails?: SortOrder
    raisonConsultation?: SortOrder
    diagnosticMedical?: SortOrder
    diagnosticMedicalDetails?: SortOrder
    medicaments?: SortOrder
    medicamentsDetails?: SortOrder
    accidents?: SortOrder
    accidentsDetails?: SortOrder
    operationsChirurgicales?: SortOrder
    operationsChirurgicalesDetails?: SortOrder
    traitementsActuels?: SortOrder
    problemesCardiaques?: SortOrder
    problemesCardiaquesDetails?: SortOrder
    maladiesGraves?: SortOrder
    maladiesGravesDetails?: SortOrder
    ortheses?: SortOrder
    orthesesDetails?: SortOrder
    allergies?: SortOrder
    allergiesDetails?: SortOrder
    raideurs?: SortOrder
    arthrose?: SortOrder
    hernieDiscale?: SortOrder
    oedeme?: SortOrder
    tendinite?: SortOrder
    mauxDeTete?: SortOrder
    flatulence?: SortOrder
    troublesCirculatoires?: SortOrder
    hypothyroidie?: SortOrder
    diabete?: SortOrder
    stresse?: SortOrder
    premenopause?: SortOrder
    douleurMusculaire?: SortOrder
    fibromyalgie?: SortOrder
    rhumatisme?: SortOrder
    sciatique?: SortOrder
    bursite?: SortOrder
    migraine?: SortOrder
    diarrhee?: SortOrder
    phlebite?: SortOrder
    hypertension?: SortOrder
    hypoglycemie?: SortOrder
    burnOut?: SortOrder
    menopause?: SortOrder
    inflammationAigue?: SortOrder
    arteriosclerose?: SortOrder
    osteoporose?: SortOrder
    mauxDeDos?: SortOrder
    fatigueDesJambes?: SortOrder
    troublesDigestifs?: SortOrder
    constipation?: SortOrder
    hyperthyroidie?: SortOrder
    hypotension?: SortOrder
    insomnie?: SortOrder
    depressionNerveuse?: SortOrder
    autres?: SortOrder
    lastVisitDate?: SortOrder
    lastEmailSent?: SortOrder
    feedbackEmailsSent?: SortOrder
    promoEmailsSent?: SortOrder
    etatPeau?: SortOrder
    etatPores?: SortOrder
    coucheCornee?: SortOrder
    irrigationSanguine?: SortOrder
    impuretes?: SortOrder
    sensibiliteCutanee?: SortOrder
    fumeur?: SortOrder
    niveauStress?: SortOrder
    expositionSoleil?: SortOrder
    protectionSolaire?: SortOrder
    suffisanceEau?: SortOrder
    travailExterieur?: SortOrder
    bainChauds?: SortOrder
    routineSoins?: SortOrder
    changementsRecents?: SortOrder
    preferencePeau?: SortOrder
    diagnosticVisuelNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientProfileMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    adresse?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrder
    telMaison?: SortOrder
    telBureau?: SortOrder
    telCellulaire?: SortOrder
    courriel?: SortOrder
    dateNaissance?: SortOrder
    occupation?: SortOrder
    gender?: SortOrder
    serviceType?: SortOrder
    assuranceCouvert?: SortOrder
    autreMaladie?: SortOrder
    autreMaladieDetails?: SortOrder
    raisonConsultation?: SortOrder
    diagnosticMedical?: SortOrder
    diagnosticMedicalDetails?: SortOrder
    medicaments?: SortOrder
    medicamentsDetails?: SortOrder
    accidents?: SortOrder
    accidentsDetails?: SortOrder
    operationsChirurgicales?: SortOrder
    operationsChirurgicalesDetails?: SortOrder
    traitementsActuels?: SortOrder
    problemesCardiaques?: SortOrder
    problemesCardiaquesDetails?: SortOrder
    maladiesGraves?: SortOrder
    maladiesGravesDetails?: SortOrder
    ortheses?: SortOrder
    orthesesDetails?: SortOrder
    allergies?: SortOrder
    allergiesDetails?: SortOrder
    raideurs?: SortOrder
    arthrose?: SortOrder
    hernieDiscale?: SortOrder
    oedeme?: SortOrder
    tendinite?: SortOrder
    mauxDeTete?: SortOrder
    flatulence?: SortOrder
    troublesCirculatoires?: SortOrder
    hypothyroidie?: SortOrder
    diabete?: SortOrder
    stresse?: SortOrder
    premenopause?: SortOrder
    douleurMusculaire?: SortOrder
    fibromyalgie?: SortOrder
    rhumatisme?: SortOrder
    sciatique?: SortOrder
    bursite?: SortOrder
    migraine?: SortOrder
    diarrhee?: SortOrder
    phlebite?: SortOrder
    hypertension?: SortOrder
    hypoglycemie?: SortOrder
    burnOut?: SortOrder
    menopause?: SortOrder
    inflammationAigue?: SortOrder
    arteriosclerose?: SortOrder
    osteoporose?: SortOrder
    mauxDeDos?: SortOrder
    fatigueDesJambes?: SortOrder
    troublesDigestifs?: SortOrder
    constipation?: SortOrder
    hyperthyroidie?: SortOrder
    hypotension?: SortOrder
    insomnie?: SortOrder
    depressionNerveuse?: SortOrder
    autres?: SortOrder
    lastVisitDate?: SortOrder
    lastEmailSent?: SortOrder
    feedbackEmailsSent?: SortOrder
    promoEmailsSent?: SortOrder
    etatPeau?: SortOrder
    etatPores?: SortOrder
    coucheCornee?: SortOrder
    irrigationSanguine?: SortOrder
    impuretes?: SortOrder
    sensibiliteCutanee?: SortOrder
    fumeur?: SortOrder
    niveauStress?: SortOrder
    expositionSoleil?: SortOrder
    protectionSolaire?: SortOrder
    suffisanceEau?: SortOrder
    travailExterieur?: SortOrder
    bainChauds?: SortOrder
    routineSoins?: SortOrder
    changementsRecents?: SortOrder
    preferencePeau?: SortOrder
    diagnosticVisuelNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientProfileSumOrderByAggregateInput = {
    feedbackEmailsSent?: SortOrder
    promoEmailsSent?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type EnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ClientFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    noteId?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    wouldReturn?: SortOrder
    wouldRecommend?: SortOrder
    hasResponded?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientFeedbackAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ClientFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    noteId?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    wouldReturn?: SortOrder
    wouldRecommend?: SortOrder
    hasResponded?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    noteId?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    wouldReturn?: SortOrder
    wouldRecommend?: SortOrder
    hasResponded?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientFeedbackSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EmailLogCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    noteId?: SortOrder
    promotionId?: SortOrder
    sentAt?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
  }

  export type EmailLogMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    noteId?: SortOrder
    promotionId?: SortOrder
    sentAt?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
  }

  export type EmailLogMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    subject?: SortOrder
    htmlContent?: SortOrder
    noteId?: SortOrder
    promotionId?: SortOrder
    sentAt?: SortOrder
    opened?: SortOrder
    clicked?: SortOrder
  }

  export type ClientProfileRelationFilter = {
    is?: ClientProfileWhereInput
    isNot?: ClientProfileWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type NoteCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    clientId?: SortOrder
    authorId?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    feedbackToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    clientId?: SortOrder
    authorId?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    feedbackToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoteMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    clientId?: SortOrder
    authorId?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    feedbackToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    professionalId?: SortOrder
    assignedAt?: SortOrder
  }

  export type AssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    professionalId?: SortOrder
    assignedAt?: SortOrder
  }

  export type AssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    professionalId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    professionalId?: SortOrder
    isAnonymous?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    professionalId?: SortOrder
    isAnonymous?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    professionalId?: SortOrder
    isAnonymous?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCategoryAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type ServiceCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCategorySumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ServiceCategoryRelationFilter = {
    is?: ServiceCategoryWhereInput
    isNot?: ServiceCategoryWhereInput
  }

  export type PackageServiceListRelationFilter = {
    every?: PackageServiceWhereInput
    some?: PackageServiceWhereInput
    none?: PackageServiceWhereInput
  }

  export type ServicePromotionListRelationFilter = {
    every?: ServicePromotionWhereInput
    some?: ServicePromotionWhereInput
    none?: ServicePromotionWhereInput
  }

  export type PackageServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicePromotionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    imageUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    requiresProfessional?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
    displayOrder?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    imageUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    requiresProfessional?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    imageUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    requiresProfessional?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
    displayOrder?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type PackagePromotionListRelationFilter = {
    every?: PackagePromotionWhereInput
    some?: PackagePromotionWhereInput
    none?: PackagePromotionWhereInput
  }

  export type PackagePromotionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PackageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
    variant?: SortOrder
    imageUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageAvgOrderByAggregateInput = {
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
    displayOrder?: SortOrder
  }

  export type PackageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
    variant?: SortOrder
    imageUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
    variant?: SortOrder
    imageUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageSumOrderByAggregateInput = {
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
    displayOrder?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type PackageRelationFilter = {
    is?: PackageWhereInput
    isNot?: PackageWhereInput
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type PackageServiceCountOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    isOptional?: SortOrder
    extraCost?: SortOrder
    createdAt?: SortOrder
  }

  export type PackageServiceAvgOrderByAggregateInput = {
    quantity?: SortOrder
    extraCost?: SortOrder
  }

  export type PackageServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    isOptional?: SortOrder
    extraCost?: SortOrder
    createdAt?: SortOrder
  }

  export type PackageServiceMinOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    isOptional?: SortOrder
    extraCost?: SortOrder
    createdAt?: SortOrder
  }

  export type PackageServiceSumOrderByAggregateInput = {
    quantity?: SortOrder
    extraCost?: SortOrder
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type BookingNullableRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type OrderNullableRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type GiftCardNullableRelationFilter = {
    is?: GiftCardWhereInput | null
    isNot?: GiftCardWhereInput | null
  }

  export type GymSubscriptionNullableRelationFilter = {
    is?: GymSubscriptionWhereInput | null
    isNot?: GymSubscriptionWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    stripePaymentId?: SortOrder
    stripeCustomerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    receiptUrl?: SortOrder
    receiptPdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    stripePaymentId?: SortOrder
    stripeCustomerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    receiptUrl?: SortOrder
    receiptPdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    stripePaymentId?: SortOrder
    stripeCustomerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    receiptUrl?: SortOrder
    receiptPdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumBookingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeFilter<$PrismaModel> | $Enums.BookingType
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type ServiceNullableRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type PackageNullableRelationFilter = {
    is?: PackageWhereInput | null
    isNot?: PackageWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PaymentRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type BookingStatusHistoryListRelationFilter = {
    every?: BookingStatusHistoryWhereInput
    some?: BookingStatusHistoryWhereInput
    none?: BookingStatusHistoryWhereInput
  }

  export type BookingStatusHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    bookingNumber?: SortOrder
    type?: SortOrder
    serviceId?: SortOrder
    packageId?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    specialNotes?: SortOrder
    bookingDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    professionalId?: SortOrder
    subtotal?: SortOrder
    taxTPS?: SortOrder
    taxTVQ?: SortOrder
    total?: SortOrder
    giftCardId?: SortOrder
    giftCardAmount?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    reminderSent?: SortOrder
    googleCalendarEventId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxTPS?: SortOrder
    taxTVQ?: SortOrder
    total?: SortOrder
    giftCardAmount?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingNumber?: SortOrder
    type?: SortOrder
    serviceId?: SortOrder
    packageId?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    specialNotes?: SortOrder
    bookingDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    professionalId?: SortOrder
    subtotal?: SortOrder
    taxTPS?: SortOrder
    taxTVQ?: SortOrder
    total?: SortOrder
    giftCardId?: SortOrder
    giftCardAmount?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    reminderSent?: SortOrder
    googleCalendarEventId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    bookingNumber?: SortOrder
    type?: SortOrder
    serviceId?: SortOrder
    packageId?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    specialNotes?: SortOrder
    bookingDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    professionalId?: SortOrder
    subtotal?: SortOrder
    taxTPS?: SortOrder
    taxTVQ?: SortOrder
    total?: SortOrder
    giftCardId?: SortOrder
    giftCardAmount?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    reminderSent?: SortOrder
    googleCalendarEventId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxTPS?: SortOrder
    taxTVQ?: SortOrder
    total?: SortOrder
    giftCardAmount?: SortOrder
  }

  export type EnumBookingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingTypeFilter<$PrismaModel>
    _max?: NestedEnumBookingTypeFilter<$PrismaModel>
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type AvailabilityProfessionalIdDateCompoundUniqueInput = {
    professionalId: string
    date: Date | string
  }

  export type AvailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    professionalId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    professionalId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    professionalId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAvailable?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GiftCardCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    purchasedBy?: SortOrder
    recipientName?: SortOrder
    recipientEmail?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GiftCardAvgOrderByAggregateInput = {
    amount?: SortOrder
    balance?: SortOrder
  }

  export type GiftCardMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    purchasedBy?: SortOrder
    recipientName?: SortOrder
    recipientEmail?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GiftCardMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    purchasedBy?: SortOrder
    recipientName?: SortOrder
    recipientEmail?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GiftCardSumOrderByAggregateInput = {
    amount?: SortOrder
    balance?: SortOrder
  }

  export type GymSubscriptionListRelationFilter = {
    every?: GymSubscriptionWhereInput
    some?: GymSubscriptionWhereInput
    none?: GymSubscriptionWhereInput
  }

  export type GymSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GymMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymMembershipAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
    displayOrder?: SortOrder
  }

  export type GymMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymMembershipSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
    displayOrder?: SortOrder
  }

  export type GymMembershipRelationFilter = {
    is?: GymMembershipWhereInput
    isNot?: GymMembershipWhereInput
  }

  export type GymSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    membershipId?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    membershipId?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GymSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    membershipId?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type ProductPromotionListRelationFilter = {
    every?: ProductPromotionWhereInput
    some?: ProductPromotionWhereInput
    none?: ProductPromotionWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductPromotionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
    displayOrder?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
    displayOrder?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    shippingAddress?: SortOrder
    subtotal?: SortOrder
    taxTPS?: SortOrder
    taxTVQ?: SortOrder
    total?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxTPS?: SortOrder
    taxTVQ?: SortOrder
    total?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    shippingAddress?: SortOrder
    subtotal?: SortOrder
    taxTPS?: SortOrder
    taxTVQ?: SortOrder
    total?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    clientEmail?: SortOrder
    clientName?: SortOrder
    clientPhone?: SortOrder
    shippingAddress?: SortOrder
    subtotal?: SortOrder
    taxTPS?: SortOrder
    taxTVQ?: SortOrder
    total?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxTPS?: SortOrder
    taxTVQ?: SortOrder
    total?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type EnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionAvgOrderByAggregateInput = {
    discountValue?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionSumOrderByAggregateInput = {
    discountValue?: SortOrder
  }

  export type EnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type PromotionRelationFilter = {
    is?: PromotionWhereInput
    isNot?: PromotionWhereInput
  }

  export type ServicePromotionPromotionIdServiceIdCompoundUniqueInput = {
    promotionId: string
    serviceId: string
  }

  export type ServicePromotionCountOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type ServicePromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type ServicePromotionMinOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
  }

  export type PackagePromotionPromotionIdPackageIdCompoundUniqueInput = {
    promotionId: string
    packageId: string
  }

  export type PackagePromotionCountOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    packageId?: SortOrder
    createdAt?: SortOrder
  }

  export type PackagePromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    packageId?: SortOrder
    createdAt?: SortOrder
  }

  export type PackagePromotionMinOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    packageId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductPromotionPromotionIdProductIdCompoundUniqueInput = {
    promotionId: string
    productId: string
  }

  export type ProductPromotionCountOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductPromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductPromotionMinOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumBookingStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableFilter<$PrismaModel> | $Enums.BookingStatus | null
  }

  export type BookingRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type BookingStatusHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedById?: SortOrder
    changedBy?: SortOrder
    changedByRole?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    oldDate?: SortOrder
    newDate?: SortOrder
    oldStartTime?: SortOrder
    newStartTime?: SortOrder
    oldEndTime?: SortOrder
    newEndTime?: SortOrder
    oldProfessionalId?: SortOrder
    newProfessionalId?: SortOrder
    changedAt?: SortOrder
  }

  export type BookingStatusHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedById?: SortOrder
    changedBy?: SortOrder
    changedByRole?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    oldDate?: SortOrder
    newDate?: SortOrder
    oldStartTime?: SortOrder
    newStartTime?: SortOrder
    oldEndTime?: SortOrder
    newEndTime?: SortOrder
    oldProfessionalId?: SortOrder
    newProfessionalId?: SortOrder
    changedAt?: SortOrder
  }

  export type BookingStatusHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedById?: SortOrder
    changedBy?: SortOrder
    changedByRole?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    oldDate?: SortOrder
    newDate?: SortOrder
    oldStartTime?: SortOrder
    newStartTime?: SortOrder
    oldEndTime?: SortOrder
    newEndTime?: SortOrder
    oldProfessionalId?: SortOrder
    newProfessionalId?: SortOrder
    changedAt?: SortOrder
  }

  export type EnumBookingStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
  }

  export type WorkingScheduleProfessionalIdDayOfWeekCompoundUniqueInput = {
    professionalId: string
    dayOfWeek: number
  }

  export type WorkingScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    professionalId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkingScheduleAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type WorkingScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    professionalId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkingScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    professionalId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkingScheduleSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type BreakPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    professionalId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    label?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreakPeriodAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type BreakPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    professionalId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    label?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreakPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    professionalId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    label?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreakPeriodSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrder
    bookingId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    sent?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    scheduledFor?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrder
    bookingId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    sent?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    scheduledFor?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrder
    bookingId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    sent?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    scheduledFor?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type SystemSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoteCreateNestedManyWithoutAuthorInput = {
    create?: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput> | NoteCreateWithoutAuthorInput[] | NoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutAuthorInput | NoteCreateOrConnectWithoutAuthorInput[]
    createMany?: NoteCreateManyAuthorInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutProfessionalInput = {
    create?: XOR<AssignmentCreateWithoutProfessionalInput, AssignmentUncheckedCreateWithoutProfessionalInput> | AssignmentCreateWithoutProfessionalInput[] | AssignmentUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutProfessionalInput | AssignmentCreateOrConnectWithoutProfessionalInput[]
    createMany?: AssignmentCreateManyProfessionalInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutProfessionalInput = {
    create?: XOR<ReviewCreateWithoutProfessionalInput, ReviewUncheckedCreateWithoutProfessionalInput> | ReviewCreateWithoutProfessionalInput[] | ReviewUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProfessionalInput | ReviewCreateOrConnectWithoutProfessionalInput[]
    createMany?: ReviewCreateManyProfessionalInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutProfessionalInput = {
    create?: XOR<BookingCreateWithoutProfessionalInput, BookingUncheckedCreateWithoutProfessionalInput> | BookingCreateWithoutProfessionalInput[] | BookingUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutProfessionalInput | BookingCreateOrConnectWithoutProfessionalInput[]
    createMany?: BookingCreateManyProfessionalInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BookingCreateWithoutCreatedByInput, BookingUncheckedCreateWithoutCreatedByInput> | BookingCreateWithoutCreatedByInput[] | BookingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCreatedByInput | BookingCreateOrConnectWithoutCreatedByInput[]
    createMany?: BookingCreateManyCreatedByInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type AvailabilityCreateNestedManyWithoutProfessionalInput = {
    create?: XOR<AvailabilityCreateWithoutProfessionalInput, AvailabilityUncheckedCreateWithoutProfessionalInput> | AvailabilityCreateWithoutProfessionalInput[] | AvailabilityUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutProfessionalInput | AvailabilityCreateOrConnectWithoutProfessionalInput[]
    createMany?: AvailabilityCreateManyProfessionalInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type WorkingScheduleCreateNestedManyWithoutProfessionalInput = {
    create?: XOR<WorkingScheduleCreateWithoutProfessionalInput, WorkingScheduleUncheckedCreateWithoutProfessionalInput> | WorkingScheduleCreateWithoutProfessionalInput[] | WorkingScheduleUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: WorkingScheduleCreateOrConnectWithoutProfessionalInput | WorkingScheduleCreateOrConnectWithoutProfessionalInput[]
    createMany?: WorkingScheduleCreateManyProfessionalInputEnvelope
    connect?: WorkingScheduleWhereUniqueInput | WorkingScheduleWhereUniqueInput[]
  }

  export type BreakPeriodCreateNestedManyWithoutProfessionalInput = {
    create?: XOR<BreakPeriodCreateWithoutProfessionalInput, BreakPeriodUncheckedCreateWithoutProfessionalInput> | BreakPeriodCreateWithoutProfessionalInput[] | BreakPeriodUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: BreakPeriodCreateOrConnectWithoutProfessionalInput | BreakPeriodCreateOrConnectWithoutProfessionalInput[]
    createMany?: BreakPeriodCreateManyProfessionalInputEnvelope
    connect?: BreakPeriodWhereUniqueInput | BreakPeriodWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput> | NoteCreateWithoutAuthorInput[] | NoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutAuthorInput | NoteCreateOrConnectWithoutAuthorInput[]
    createMany?: NoteCreateManyAuthorInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutProfessionalInput = {
    create?: XOR<AssignmentCreateWithoutProfessionalInput, AssignmentUncheckedCreateWithoutProfessionalInput> | AssignmentCreateWithoutProfessionalInput[] | AssignmentUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutProfessionalInput | AssignmentCreateOrConnectWithoutProfessionalInput[]
    createMany?: AssignmentCreateManyProfessionalInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutProfessionalInput = {
    create?: XOR<ReviewCreateWithoutProfessionalInput, ReviewUncheckedCreateWithoutProfessionalInput> | ReviewCreateWithoutProfessionalInput[] | ReviewUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProfessionalInput | ReviewCreateOrConnectWithoutProfessionalInput[]
    createMany?: ReviewCreateManyProfessionalInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutProfessionalInput = {
    create?: XOR<BookingCreateWithoutProfessionalInput, BookingUncheckedCreateWithoutProfessionalInput> | BookingCreateWithoutProfessionalInput[] | BookingUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutProfessionalInput | BookingCreateOrConnectWithoutProfessionalInput[]
    createMany?: BookingCreateManyProfessionalInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BookingCreateWithoutCreatedByInput, BookingUncheckedCreateWithoutCreatedByInput> | BookingCreateWithoutCreatedByInput[] | BookingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCreatedByInput | BookingCreateOrConnectWithoutCreatedByInput[]
    createMany?: BookingCreateManyCreatedByInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type AvailabilityUncheckedCreateNestedManyWithoutProfessionalInput = {
    create?: XOR<AvailabilityCreateWithoutProfessionalInput, AvailabilityUncheckedCreateWithoutProfessionalInput> | AvailabilityCreateWithoutProfessionalInput[] | AvailabilityUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutProfessionalInput | AvailabilityCreateOrConnectWithoutProfessionalInput[]
    createMany?: AvailabilityCreateManyProfessionalInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type WorkingScheduleUncheckedCreateNestedManyWithoutProfessionalInput = {
    create?: XOR<WorkingScheduleCreateWithoutProfessionalInput, WorkingScheduleUncheckedCreateWithoutProfessionalInput> | WorkingScheduleCreateWithoutProfessionalInput[] | WorkingScheduleUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: WorkingScheduleCreateOrConnectWithoutProfessionalInput | WorkingScheduleCreateOrConnectWithoutProfessionalInput[]
    createMany?: WorkingScheduleCreateManyProfessionalInputEnvelope
    connect?: WorkingScheduleWhereUniqueInput | WorkingScheduleWhereUniqueInput[]
  }

  export type BreakPeriodUncheckedCreateNestedManyWithoutProfessionalInput = {
    create?: XOR<BreakPeriodCreateWithoutProfessionalInput, BreakPeriodUncheckedCreateWithoutProfessionalInput> | BreakPeriodCreateWithoutProfessionalInput[] | BreakPeriodUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: BreakPeriodCreateOrConnectWithoutProfessionalInput | BreakPeriodCreateOrConnectWithoutProfessionalInput[]
    createMany?: BreakPeriodCreateManyProfessionalInputEnvelope
    connect?: BreakPeriodWhereUniqueInput | BreakPeriodWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NoteUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput> | NoteCreateWithoutAuthorInput[] | NoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutAuthorInput | NoteCreateOrConnectWithoutAuthorInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutAuthorInput | NoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: NoteCreateManyAuthorInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutAuthorInput | NoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutAuthorInput | NoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutProfessionalNestedInput = {
    create?: XOR<AssignmentCreateWithoutProfessionalInput, AssignmentUncheckedCreateWithoutProfessionalInput> | AssignmentCreateWithoutProfessionalInput[] | AssignmentUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutProfessionalInput | AssignmentCreateOrConnectWithoutProfessionalInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutProfessionalInput | AssignmentUpsertWithWhereUniqueWithoutProfessionalInput[]
    createMany?: AssignmentCreateManyProfessionalInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutProfessionalInput | AssignmentUpdateWithWhereUniqueWithoutProfessionalInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutProfessionalInput | AssignmentUpdateManyWithWhereWithoutProfessionalInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutProfessionalNestedInput = {
    create?: XOR<ReviewCreateWithoutProfessionalInput, ReviewUncheckedCreateWithoutProfessionalInput> | ReviewCreateWithoutProfessionalInput[] | ReviewUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProfessionalInput | ReviewCreateOrConnectWithoutProfessionalInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProfessionalInput | ReviewUpsertWithWhereUniqueWithoutProfessionalInput[]
    createMany?: ReviewCreateManyProfessionalInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProfessionalInput | ReviewUpdateWithWhereUniqueWithoutProfessionalInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProfessionalInput | ReviewUpdateManyWithWhereWithoutProfessionalInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutProfessionalNestedInput = {
    create?: XOR<BookingCreateWithoutProfessionalInput, BookingUncheckedCreateWithoutProfessionalInput> | BookingCreateWithoutProfessionalInput[] | BookingUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutProfessionalInput | BookingCreateOrConnectWithoutProfessionalInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutProfessionalInput | BookingUpsertWithWhereUniqueWithoutProfessionalInput[]
    createMany?: BookingCreateManyProfessionalInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutProfessionalInput | BookingUpdateWithWhereUniqueWithoutProfessionalInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutProfessionalInput | BookingUpdateManyWithWhereWithoutProfessionalInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BookingCreateWithoutCreatedByInput, BookingUncheckedCreateWithoutCreatedByInput> | BookingCreateWithoutCreatedByInput[] | BookingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCreatedByInput | BookingCreateOrConnectWithoutCreatedByInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutCreatedByInput | BookingUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BookingCreateManyCreatedByInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutCreatedByInput | BookingUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutCreatedByInput | BookingUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type AvailabilityUpdateManyWithoutProfessionalNestedInput = {
    create?: XOR<AvailabilityCreateWithoutProfessionalInput, AvailabilityUncheckedCreateWithoutProfessionalInput> | AvailabilityCreateWithoutProfessionalInput[] | AvailabilityUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutProfessionalInput | AvailabilityCreateOrConnectWithoutProfessionalInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutProfessionalInput | AvailabilityUpsertWithWhereUniqueWithoutProfessionalInput[]
    createMany?: AvailabilityCreateManyProfessionalInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutProfessionalInput | AvailabilityUpdateWithWhereUniqueWithoutProfessionalInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutProfessionalInput | AvailabilityUpdateManyWithWhereWithoutProfessionalInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type WorkingScheduleUpdateManyWithoutProfessionalNestedInput = {
    create?: XOR<WorkingScheduleCreateWithoutProfessionalInput, WorkingScheduleUncheckedCreateWithoutProfessionalInput> | WorkingScheduleCreateWithoutProfessionalInput[] | WorkingScheduleUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: WorkingScheduleCreateOrConnectWithoutProfessionalInput | WorkingScheduleCreateOrConnectWithoutProfessionalInput[]
    upsert?: WorkingScheduleUpsertWithWhereUniqueWithoutProfessionalInput | WorkingScheduleUpsertWithWhereUniqueWithoutProfessionalInput[]
    createMany?: WorkingScheduleCreateManyProfessionalInputEnvelope
    set?: WorkingScheduleWhereUniqueInput | WorkingScheduleWhereUniqueInput[]
    disconnect?: WorkingScheduleWhereUniqueInput | WorkingScheduleWhereUniqueInput[]
    delete?: WorkingScheduleWhereUniqueInput | WorkingScheduleWhereUniqueInput[]
    connect?: WorkingScheduleWhereUniqueInput | WorkingScheduleWhereUniqueInput[]
    update?: WorkingScheduleUpdateWithWhereUniqueWithoutProfessionalInput | WorkingScheduleUpdateWithWhereUniqueWithoutProfessionalInput[]
    updateMany?: WorkingScheduleUpdateManyWithWhereWithoutProfessionalInput | WorkingScheduleUpdateManyWithWhereWithoutProfessionalInput[]
    deleteMany?: WorkingScheduleScalarWhereInput | WorkingScheduleScalarWhereInput[]
  }

  export type BreakPeriodUpdateManyWithoutProfessionalNestedInput = {
    create?: XOR<BreakPeriodCreateWithoutProfessionalInput, BreakPeriodUncheckedCreateWithoutProfessionalInput> | BreakPeriodCreateWithoutProfessionalInput[] | BreakPeriodUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: BreakPeriodCreateOrConnectWithoutProfessionalInput | BreakPeriodCreateOrConnectWithoutProfessionalInput[]
    upsert?: BreakPeriodUpsertWithWhereUniqueWithoutProfessionalInput | BreakPeriodUpsertWithWhereUniqueWithoutProfessionalInput[]
    createMany?: BreakPeriodCreateManyProfessionalInputEnvelope
    set?: BreakPeriodWhereUniqueInput | BreakPeriodWhereUniqueInput[]
    disconnect?: BreakPeriodWhereUniqueInput | BreakPeriodWhereUniqueInput[]
    delete?: BreakPeriodWhereUniqueInput | BreakPeriodWhereUniqueInput[]
    connect?: BreakPeriodWhereUniqueInput | BreakPeriodWhereUniqueInput[]
    update?: BreakPeriodUpdateWithWhereUniqueWithoutProfessionalInput | BreakPeriodUpdateWithWhereUniqueWithoutProfessionalInput[]
    updateMany?: BreakPeriodUpdateManyWithWhereWithoutProfessionalInput | BreakPeriodUpdateManyWithWhereWithoutProfessionalInput[]
    deleteMany?: BreakPeriodScalarWhereInput | BreakPeriodScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput> | NoteCreateWithoutAuthorInput[] | NoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutAuthorInput | NoteCreateOrConnectWithoutAuthorInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutAuthorInput | NoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: NoteCreateManyAuthorInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutAuthorInput | NoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutAuthorInput | NoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutProfessionalNestedInput = {
    create?: XOR<AssignmentCreateWithoutProfessionalInput, AssignmentUncheckedCreateWithoutProfessionalInput> | AssignmentCreateWithoutProfessionalInput[] | AssignmentUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutProfessionalInput | AssignmentCreateOrConnectWithoutProfessionalInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutProfessionalInput | AssignmentUpsertWithWhereUniqueWithoutProfessionalInput[]
    createMany?: AssignmentCreateManyProfessionalInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutProfessionalInput | AssignmentUpdateWithWhereUniqueWithoutProfessionalInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutProfessionalInput | AssignmentUpdateManyWithWhereWithoutProfessionalInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutProfessionalNestedInput = {
    create?: XOR<ReviewCreateWithoutProfessionalInput, ReviewUncheckedCreateWithoutProfessionalInput> | ReviewCreateWithoutProfessionalInput[] | ReviewUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProfessionalInput | ReviewCreateOrConnectWithoutProfessionalInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProfessionalInput | ReviewUpsertWithWhereUniqueWithoutProfessionalInput[]
    createMany?: ReviewCreateManyProfessionalInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProfessionalInput | ReviewUpdateWithWhereUniqueWithoutProfessionalInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProfessionalInput | ReviewUpdateManyWithWhereWithoutProfessionalInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutProfessionalNestedInput = {
    create?: XOR<BookingCreateWithoutProfessionalInput, BookingUncheckedCreateWithoutProfessionalInput> | BookingCreateWithoutProfessionalInput[] | BookingUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutProfessionalInput | BookingCreateOrConnectWithoutProfessionalInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutProfessionalInput | BookingUpsertWithWhereUniqueWithoutProfessionalInput[]
    createMany?: BookingCreateManyProfessionalInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutProfessionalInput | BookingUpdateWithWhereUniqueWithoutProfessionalInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutProfessionalInput | BookingUpdateManyWithWhereWithoutProfessionalInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BookingCreateWithoutCreatedByInput, BookingUncheckedCreateWithoutCreatedByInput> | BookingCreateWithoutCreatedByInput[] | BookingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCreatedByInput | BookingCreateOrConnectWithoutCreatedByInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutCreatedByInput | BookingUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BookingCreateManyCreatedByInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutCreatedByInput | BookingUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutCreatedByInput | BookingUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type AvailabilityUncheckedUpdateManyWithoutProfessionalNestedInput = {
    create?: XOR<AvailabilityCreateWithoutProfessionalInput, AvailabilityUncheckedCreateWithoutProfessionalInput> | AvailabilityCreateWithoutProfessionalInput[] | AvailabilityUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutProfessionalInput | AvailabilityCreateOrConnectWithoutProfessionalInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutProfessionalInput | AvailabilityUpsertWithWhereUniqueWithoutProfessionalInput[]
    createMany?: AvailabilityCreateManyProfessionalInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutProfessionalInput | AvailabilityUpdateWithWhereUniqueWithoutProfessionalInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutProfessionalInput | AvailabilityUpdateManyWithWhereWithoutProfessionalInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type WorkingScheduleUncheckedUpdateManyWithoutProfessionalNestedInput = {
    create?: XOR<WorkingScheduleCreateWithoutProfessionalInput, WorkingScheduleUncheckedCreateWithoutProfessionalInput> | WorkingScheduleCreateWithoutProfessionalInput[] | WorkingScheduleUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: WorkingScheduleCreateOrConnectWithoutProfessionalInput | WorkingScheduleCreateOrConnectWithoutProfessionalInput[]
    upsert?: WorkingScheduleUpsertWithWhereUniqueWithoutProfessionalInput | WorkingScheduleUpsertWithWhereUniqueWithoutProfessionalInput[]
    createMany?: WorkingScheduleCreateManyProfessionalInputEnvelope
    set?: WorkingScheduleWhereUniqueInput | WorkingScheduleWhereUniqueInput[]
    disconnect?: WorkingScheduleWhereUniqueInput | WorkingScheduleWhereUniqueInput[]
    delete?: WorkingScheduleWhereUniqueInput | WorkingScheduleWhereUniqueInput[]
    connect?: WorkingScheduleWhereUniqueInput | WorkingScheduleWhereUniqueInput[]
    update?: WorkingScheduleUpdateWithWhereUniqueWithoutProfessionalInput | WorkingScheduleUpdateWithWhereUniqueWithoutProfessionalInput[]
    updateMany?: WorkingScheduleUpdateManyWithWhereWithoutProfessionalInput | WorkingScheduleUpdateManyWithWhereWithoutProfessionalInput[]
    deleteMany?: WorkingScheduleScalarWhereInput | WorkingScheduleScalarWhereInput[]
  }

  export type BreakPeriodUncheckedUpdateManyWithoutProfessionalNestedInput = {
    create?: XOR<BreakPeriodCreateWithoutProfessionalInput, BreakPeriodUncheckedCreateWithoutProfessionalInput> | BreakPeriodCreateWithoutProfessionalInput[] | BreakPeriodUncheckedCreateWithoutProfessionalInput[]
    connectOrCreate?: BreakPeriodCreateOrConnectWithoutProfessionalInput | BreakPeriodCreateOrConnectWithoutProfessionalInput[]
    upsert?: BreakPeriodUpsertWithWhereUniqueWithoutProfessionalInput | BreakPeriodUpsertWithWhereUniqueWithoutProfessionalInput[]
    createMany?: BreakPeriodCreateManyProfessionalInputEnvelope
    set?: BreakPeriodWhereUniqueInput | BreakPeriodWhereUniqueInput[]
    disconnect?: BreakPeriodWhereUniqueInput | BreakPeriodWhereUniqueInput[]
    delete?: BreakPeriodWhereUniqueInput | BreakPeriodWhereUniqueInput[]
    connect?: BreakPeriodWhereUniqueInput | BreakPeriodWhereUniqueInput[]
    update?: BreakPeriodUpdateWithWhereUniqueWithoutProfessionalInput | BreakPeriodUpdateWithWhereUniqueWithoutProfessionalInput[]
    updateMany?: BreakPeriodUpdateManyWithWhereWithoutProfessionalInput | BreakPeriodUpdateManyWithWhereWithoutProfessionalInput[]
    deleteMany?: BreakPeriodScalarWhereInput | BreakPeriodScalarWhereInput[]
  }

  export type ClientProfileCreatezonesDouleurInput = {
    set: string[]
  }

  export type NoteCreateNestedManyWithoutClientInput = {
    create?: XOR<NoteCreateWithoutClientInput, NoteUncheckedCreateWithoutClientInput> | NoteCreateWithoutClientInput[] | NoteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutClientInput | NoteCreateOrConnectWithoutClientInput[]
    createMany?: NoteCreateManyClientInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutClientInput = {
    create?: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput> | AssignmentCreateWithoutClientInput[] | AssignmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientInput | AssignmentCreateOrConnectWithoutClientInput[]
    createMany?: AssignmentCreateManyClientInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<NoteCreateWithoutClientInput, NoteUncheckedCreateWithoutClientInput> | NoteCreateWithoutClientInput[] | NoteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutClientInput | NoteCreateOrConnectWithoutClientInput[]
    createMany?: NoteCreateManyClientInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput> | AssignmentCreateWithoutClientInput[] | AssignmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientInput | AssignmentCreateOrConnectWithoutClientInput[]
    createMany?: AssignmentCreateManyClientInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type EnumServiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ServiceType
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientProfileUpdatezonesDouleurInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NoteUpdateManyWithoutClientNestedInput = {
    create?: XOR<NoteCreateWithoutClientInput, NoteUncheckedCreateWithoutClientInput> | NoteCreateWithoutClientInput[] | NoteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutClientInput | NoteCreateOrConnectWithoutClientInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutClientInput | NoteUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: NoteCreateManyClientInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutClientInput | NoteUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutClientInput | NoteUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutClientNestedInput = {
    create?: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput> | AssignmentCreateWithoutClientInput[] | AssignmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientInput | AssignmentCreateOrConnectWithoutClientInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutClientInput | AssignmentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AssignmentCreateManyClientInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutClientInput | AssignmentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutClientInput | AssignmentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<NoteCreateWithoutClientInput, NoteUncheckedCreateWithoutClientInput> | NoteCreateWithoutClientInput[] | NoteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutClientInput | NoteCreateOrConnectWithoutClientInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutClientInput | NoteUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: NoteCreateManyClientInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutClientInput | NoteUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutClientInput | NoteUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput> | AssignmentCreateWithoutClientInput[] | AssignmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientInput | AssignmentCreateOrConnectWithoutClientInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutClientInput | AssignmentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AssignmentCreateManyClientInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutClientInput | AssignmentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutClientInput | AssignmentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientProfileCreateNestedOneWithoutNotesInput = {
    create?: XOR<ClientProfileCreateWithoutNotesInput, ClientProfileUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutNotesInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotesCreatedInput = {
    create?: XOR<UserCreateWithoutNotesCreatedInput, UserUncheckedCreateWithoutNotesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type ClientProfileUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<ClientProfileCreateWithoutNotesInput, ClientProfileUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutNotesInput
    upsert?: ClientProfileUpsertWithoutNotesInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutNotesInput, ClientProfileUpdateWithoutNotesInput>, ClientProfileUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateOneRequiredWithoutNotesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutNotesCreatedInput, UserUncheckedCreateWithoutNotesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesCreatedInput
    upsert?: UserUpsertWithoutNotesCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotesCreatedInput, UserUpdateWithoutNotesCreatedInput>, UserUncheckedUpdateWithoutNotesCreatedInput>
  }

  export type ClientProfileCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ClientProfileCreateWithoutAssignmentsInput, ClientProfileUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutAssignmentsInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedClientsInput = {
    create?: XOR<UserCreateWithoutAssignedClientsInput, UserUncheckedCreateWithoutAssignedClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedClientsInput
    connect?: UserWhereUniqueInput
  }

  export type ClientProfileUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ClientProfileCreateWithoutAssignmentsInput, ClientProfileUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutAssignmentsInput
    upsert?: ClientProfileUpsertWithoutAssignmentsInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutAssignmentsInput, ClientProfileUpdateWithoutAssignmentsInput>, ClientProfileUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutAssignedClientsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedClientsInput, UserUncheckedCreateWithoutAssignedClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedClientsInput
    upsert?: UserUpsertWithoutAssignedClientsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedClientsInput, UserUpdateWithoutAssignedClientsInput>, UserUncheckedUpdateWithoutAssignedClientsInput>
  }

  export type UserCreateNestedOneWithoutReviewsReceivedInput = {
    create?: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsReceivedInput
    upsert?: UserUpsertWithoutReviewsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsReceivedInput, UserUpdateWithoutReviewsReceivedInput>, UserUncheckedUpdateWithoutReviewsReceivedInput>
  }

  export type ServiceCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCategoryInput | ServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCategoryInput | ServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCategoryInput | ServiceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCategoryInput | ServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCategoryInput | ServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCategoryInput | ServiceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceCategoryCreateNestedOneWithoutServicesInput = {
    create?: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutServicesInput
    connect?: ServiceCategoryWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PackageServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<PackageServiceCreateWithoutServiceInput, PackageServiceUncheckedCreateWithoutServiceInput> | PackageServiceCreateWithoutServiceInput[] | PackageServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PackageServiceCreateOrConnectWithoutServiceInput | PackageServiceCreateOrConnectWithoutServiceInput[]
    createMany?: PackageServiceCreateManyServiceInputEnvelope
    connect?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
  }

  export type ServicePromotionCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServicePromotionCreateWithoutServiceInput, ServicePromotionUncheckedCreateWithoutServiceInput> | ServicePromotionCreateWithoutServiceInput[] | ServicePromotionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePromotionCreateOrConnectWithoutServiceInput | ServicePromotionCreateOrConnectWithoutServiceInput[]
    createMany?: ServicePromotionCreateManyServiceInputEnvelope
    connect?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PackageServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<PackageServiceCreateWithoutServiceInput, PackageServiceUncheckedCreateWithoutServiceInput> | PackageServiceCreateWithoutServiceInput[] | PackageServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PackageServiceCreateOrConnectWithoutServiceInput | PackageServiceCreateOrConnectWithoutServiceInput[]
    createMany?: PackageServiceCreateManyServiceInputEnvelope
    connect?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
  }

  export type ServicePromotionUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServicePromotionCreateWithoutServiceInput, ServicePromotionUncheckedCreateWithoutServiceInput> | ServicePromotionCreateWithoutServiceInput[] | ServicePromotionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePromotionCreateOrConnectWithoutServiceInput | ServicePromotionCreateOrConnectWithoutServiceInput[]
    createMany?: ServicePromotionCreateManyServiceInputEnvelope
    connect?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceCategoryCreateOrConnectWithoutServicesInput
    upsert?: ServiceCategoryUpsertWithoutServicesInput
    connect?: ServiceCategoryWhereUniqueInput
    update?: XOR<XOR<ServiceCategoryUpdateToOneWithWhereWithoutServicesInput, ServiceCategoryUpdateWithoutServicesInput>, ServiceCategoryUncheckedUpdateWithoutServicesInput>
  }

  export type BookingUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceInput | BookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceInput | BookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceInput | BookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PackageServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<PackageServiceCreateWithoutServiceInput, PackageServiceUncheckedCreateWithoutServiceInput> | PackageServiceCreateWithoutServiceInput[] | PackageServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PackageServiceCreateOrConnectWithoutServiceInput | PackageServiceCreateOrConnectWithoutServiceInput[]
    upsert?: PackageServiceUpsertWithWhereUniqueWithoutServiceInput | PackageServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: PackageServiceCreateManyServiceInputEnvelope
    set?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    disconnect?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    delete?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    connect?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    update?: PackageServiceUpdateWithWhereUniqueWithoutServiceInput | PackageServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: PackageServiceUpdateManyWithWhereWithoutServiceInput | PackageServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: PackageServiceScalarWhereInput | PackageServiceScalarWhereInput[]
  }

  export type ServicePromotionUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServicePromotionCreateWithoutServiceInput, ServicePromotionUncheckedCreateWithoutServiceInput> | ServicePromotionCreateWithoutServiceInput[] | ServicePromotionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePromotionCreateOrConnectWithoutServiceInput | ServicePromotionCreateOrConnectWithoutServiceInput[]
    upsert?: ServicePromotionUpsertWithWhereUniqueWithoutServiceInput | ServicePromotionUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServicePromotionCreateManyServiceInputEnvelope
    set?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    disconnect?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    delete?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    connect?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    update?: ServicePromotionUpdateWithWhereUniqueWithoutServiceInput | ServicePromotionUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServicePromotionUpdateManyWithWhereWithoutServiceInput | ServicePromotionUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServicePromotionScalarWhereInput | ServicePromotionScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceInput | BookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceInput | BookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceInput | BookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PackageServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<PackageServiceCreateWithoutServiceInput, PackageServiceUncheckedCreateWithoutServiceInput> | PackageServiceCreateWithoutServiceInput[] | PackageServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PackageServiceCreateOrConnectWithoutServiceInput | PackageServiceCreateOrConnectWithoutServiceInput[]
    upsert?: PackageServiceUpsertWithWhereUniqueWithoutServiceInput | PackageServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: PackageServiceCreateManyServiceInputEnvelope
    set?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    disconnect?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    delete?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    connect?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    update?: PackageServiceUpdateWithWhereUniqueWithoutServiceInput | PackageServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: PackageServiceUpdateManyWithWhereWithoutServiceInput | PackageServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: PackageServiceScalarWhereInput | PackageServiceScalarWhereInput[]
  }

  export type ServicePromotionUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServicePromotionCreateWithoutServiceInput, ServicePromotionUncheckedCreateWithoutServiceInput> | ServicePromotionCreateWithoutServiceInput[] | ServicePromotionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePromotionCreateOrConnectWithoutServiceInput | ServicePromotionCreateOrConnectWithoutServiceInput[]
    upsert?: ServicePromotionUpsertWithWhereUniqueWithoutServiceInput | ServicePromotionUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServicePromotionCreateManyServiceInputEnvelope
    set?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    disconnect?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    delete?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    connect?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    update?: ServicePromotionUpdateWithWhereUniqueWithoutServiceInput | ServicePromotionUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServicePromotionUpdateManyWithWhereWithoutServiceInput | ServicePromotionUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServicePromotionScalarWhereInput | ServicePromotionScalarWhereInput[]
  }

  export type PackageServiceCreateNestedManyWithoutPackageInput = {
    create?: XOR<PackageServiceCreateWithoutPackageInput, PackageServiceUncheckedCreateWithoutPackageInput> | PackageServiceCreateWithoutPackageInput[] | PackageServiceUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageServiceCreateOrConnectWithoutPackageInput | PackageServiceCreateOrConnectWithoutPackageInput[]
    createMany?: PackageServiceCreateManyPackageInputEnvelope
    connect?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutPackageInput = {
    create?: XOR<BookingCreateWithoutPackageInput, BookingUncheckedCreateWithoutPackageInput> | BookingCreateWithoutPackageInput[] | BookingUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPackageInput | BookingCreateOrConnectWithoutPackageInput[]
    createMany?: BookingCreateManyPackageInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PackagePromotionCreateNestedManyWithoutPackageInput = {
    create?: XOR<PackagePromotionCreateWithoutPackageInput, PackagePromotionUncheckedCreateWithoutPackageInput> | PackagePromotionCreateWithoutPackageInput[] | PackagePromotionUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackagePromotionCreateOrConnectWithoutPackageInput | PackagePromotionCreateOrConnectWithoutPackageInput[]
    createMany?: PackagePromotionCreateManyPackageInputEnvelope
    connect?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
  }

  export type PackageServiceUncheckedCreateNestedManyWithoutPackageInput = {
    create?: XOR<PackageServiceCreateWithoutPackageInput, PackageServiceUncheckedCreateWithoutPackageInput> | PackageServiceCreateWithoutPackageInput[] | PackageServiceUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageServiceCreateOrConnectWithoutPackageInput | PackageServiceCreateOrConnectWithoutPackageInput[]
    createMany?: PackageServiceCreateManyPackageInputEnvelope
    connect?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutPackageInput = {
    create?: XOR<BookingCreateWithoutPackageInput, BookingUncheckedCreateWithoutPackageInput> | BookingCreateWithoutPackageInput[] | BookingUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPackageInput | BookingCreateOrConnectWithoutPackageInput[]
    createMany?: BookingCreateManyPackageInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PackagePromotionUncheckedCreateNestedManyWithoutPackageInput = {
    create?: XOR<PackagePromotionCreateWithoutPackageInput, PackagePromotionUncheckedCreateWithoutPackageInput> | PackagePromotionCreateWithoutPackageInput[] | PackagePromotionUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackagePromotionCreateOrConnectWithoutPackageInput | PackagePromotionCreateOrConnectWithoutPackageInput[]
    createMany?: PackagePromotionCreateManyPackageInputEnvelope
    connect?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PackageServiceUpdateManyWithoutPackageNestedInput = {
    create?: XOR<PackageServiceCreateWithoutPackageInput, PackageServiceUncheckedCreateWithoutPackageInput> | PackageServiceCreateWithoutPackageInput[] | PackageServiceUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageServiceCreateOrConnectWithoutPackageInput | PackageServiceCreateOrConnectWithoutPackageInput[]
    upsert?: PackageServiceUpsertWithWhereUniqueWithoutPackageInput | PackageServiceUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: PackageServiceCreateManyPackageInputEnvelope
    set?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    disconnect?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    delete?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    connect?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    update?: PackageServiceUpdateWithWhereUniqueWithoutPackageInput | PackageServiceUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: PackageServiceUpdateManyWithWhereWithoutPackageInput | PackageServiceUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: PackageServiceScalarWhereInput | PackageServiceScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutPackageNestedInput = {
    create?: XOR<BookingCreateWithoutPackageInput, BookingUncheckedCreateWithoutPackageInput> | BookingCreateWithoutPackageInput[] | BookingUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPackageInput | BookingCreateOrConnectWithoutPackageInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPackageInput | BookingUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: BookingCreateManyPackageInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPackageInput | BookingUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPackageInput | BookingUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PackagePromotionUpdateManyWithoutPackageNestedInput = {
    create?: XOR<PackagePromotionCreateWithoutPackageInput, PackagePromotionUncheckedCreateWithoutPackageInput> | PackagePromotionCreateWithoutPackageInput[] | PackagePromotionUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackagePromotionCreateOrConnectWithoutPackageInput | PackagePromotionCreateOrConnectWithoutPackageInput[]
    upsert?: PackagePromotionUpsertWithWhereUniqueWithoutPackageInput | PackagePromotionUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: PackagePromotionCreateManyPackageInputEnvelope
    set?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    disconnect?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    delete?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    connect?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    update?: PackagePromotionUpdateWithWhereUniqueWithoutPackageInput | PackagePromotionUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: PackagePromotionUpdateManyWithWhereWithoutPackageInput | PackagePromotionUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: PackagePromotionScalarWhereInput | PackagePromotionScalarWhereInput[]
  }

  export type PackageServiceUncheckedUpdateManyWithoutPackageNestedInput = {
    create?: XOR<PackageServiceCreateWithoutPackageInput, PackageServiceUncheckedCreateWithoutPackageInput> | PackageServiceCreateWithoutPackageInput[] | PackageServiceUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageServiceCreateOrConnectWithoutPackageInput | PackageServiceCreateOrConnectWithoutPackageInput[]
    upsert?: PackageServiceUpsertWithWhereUniqueWithoutPackageInput | PackageServiceUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: PackageServiceCreateManyPackageInputEnvelope
    set?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    disconnect?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    delete?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    connect?: PackageServiceWhereUniqueInput | PackageServiceWhereUniqueInput[]
    update?: PackageServiceUpdateWithWhereUniqueWithoutPackageInput | PackageServiceUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: PackageServiceUpdateManyWithWhereWithoutPackageInput | PackageServiceUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: PackageServiceScalarWhereInput | PackageServiceScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutPackageNestedInput = {
    create?: XOR<BookingCreateWithoutPackageInput, BookingUncheckedCreateWithoutPackageInput> | BookingCreateWithoutPackageInput[] | BookingUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPackageInput | BookingCreateOrConnectWithoutPackageInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPackageInput | BookingUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: BookingCreateManyPackageInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPackageInput | BookingUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPackageInput | BookingUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PackagePromotionUncheckedUpdateManyWithoutPackageNestedInput = {
    create?: XOR<PackagePromotionCreateWithoutPackageInput, PackagePromotionUncheckedCreateWithoutPackageInput> | PackagePromotionCreateWithoutPackageInput[] | PackagePromotionUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackagePromotionCreateOrConnectWithoutPackageInput | PackagePromotionCreateOrConnectWithoutPackageInput[]
    upsert?: PackagePromotionUpsertWithWhereUniqueWithoutPackageInput | PackagePromotionUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: PackagePromotionCreateManyPackageInputEnvelope
    set?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    disconnect?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    delete?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    connect?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    update?: PackagePromotionUpdateWithWhereUniqueWithoutPackageInput | PackagePromotionUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: PackagePromotionUpdateManyWithWhereWithoutPackageInput | PackagePromotionUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: PackagePromotionScalarWhereInput | PackagePromotionScalarWhereInput[]
  }

  export type PackageCreateNestedOneWithoutServicesInput = {
    create?: XOR<PackageCreateWithoutServicesInput, PackageUncheckedCreateWithoutServicesInput>
    connectOrCreate?: PackageCreateOrConnectWithoutServicesInput
    connect?: PackageWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutPackageServicesInput = {
    create?: XOR<ServiceCreateWithoutPackageServicesInput, ServiceUncheckedCreateWithoutPackageServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPackageServicesInput
    connect?: ServiceWhereUniqueInput
  }

  export type PackageUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<PackageCreateWithoutServicesInput, PackageUncheckedCreateWithoutServicesInput>
    connectOrCreate?: PackageCreateOrConnectWithoutServicesInput
    upsert?: PackageUpsertWithoutServicesInput
    connect?: PackageWhereUniqueInput
    update?: XOR<XOR<PackageUpdateToOneWithWhereWithoutServicesInput, PackageUpdateWithoutServicesInput>, PackageUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutPackageServicesNestedInput = {
    create?: XOR<ServiceCreateWithoutPackageServicesInput, ServiceUncheckedCreateWithoutPackageServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPackageServicesInput
    upsert?: ServiceUpsertWithoutPackageServicesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutPackageServicesInput, ServiceUpdateWithoutPackageServicesInput>, ServiceUncheckedUpdateWithoutPackageServicesInput>
  }

  export type BookingCreateNestedOneWithoutPaymentInput = {
    create?: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentInput
    connect?: BookingWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutPaymentInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput
    connect?: OrderWhereUniqueInput
  }

  export type GiftCardCreateNestedOneWithoutPaymentInput = {
    create?: XOR<GiftCardCreateWithoutPaymentInput, GiftCardUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: GiftCardCreateOrConnectWithoutPaymentInput
    connect?: GiftCardWhereUniqueInput
  }

  export type GymSubscriptionCreateNestedOneWithoutPaymentInput = {
    create?: XOR<GymSubscriptionCreateWithoutPaymentInput, GymSubscriptionUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: GymSubscriptionCreateOrConnectWithoutPaymentInput
    connect?: GymSubscriptionWhereUniqueInput
  }

  export type BookingUncheckedCreateNestedOneWithoutPaymentInput = {
    create?: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentInput
    connect?: BookingWhereUniqueInput
  }

  export type OrderUncheckedCreateNestedOneWithoutPaymentInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput
    connect?: OrderWhereUniqueInput
  }

  export type GiftCardUncheckedCreateNestedOneWithoutPaymentInput = {
    create?: XOR<GiftCardCreateWithoutPaymentInput, GiftCardUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: GiftCardCreateOrConnectWithoutPaymentInput
    connect?: GiftCardWhereUniqueInput
  }

  export type GymSubscriptionUncheckedCreateNestedOneWithoutPaymentInput = {
    create?: XOR<GymSubscriptionCreateWithoutPaymentInput, GymSubscriptionUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: GymSubscriptionCreateOrConnectWithoutPaymentInput
    connect?: GymSubscriptionWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type BookingUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentInput
    upsert?: BookingUpsertWithoutPaymentInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentInput, BookingUpdateWithoutPaymentInput>, BookingUncheckedUpdateWithoutPaymentInput>
  }

  export type OrderUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput
    upsert?: OrderUpsertWithoutPaymentInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentInput, OrderUpdateWithoutPaymentInput>, OrderUncheckedUpdateWithoutPaymentInput>
  }

  export type GiftCardUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<GiftCardCreateWithoutPaymentInput, GiftCardUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: GiftCardCreateOrConnectWithoutPaymentInput
    upsert?: GiftCardUpsertWithoutPaymentInput
    disconnect?: GiftCardWhereInput | boolean
    delete?: GiftCardWhereInput | boolean
    connect?: GiftCardWhereUniqueInput
    update?: XOR<XOR<GiftCardUpdateToOneWithWhereWithoutPaymentInput, GiftCardUpdateWithoutPaymentInput>, GiftCardUncheckedUpdateWithoutPaymentInput>
  }

  export type GymSubscriptionUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<GymSubscriptionCreateWithoutPaymentInput, GymSubscriptionUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: GymSubscriptionCreateOrConnectWithoutPaymentInput
    upsert?: GymSubscriptionUpsertWithoutPaymentInput
    disconnect?: GymSubscriptionWhereInput | boolean
    delete?: GymSubscriptionWhereInput | boolean
    connect?: GymSubscriptionWhereUniqueInput
    update?: XOR<XOR<GymSubscriptionUpdateToOneWithWhereWithoutPaymentInput, GymSubscriptionUpdateWithoutPaymentInput>, GymSubscriptionUncheckedUpdateWithoutPaymentInput>
  }

  export type BookingUncheckedUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentInput
    upsert?: BookingUpsertWithoutPaymentInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentInput, BookingUpdateWithoutPaymentInput>, BookingUncheckedUpdateWithoutPaymentInput>
  }

  export type OrderUncheckedUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput
    upsert?: OrderUpsertWithoutPaymentInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentInput, OrderUpdateWithoutPaymentInput>, OrderUncheckedUpdateWithoutPaymentInput>
  }

  export type GiftCardUncheckedUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<GiftCardCreateWithoutPaymentInput, GiftCardUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: GiftCardCreateOrConnectWithoutPaymentInput
    upsert?: GiftCardUpsertWithoutPaymentInput
    disconnect?: GiftCardWhereInput | boolean
    delete?: GiftCardWhereInput | boolean
    connect?: GiftCardWhereUniqueInput
    update?: XOR<XOR<GiftCardUpdateToOneWithWhereWithoutPaymentInput, GiftCardUpdateWithoutPaymentInput>, GiftCardUncheckedUpdateWithoutPaymentInput>
  }

  export type GymSubscriptionUncheckedUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<GymSubscriptionCreateWithoutPaymentInput, GymSubscriptionUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: GymSubscriptionCreateOrConnectWithoutPaymentInput
    upsert?: GymSubscriptionUpsertWithoutPaymentInput
    disconnect?: GymSubscriptionWhereInput | boolean
    delete?: GymSubscriptionWhereInput | boolean
    connect?: GymSubscriptionWhereUniqueInput
    update?: XOR<XOR<GymSubscriptionUpdateToOneWithWhereWithoutPaymentInput, GymSubscriptionUpdateWithoutPaymentInput>, GymSubscriptionUncheckedUpdateWithoutPaymentInput>
  }

  export type ServiceCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
  }

  export type PackageCreateNestedOneWithoutBookingsInput = {
    create?: XOR<PackageCreateWithoutBookingsInput, PackageUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PackageCreateOrConnectWithoutBookingsInput
    connect?: PackageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsAsProfessionalInput = {
    create?: XOR<UserCreateWithoutBookingsAsProfessionalInput, UserUncheckedCreateWithoutBookingsAsProfessionalInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsAsProfessionalInput
    connect?: UserWhereUniqueInput
  }

  export type GiftCardCreateNestedOneWithoutUsedInBookingsInput = {
    create?: XOR<GiftCardCreateWithoutUsedInBookingsInput, GiftCardUncheckedCreateWithoutUsedInBookingsInput>
    connectOrCreate?: GiftCardCreateOrConnectWithoutUsedInBookingsInput
    connect?: GiftCardWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput
    connect?: PaymentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsCreatedInput = {
    create?: XOR<UserCreateWithoutBookingsCreatedInput, UserUncheckedCreateWithoutBookingsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type BookingStatusHistoryCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingStatusHistoryCreateWithoutBookingInput, BookingStatusHistoryUncheckedCreateWithoutBookingInput> | BookingStatusHistoryCreateWithoutBookingInput[] | BookingStatusHistoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingStatusHistoryCreateOrConnectWithoutBookingInput | BookingStatusHistoryCreateOrConnectWithoutBookingInput[]
    createMany?: BookingStatusHistoryCreateManyBookingInputEnvelope
    connect?: BookingStatusHistoryWhereUniqueInput | BookingStatusHistoryWhereUniqueInput[]
  }

  export type BookingStatusHistoryUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingStatusHistoryCreateWithoutBookingInput, BookingStatusHistoryUncheckedCreateWithoutBookingInput> | BookingStatusHistoryCreateWithoutBookingInput[] | BookingStatusHistoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingStatusHistoryCreateOrConnectWithoutBookingInput | BookingStatusHistoryCreateOrConnectWithoutBookingInput[]
    createMany?: BookingStatusHistoryCreateManyBookingInputEnvelope
    connect?: BookingStatusHistoryWhereUniqueInput | BookingStatusHistoryWhereUniqueInput[]
  }

  export type EnumBookingTypeFieldUpdateOperationsInput = {
    set?: $Enums.BookingType
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type ServiceUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    upsert?: ServiceUpsertWithoutBookingsInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBookingsInput, ServiceUpdateWithoutBookingsInput>, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type PackageUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<PackageCreateWithoutBookingsInput, PackageUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PackageCreateOrConnectWithoutBookingsInput
    upsert?: PackageUpsertWithoutBookingsInput
    disconnect?: PackageWhereInput | boolean
    delete?: PackageWhereInput | boolean
    connect?: PackageWhereUniqueInput
    update?: XOR<XOR<PackageUpdateToOneWithWhereWithoutBookingsInput, PackageUpdateWithoutBookingsInput>, PackageUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneWithoutBookingsAsProfessionalNestedInput = {
    create?: XOR<UserCreateWithoutBookingsAsProfessionalInput, UserUncheckedCreateWithoutBookingsAsProfessionalInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsAsProfessionalInput
    upsert?: UserUpsertWithoutBookingsAsProfessionalInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsAsProfessionalInput, UserUpdateWithoutBookingsAsProfessionalInput>, UserUncheckedUpdateWithoutBookingsAsProfessionalInput>
  }

  export type GiftCardUpdateOneWithoutUsedInBookingsNestedInput = {
    create?: XOR<GiftCardCreateWithoutUsedInBookingsInput, GiftCardUncheckedCreateWithoutUsedInBookingsInput>
    connectOrCreate?: GiftCardCreateOrConnectWithoutUsedInBookingsInput
    upsert?: GiftCardUpsertWithoutUsedInBookingsInput
    disconnect?: GiftCardWhereInput | boolean
    delete?: GiftCardWhereInput | boolean
    connect?: GiftCardWhereUniqueInput
    update?: XOR<XOR<GiftCardUpdateToOneWithWhereWithoutUsedInBookingsInput, GiftCardUpdateWithoutUsedInBookingsInput>, GiftCardUncheckedUpdateWithoutUsedInBookingsInput>
  }

  export type PaymentUpdateOneRequiredWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput
    upsert?: PaymentUpsertWithoutBookingInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutBookingInput, PaymentUpdateWithoutBookingInput>, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type UserUpdateOneWithoutBookingsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutBookingsCreatedInput, UserUncheckedCreateWithoutBookingsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsCreatedInput
    upsert?: UserUpsertWithoutBookingsCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsCreatedInput, UserUpdateWithoutBookingsCreatedInput>, UserUncheckedUpdateWithoutBookingsCreatedInput>
  }

  export type BookingStatusHistoryUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingStatusHistoryCreateWithoutBookingInput, BookingStatusHistoryUncheckedCreateWithoutBookingInput> | BookingStatusHistoryCreateWithoutBookingInput[] | BookingStatusHistoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingStatusHistoryCreateOrConnectWithoutBookingInput | BookingStatusHistoryCreateOrConnectWithoutBookingInput[]
    upsert?: BookingStatusHistoryUpsertWithWhereUniqueWithoutBookingInput | BookingStatusHistoryUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingStatusHistoryCreateManyBookingInputEnvelope
    set?: BookingStatusHistoryWhereUniqueInput | BookingStatusHistoryWhereUniqueInput[]
    disconnect?: BookingStatusHistoryWhereUniqueInput | BookingStatusHistoryWhereUniqueInput[]
    delete?: BookingStatusHistoryWhereUniqueInput | BookingStatusHistoryWhereUniqueInput[]
    connect?: BookingStatusHistoryWhereUniqueInput | BookingStatusHistoryWhereUniqueInput[]
    update?: BookingStatusHistoryUpdateWithWhereUniqueWithoutBookingInput | BookingStatusHistoryUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingStatusHistoryUpdateManyWithWhereWithoutBookingInput | BookingStatusHistoryUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingStatusHistoryScalarWhereInput | BookingStatusHistoryScalarWhereInput[]
  }

  export type BookingStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingStatusHistoryCreateWithoutBookingInput, BookingStatusHistoryUncheckedCreateWithoutBookingInput> | BookingStatusHistoryCreateWithoutBookingInput[] | BookingStatusHistoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingStatusHistoryCreateOrConnectWithoutBookingInput | BookingStatusHistoryCreateOrConnectWithoutBookingInput[]
    upsert?: BookingStatusHistoryUpsertWithWhereUniqueWithoutBookingInput | BookingStatusHistoryUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingStatusHistoryCreateManyBookingInputEnvelope
    set?: BookingStatusHistoryWhereUniqueInput | BookingStatusHistoryWhereUniqueInput[]
    disconnect?: BookingStatusHistoryWhereUniqueInput | BookingStatusHistoryWhereUniqueInput[]
    delete?: BookingStatusHistoryWhereUniqueInput | BookingStatusHistoryWhereUniqueInput[]
    connect?: BookingStatusHistoryWhereUniqueInput | BookingStatusHistoryWhereUniqueInput[]
    update?: BookingStatusHistoryUpdateWithWhereUniqueWithoutBookingInput | BookingStatusHistoryUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingStatusHistoryUpdateManyWithWhereWithoutBookingInput | BookingStatusHistoryUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingStatusHistoryScalarWhereInput | BookingStatusHistoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAvailabilitiesInput = {
    create?: XOR<UserCreateWithoutAvailabilitiesInput, UserUncheckedCreateWithoutAvailabilitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAvailabilitiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAvailabilitiesNestedInput = {
    create?: XOR<UserCreateWithoutAvailabilitiesInput, UserUncheckedCreateWithoutAvailabilitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAvailabilitiesInput
    upsert?: UserUpsertWithoutAvailabilitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAvailabilitiesInput, UserUpdateWithoutAvailabilitiesInput>, UserUncheckedUpdateWithoutAvailabilitiesInput>
  }

  export type PaymentCreateNestedOneWithoutGiftCardInput = {
    create?: XOR<PaymentCreateWithoutGiftCardInput, PaymentUncheckedCreateWithoutGiftCardInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutGiftCardInput
    connect?: PaymentWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutGiftCardInput = {
    create?: XOR<BookingCreateWithoutGiftCardInput, BookingUncheckedCreateWithoutGiftCardInput> | BookingCreateWithoutGiftCardInput[] | BookingUncheckedCreateWithoutGiftCardInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutGiftCardInput | BookingCreateOrConnectWithoutGiftCardInput[]
    createMany?: BookingCreateManyGiftCardInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutGiftCardInput = {
    create?: XOR<BookingCreateWithoutGiftCardInput, BookingUncheckedCreateWithoutGiftCardInput> | BookingCreateWithoutGiftCardInput[] | BookingUncheckedCreateWithoutGiftCardInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutGiftCardInput | BookingCreateOrConnectWithoutGiftCardInput[]
    createMany?: BookingCreateManyGiftCardInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PaymentUpdateOneRequiredWithoutGiftCardNestedInput = {
    create?: XOR<PaymentCreateWithoutGiftCardInput, PaymentUncheckedCreateWithoutGiftCardInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutGiftCardInput
    upsert?: PaymentUpsertWithoutGiftCardInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutGiftCardInput, PaymentUpdateWithoutGiftCardInput>, PaymentUncheckedUpdateWithoutGiftCardInput>
  }

  export type BookingUpdateManyWithoutGiftCardNestedInput = {
    create?: XOR<BookingCreateWithoutGiftCardInput, BookingUncheckedCreateWithoutGiftCardInput> | BookingCreateWithoutGiftCardInput[] | BookingUncheckedCreateWithoutGiftCardInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutGiftCardInput | BookingCreateOrConnectWithoutGiftCardInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutGiftCardInput | BookingUpsertWithWhereUniqueWithoutGiftCardInput[]
    createMany?: BookingCreateManyGiftCardInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutGiftCardInput | BookingUpdateWithWhereUniqueWithoutGiftCardInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutGiftCardInput | BookingUpdateManyWithWhereWithoutGiftCardInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutGiftCardNestedInput = {
    create?: XOR<BookingCreateWithoutGiftCardInput, BookingUncheckedCreateWithoutGiftCardInput> | BookingCreateWithoutGiftCardInput[] | BookingUncheckedCreateWithoutGiftCardInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutGiftCardInput | BookingCreateOrConnectWithoutGiftCardInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutGiftCardInput | BookingUpsertWithWhereUniqueWithoutGiftCardInput[]
    createMany?: BookingCreateManyGiftCardInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutGiftCardInput | BookingUpdateWithWhereUniqueWithoutGiftCardInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutGiftCardInput | BookingUpdateManyWithWhereWithoutGiftCardInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type GymSubscriptionCreateNestedManyWithoutMembershipInput = {
    create?: XOR<GymSubscriptionCreateWithoutMembershipInput, GymSubscriptionUncheckedCreateWithoutMembershipInput> | GymSubscriptionCreateWithoutMembershipInput[] | GymSubscriptionUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: GymSubscriptionCreateOrConnectWithoutMembershipInput | GymSubscriptionCreateOrConnectWithoutMembershipInput[]
    createMany?: GymSubscriptionCreateManyMembershipInputEnvelope
    connect?: GymSubscriptionWhereUniqueInput | GymSubscriptionWhereUniqueInput[]
  }

  export type GymSubscriptionUncheckedCreateNestedManyWithoutMembershipInput = {
    create?: XOR<GymSubscriptionCreateWithoutMembershipInput, GymSubscriptionUncheckedCreateWithoutMembershipInput> | GymSubscriptionCreateWithoutMembershipInput[] | GymSubscriptionUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: GymSubscriptionCreateOrConnectWithoutMembershipInput | GymSubscriptionCreateOrConnectWithoutMembershipInput[]
    createMany?: GymSubscriptionCreateManyMembershipInputEnvelope
    connect?: GymSubscriptionWhereUniqueInput | GymSubscriptionWhereUniqueInput[]
  }

  export type GymSubscriptionUpdateManyWithoutMembershipNestedInput = {
    create?: XOR<GymSubscriptionCreateWithoutMembershipInput, GymSubscriptionUncheckedCreateWithoutMembershipInput> | GymSubscriptionCreateWithoutMembershipInput[] | GymSubscriptionUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: GymSubscriptionCreateOrConnectWithoutMembershipInput | GymSubscriptionCreateOrConnectWithoutMembershipInput[]
    upsert?: GymSubscriptionUpsertWithWhereUniqueWithoutMembershipInput | GymSubscriptionUpsertWithWhereUniqueWithoutMembershipInput[]
    createMany?: GymSubscriptionCreateManyMembershipInputEnvelope
    set?: GymSubscriptionWhereUniqueInput | GymSubscriptionWhereUniqueInput[]
    disconnect?: GymSubscriptionWhereUniqueInput | GymSubscriptionWhereUniqueInput[]
    delete?: GymSubscriptionWhereUniqueInput | GymSubscriptionWhereUniqueInput[]
    connect?: GymSubscriptionWhereUniqueInput | GymSubscriptionWhereUniqueInput[]
    update?: GymSubscriptionUpdateWithWhereUniqueWithoutMembershipInput | GymSubscriptionUpdateWithWhereUniqueWithoutMembershipInput[]
    updateMany?: GymSubscriptionUpdateManyWithWhereWithoutMembershipInput | GymSubscriptionUpdateManyWithWhereWithoutMembershipInput[]
    deleteMany?: GymSubscriptionScalarWhereInput | GymSubscriptionScalarWhereInput[]
  }

  export type GymSubscriptionUncheckedUpdateManyWithoutMembershipNestedInput = {
    create?: XOR<GymSubscriptionCreateWithoutMembershipInput, GymSubscriptionUncheckedCreateWithoutMembershipInput> | GymSubscriptionCreateWithoutMembershipInput[] | GymSubscriptionUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: GymSubscriptionCreateOrConnectWithoutMembershipInput | GymSubscriptionCreateOrConnectWithoutMembershipInput[]
    upsert?: GymSubscriptionUpsertWithWhereUniqueWithoutMembershipInput | GymSubscriptionUpsertWithWhereUniqueWithoutMembershipInput[]
    createMany?: GymSubscriptionCreateManyMembershipInputEnvelope
    set?: GymSubscriptionWhereUniqueInput | GymSubscriptionWhereUniqueInput[]
    disconnect?: GymSubscriptionWhereUniqueInput | GymSubscriptionWhereUniqueInput[]
    delete?: GymSubscriptionWhereUniqueInput | GymSubscriptionWhereUniqueInput[]
    connect?: GymSubscriptionWhereUniqueInput | GymSubscriptionWhereUniqueInput[]
    update?: GymSubscriptionUpdateWithWhereUniqueWithoutMembershipInput | GymSubscriptionUpdateWithWhereUniqueWithoutMembershipInput[]
    updateMany?: GymSubscriptionUpdateManyWithWhereWithoutMembershipInput | GymSubscriptionUpdateManyWithWhereWithoutMembershipInput[]
    deleteMany?: GymSubscriptionScalarWhereInput | GymSubscriptionScalarWhereInput[]
  }

  export type GymMembershipCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<GymMembershipCreateWithoutSubscriptionsInput, GymMembershipUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: GymMembershipCreateOrConnectWithoutSubscriptionsInput
    connect?: GymMembershipWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutGymSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutGymSubscriptionInput, PaymentUncheckedCreateWithoutGymSubscriptionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutGymSubscriptionInput
    connect?: PaymentWhereUniqueInput
  }

  export type GymMembershipUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<GymMembershipCreateWithoutSubscriptionsInput, GymMembershipUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: GymMembershipCreateOrConnectWithoutSubscriptionsInput
    upsert?: GymMembershipUpsertWithoutSubscriptionsInput
    connect?: GymMembershipWhereUniqueInput
    update?: XOR<XOR<GymMembershipUpdateToOneWithWhereWithoutSubscriptionsInput, GymMembershipUpdateWithoutSubscriptionsInput>, GymMembershipUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PaymentUpdateOneRequiredWithoutGymSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutGymSubscriptionInput, PaymentUncheckedCreateWithoutGymSubscriptionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutGymSubscriptionInput
    upsert?: PaymentUpsertWithoutGymSubscriptionInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutGymSubscriptionInput, PaymentUpdateWithoutGymSubscriptionInput>, PaymentUncheckedUpdateWithoutGymSubscriptionInput>
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductPromotionCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductPromotionCreateWithoutProductInput, ProductPromotionUncheckedCreateWithoutProductInput> | ProductPromotionCreateWithoutProductInput[] | ProductPromotionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPromotionCreateOrConnectWithoutProductInput | ProductPromotionCreateOrConnectWithoutProductInput[]
    createMany?: ProductPromotionCreateManyProductInputEnvelope
    connect?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductPromotionUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductPromotionCreateWithoutProductInput, ProductPromotionUncheckedCreateWithoutProductInput> | ProductPromotionCreateWithoutProductInput[] | ProductPromotionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPromotionCreateOrConnectWithoutProductInput | ProductPromotionCreateOrConnectWithoutProductInput[]
    createMany?: ProductPromotionCreateManyProductInputEnvelope
    connect?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductPromotionUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductPromotionCreateWithoutProductInput, ProductPromotionUncheckedCreateWithoutProductInput> | ProductPromotionCreateWithoutProductInput[] | ProductPromotionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPromotionCreateOrConnectWithoutProductInput | ProductPromotionCreateOrConnectWithoutProductInput[]
    upsert?: ProductPromotionUpsertWithWhereUniqueWithoutProductInput | ProductPromotionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductPromotionCreateManyProductInputEnvelope
    set?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    disconnect?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    delete?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    connect?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    update?: ProductPromotionUpdateWithWhereUniqueWithoutProductInput | ProductPromotionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductPromotionUpdateManyWithWhereWithoutProductInput | ProductPromotionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductPromotionScalarWhereInput | ProductPromotionScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductPromotionUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductPromotionCreateWithoutProductInput, ProductPromotionUncheckedCreateWithoutProductInput> | ProductPromotionCreateWithoutProductInput[] | ProductPromotionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductPromotionCreateOrConnectWithoutProductInput | ProductPromotionCreateOrConnectWithoutProductInput[]
    upsert?: ProductPromotionUpsertWithWhereUniqueWithoutProductInput | ProductPromotionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductPromotionCreateManyProductInputEnvelope
    set?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    disconnect?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    delete?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    connect?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    update?: ProductPromotionUpdateWithWhereUniqueWithoutProductInput | ProductPromotionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductPromotionUpdateManyWithWhereWithoutProductInput | ProductPromotionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductPromotionScalarWhereInput | ProductPromotionScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    connect?: PaymentWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type PaymentUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    upsert?: PaymentUpsertWithoutOrderInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutOrderInput, PaymentUpdateWithoutOrderInput>, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ServicePromotionCreateNestedManyWithoutPromotionInput = {
    create?: XOR<ServicePromotionCreateWithoutPromotionInput, ServicePromotionUncheckedCreateWithoutPromotionInput> | ServicePromotionCreateWithoutPromotionInput[] | ServicePromotionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: ServicePromotionCreateOrConnectWithoutPromotionInput | ServicePromotionCreateOrConnectWithoutPromotionInput[]
    createMany?: ServicePromotionCreateManyPromotionInputEnvelope
    connect?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
  }

  export type PackagePromotionCreateNestedManyWithoutPromotionInput = {
    create?: XOR<PackagePromotionCreateWithoutPromotionInput, PackagePromotionUncheckedCreateWithoutPromotionInput> | PackagePromotionCreateWithoutPromotionInput[] | PackagePromotionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PackagePromotionCreateOrConnectWithoutPromotionInput | PackagePromotionCreateOrConnectWithoutPromotionInput[]
    createMany?: PackagePromotionCreateManyPromotionInputEnvelope
    connect?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
  }

  export type ProductPromotionCreateNestedManyWithoutPromotionInput = {
    create?: XOR<ProductPromotionCreateWithoutPromotionInput, ProductPromotionUncheckedCreateWithoutPromotionInput> | ProductPromotionCreateWithoutPromotionInput[] | ProductPromotionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: ProductPromotionCreateOrConnectWithoutPromotionInput | ProductPromotionCreateOrConnectWithoutPromotionInput[]
    createMany?: ProductPromotionCreateManyPromotionInputEnvelope
    connect?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
  }

  export type ServicePromotionUncheckedCreateNestedManyWithoutPromotionInput = {
    create?: XOR<ServicePromotionCreateWithoutPromotionInput, ServicePromotionUncheckedCreateWithoutPromotionInput> | ServicePromotionCreateWithoutPromotionInput[] | ServicePromotionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: ServicePromotionCreateOrConnectWithoutPromotionInput | ServicePromotionCreateOrConnectWithoutPromotionInput[]
    createMany?: ServicePromotionCreateManyPromotionInputEnvelope
    connect?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
  }

  export type PackagePromotionUncheckedCreateNestedManyWithoutPromotionInput = {
    create?: XOR<PackagePromotionCreateWithoutPromotionInput, PackagePromotionUncheckedCreateWithoutPromotionInput> | PackagePromotionCreateWithoutPromotionInput[] | PackagePromotionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PackagePromotionCreateOrConnectWithoutPromotionInput | PackagePromotionCreateOrConnectWithoutPromotionInput[]
    createMany?: PackagePromotionCreateManyPromotionInputEnvelope
    connect?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
  }

  export type ProductPromotionUncheckedCreateNestedManyWithoutPromotionInput = {
    create?: XOR<ProductPromotionCreateWithoutPromotionInput, ProductPromotionUncheckedCreateWithoutPromotionInput> | ProductPromotionCreateWithoutPromotionInput[] | ProductPromotionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: ProductPromotionCreateOrConnectWithoutPromotionInput | ProductPromotionCreateOrConnectWithoutPromotionInput[]
    createMany?: ProductPromotionCreateManyPromotionInputEnvelope
    connect?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
  }

  export type EnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType
  }

  export type ServicePromotionUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<ServicePromotionCreateWithoutPromotionInput, ServicePromotionUncheckedCreateWithoutPromotionInput> | ServicePromotionCreateWithoutPromotionInput[] | ServicePromotionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: ServicePromotionCreateOrConnectWithoutPromotionInput | ServicePromotionCreateOrConnectWithoutPromotionInput[]
    upsert?: ServicePromotionUpsertWithWhereUniqueWithoutPromotionInput | ServicePromotionUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: ServicePromotionCreateManyPromotionInputEnvelope
    set?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    disconnect?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    delete?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    connect?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    update?: ServicePromotionUpdateWithWhereUniqueWithoutPromotionInput | ServicePromotionUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: ServicePromotionUpdateManyWithWhereWithoutPromotionInput | ServicePromotionUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: ServicePromotionScalarWhereInput | ServicePromotionScalarWhereInput[]
  }

  export type PackagePromotionUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<PackagePromotionCreateWithoutPromotionInput, PackagePromotionUncheckedCreateWithoutPromotionInput> | PackagePromotionCreateWithoutPromotionInput[] | PackagePromotionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PackagePromotionCreateOrConnectWithoutPromotionInput | PackagePromotionCreateOrConnectWithoutPromotionInput[]
    upsert?: PackagePromotionUpsertWithWhereUniqueWithoutPromotionInput | PackagePromotionUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: PackagePromotionCreateManyPromotionInputEnvelope
    set?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    disconnect?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    delete?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    connect?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    update?: PackagePromotionUpdateWithWhereUniqueWithoutPromotionInput | PackagePromotionUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: PackagePromotionUpdateManyWithWhereWithoutPromotionInput | PackagePromotionUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: PackagePromotionScalarWhereInput | PackagePromotionScalarWhereInput[]
  }

  export type ProductPromotionUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<ProductPromotionCreateWithoutPromotionInput, ProductPromotionUncheckedCreateWithoutPromotionInput> | ProductPromotionCreateWithoutPromotionInput[] | ProductPromotionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: ProductPromotionCreateOrConnectWithoutPromotionInput | ProductPromotionCreateOrConnectWithoutPromotionInput[]
    upsert?: ProductPromotionUpsertWithWhereUniqueWithoutPromotionInput | ProductPromotionUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: ProductPromotionCreateManyPromotionInputEnvelope
    set?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    disconnect?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    delete?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    connect?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    update?: ProductPromotionUpdateWithWhereUniqueWithoutPromotionInput | ProductPromotionUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: ProductPromotionUpdateManyWithWhereWithoutPromotionInput | ProductPromotionUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: ProductPromotionScalarWhereInput | ProductPromotionScalarWhereInput[]
  }

  export type ServicePromotionUncheckedUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<ServicePromotionCreateWithoutPromotionInput, ServicePromotionUncheckedCreateWithoutPromotionInput> | ServicePromotionCreateWithoutPromotionInput[] | ServicePromotionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: ServicePromotionCreateOrConnectWithoutPromotionInput | ServicePromotionCreateOrConnectWithoutPromotionInput[]
    upsert?: ServicePromotionUpsertWithWhereUniqueWithoutPromotionInput | ServicePromotionUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: ServicePromotionCreateManyPromotionInputEnvelope
    set?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    disconnect?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    delete?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    connect?: ServicePromotionWhereUniqueInput | ServicePromotionWhereUniqueInput[]
    update?: ServicePromotionUpdateWithWhereUniqueWithoutPromotionInput | ServicePromotionUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: ServicePromotionUpdateManyWithWhereWithoutPromotionInput | ServicePromotionUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: ServicePromotionScalarWhereInput | ServicePromotionScalarWhereInput[]
  }

  export type PackagePromotionUncheckedUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<PackagePromotionCreateWithoutPromotionInput, PackagePromotionUncheckedCreateWithoutPromotionInput> | PackagePromotionCreateWithoutPromotionInput[] | PackagePromotionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PackagePromotionCreateOrConnectWithoutPromotionInput | PackagePromotionCreateOrConnectWithoutPromotionInput[]
    upsert?: PackagePromotionUpsertWithWhereUniqueWithoutPromotionInput | PackagePromotionUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: PackagePromotionCreateManyPromotionInputEnvelope
    set?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    disconnect?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    delete?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    connect?: PackagePromotionWhereUniqueInput | PackagePromotionWhereUniqueInput[]
    update?: PackagePromotionUpdateWithWhereUniqueWithoutPromotionInput | PackagePromotionUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: PackagePromotionUpdateManyWithWhereWithoutPromotionInput | PackagePromotionUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: PackagePromotionScalarWhereInput | PackagePromotionScalarWhereInput[]
  }

  export type ProductPromotionUncheckedUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<ProductPromotionCreateWithoutPromotionInput, ProductPromotionUncheckedCreateWithoutPromotionInput> | ProductPromotionCreateWithoutPromotionInput[] | ProductPromotionUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: ProductPromotionCreateOrConnectWithoutPromotionInput | ProductPromotionCreateOrConnectWithoutPromotionInput[]
    upsert?: ProductPromotionUpsertWithWhereUniqueWithoutPromotionInput | ProductPromotionUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: ProductPromotionCreateManyPromotionInputEnvelope
    set?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    disconnect?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    delete?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    connect?: ProductPromotionWhereUniqueInput | ProductPromotionWhereUniqueInput[]
    update?: ProductPromotionUpdateWithWhereUniqueWithoutPromotionInput | ProductPromotionUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: ProductPromotionUpdateManyWithWhereWithoutPromotionInput | ProductPromotionUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: ProductPromotionScalarWhereInput | ProductPromotionScalarWhereInput[]
  }

  export type PromotionCreateNestedOneWithoutServicesInput = {
    create?: XOR<PromotionCreateWithoutServicesInput, PromotionUncheckedCreateWithoutServicesInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutServicesInput
    connect?: PromotionWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutPromotionsInput = {
    create?: XOR<ServiceCreateWithoutPromotionsInput, ServiceUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPromotionsInput
    connect?: ServiceWhereUniqueInput
  }

  export type PromotionUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<PromotionCreateWithoutServicesInput, PromotionUncheckedCreateWithoutServicesInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutServicesInput
    upsert?: PromotionUpsertWithoutServicesInput
    connect?: PromotionWhereUniqueInput
    update?: XOR<XOR<PromotionUpdateToOneWithWhereWithoutServicesInput, PromotionUpdateWithoutServicesInput>, PromotionUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutPromotionsNestedInput = {
    create?: XOR<ServiceCreateWithoutPromotionsInput, ServiceUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPromotionsInput
    upsert?: ServiceUpsertWithoutPromotionsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutPromotionsInput, ServiceUpdateWithoutPromotionsInput>, ServiceUncheckedUpdateWithoutPromotionsInput>
  }

  export type PromotionCreateNestedOneWithoutPackagesInput = {
    create?: XOR<PromotionCreateWithoutPackagesInput, PromotionUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutPackagesInput
    connect?: PromotionWhereUniqueInput
  }

  export type PackageCreateNestedOneWithoutPromotionsInput = {
    create?: XOR<PackageCreateWithoutPromotionsInput, PackageUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: PackageCreateOrConnectWithoutPromotionsInput
    connect?: PackageWhereUniqueInput
  }

  export type PromotionUpdateOneRequiredWithoutPackagesNestedInput = {
    create?: XOR<PromotionCreateWithoutPackagesInput, PromotionUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutPackagesInput
    upsert?: PromotionUpsertWithoutPackagesInput
    connect?: PromotionWhereUniqueInput
    update?: XOR<XOR<PromotionUpdateToOneWithWhereWithoutPackagesInput, PromotionUpdateWithoutPackagesInput>, PromotionUncheckedUpdateWithoutPackagesInput>
  }

  export type PackageUpdateOneRequiredWithoutPromotionsNestedInput = {
    create?: XOR<PackageCreateWithoutPromotionsInput, PackageUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: PackageCreateOrConnectWithoutPromotionsInput
    upsert?: PackageUpsertWithoutPromotionsInput
    connect?: PackageWhereUniqueInput
    update?: XOR<XOR<PackageUpdateToOneWithWhereWithoutPromotionsInput, PackageUpdateWithoutPromotionsInput>, PackageUncheckedUpdateWithoutPromotionsInput>
  }

  export type PromotionCreateNestedOneWithoutProductsInput = {
    create?: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutProductsInput
    connect?: PromotionWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPromotionsInput = {
    create?: XOR<ProductCreateWithoutPromotionsInput, ProductUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPromotionsInput
    connect?: ProductWhereUniqueInput
  }

  export type PromotionUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutProductsInput
    upsert?: PromotionUpsertWithoutProductsInput
    connect?: PromotionWhereUniqueInput
    update?: XOR<XOR<PromotionUpdateToOneWithWhereWithoutProductsInput, PromotionUpdateWithoutProductsInput>, PromotionUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutPromotionsNestedInput = {
    create?: XOR<ProductCreateWithoutPromotionsInput, ProductUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPromotionsInput
    upsert?: ProductUpsertWithoutPromotionsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPromotionsInput, ProductUpdateWithoutPromotionsInput>, ProductUncheckedUpdateWithoutPromotionsInput>
  }

  export type BookingCreateNestedOneWithoutStatusHistoryInput = {
    create?: XOR<BookingCreateWithoutStatusHistoryInput, BookingUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: BookingCreateOrConnectWithoutStatusHistoryInput
    connect?: BookingWhereUniqueInput
  }

  export type NullableEnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus | null
  }

  export type BookingUpdateOneRequiredWithoutStatusHistoryNestedInput = {
    create?: XOR<BookingCreateWithoutStatusHistoryInput, BookingUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: BookingCreateOrConnectWithoutStatusHistoryInput
    upsert?: BookingUpsertWithoutStatusHistoryInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutStatusHistoryInput, BookingUpdateWithoutStatusHistoryInput>, BookingUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type UserCreateNestedOneWithoutWorkingSchedulesInput = {
    create?: XOR<UserCreateWithoutWorkingSchedulesInput, UserUncheckedCreateWithoutWorkingSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkingSchedulesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWorkingSchedulesNestedInput = {
    create?: XOR<UserCreateWithoutWorkingSchedulesInput, UserUncheckedCreateWithoutWorkingSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkingSchedulesInput
    upsert?: UserUpsertWithoutWorkingSchedulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkingSchedulesInput, UserUpdateWithoutWorkingSchedulesInput>, UserUncheckedUpdateWithoutWorkingSchedulesInput>
  }

  export type UserCreateNestedOneWithoutBreaksInput = {
    create?: XOR<UserCreateWithoutBreaksInput, UserUncheckedCreateWithoutBreaksInput>
    connectOrCreate?: UserCreateOrConnectWithoutBreaksInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBreaksNestedInput = {
    create?: XOR<UserCreateWithoutBreaksInput, UserUncheckedCreateWithoutBreaksInput>
    connectOrCreate?: UserCreateOrConnectWithoutBreaksInput
    upsert?: UserUpsertWithoutBreaksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBreaksInput, UserUpdateWithoutBreaksInput>, UserUncheckedUpdateWithoutBreaksInput>
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumBookingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeFilter<$PrismaModel> | $Enums.BookingType
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingTypeFilter<$PrismaModel>
    _max?: NestedEnumBookingTypeFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableFilter<$PrismaModel> | $Enums.BookingStatus | null
  }

  export type NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NoteCreateWithoutAuthorInput = {
    id?: string
    content: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    feedbackToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    clientId: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    feedbackToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateOrConnectWithoutAuthorInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput>
  }

  export type NoteCreateManyAuthorInputEnvelope = {
    data: NoteCreateManyAuthorInput | NoteCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutProfessionalInput = {
    id?: string
    assignedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateWithoutProfessionalInput = {
    id?: string
    clientId: string
    assignedAt?: Date | string
  }

  export type AssignmentCreateOrConnectWithoutProfessionalInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutProfessionalInput, AssignmentUncheckedCreateWithoutProfessionalInput>
  }

  export type AssignmentCreateManyProfessionalInputEnvelope = {
    data: AssignmentCreateManyProfessionalInput | AssignmentCreateManyProfessionalInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutProfessionalInput = {
    id?: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
  }

  export type ReviewUncheckedCreateWithoutProfessionalInput = {
    id?: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutProfessionalInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutProfessionalInput, ReviewUncheckedCreateWithoutProfessionalInput>
  }

  export type ReviewCreateManyProfessionalInputEnvelope = {
    data: ReviewCreateManyProfessionalInput | ReviewCreateManyProfessionalInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutProfessionalInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutBookingsInput
    package?: PackageCreateNestedOneWithoutBookingsInput
    giftCard?: GiftCardCreateNestedOneWithoutUsedInBookingsInput
    payment: PaymentCreateNestedOneWithoutBookingInput
    createdBy?: UserCreateNestedOneWithoutBookingsCreatedInput
    statusHistory?: BookingStatusHistoryCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutProfessionalInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    serviceId?: string | null
    packageId?: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardId?: string | null
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    paymentId: string
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: BookingStatusHistoryUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutProfessionalInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutProfessionalInput, BookingUncheckedCreateWithoutProfessionalInput>
  }

  export type BookingCreateManyProfessionalInputEnvelope = {
    data: BookingCreateManyProfessionalInput | BookingCreateManyProfessionalInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutCreatedByInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutBookingsInput
    package?: PackageCreateNestedOneWithoutBookingsInput
    professional?: UserCreateNestedOneWithoutBookingsAsProfessionalInput
    giftCard?: GiftCardCreateNestedOneWithoutUsedInBookingsInput
    payment: PaymentCreateNestedOneWithoutBookingInput
    statusHistory?: BookingStatusHistoryCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCreatedByInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    serviceId?: string | null
    packageId?: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    professionalId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardId?: string | null
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    paymentId: string
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: BookingStatusHistoryUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCreatedByInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCreatedByInput, BookingUncheckedCreateWithoutCreatedByInput>
  }

  export type BookingCreateManyCreatedByInputEnvelope = {
    data: BookingCreateManyCreatedByInput | BookingCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AvailabilityCreateWithoutProfessionalInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    isAvailable?: boolean
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityUncheckedCreateWithoutProfessionalInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    isAvailable?: boolean
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityCreateOrConnectWithoutProfessionalInput = {
    where: AvailabilityWhereUniqueInput
    create: XOR<AvailabilityCreateWithoutProfessionalInput, AvailabilityUncheckedCreateWithoutProfessionalInput>
  }

  export type AvailabilityCreateManyProfessionalInputEnvelope = {
    data: AvailabilityCreateManyProfessionalInput | AvailabilityCreateManyProfessionalInput[]
    skipDuplicates?: boolean
  }

  export type WorkingScheduleCreateWithoutProfessionalInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkingScheduleUncheckedCreateWithoutProfessionalInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkingScheduleCreateOrConnectWithoutProfessionalInput = {
    where: WorkingScheduleWhereUniqueInput
    create: XOR<WorkingScheduleCreateWithoutProfessionalInput, WorkingScheduleUncheckedCreateWithoutProfessionalInput>
  }

  export type WorkingScheduleCreateManyProfessionalInputEnvelope = {
    data: WorkingScheduleCreateManyProfessionalInput | WorkingScheduleCreateManyProfessionalInput[]
    skipDuplicates?: boolean
  }

  export type BreakPeriodCreateWithoutProfessionalInput = {
    id?: string
    dayOfWeek?: number | null
    startTime: string
    endTime: string
    label?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreakPeriodUncheckedCreateWithoutProfessionalInput = {
    id?: string
    dayOfWeek?: number | null
    startTime: string
    endTime: string
    label?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreakPeriodCreateOrConnectWithoutProfessionalInput = {
    where: BreakPeriodWhereUniqueInput
    create: XOR<BreakPeriodCreateWithoutProfessionalInput, BreakPeriodUncheckedCreateWithoutProfessionalInput>
  }

  export type BreakPeriodCreateManyProfessionalInputEnvelope = {
    data: BreakPeriodCreateManyProfessionalInput | BreakPeriodCreateManyProfessionalInput[]
    skipDuplicates?: boolean
  }

  export type NoteUpsertWithWhereUniqueWithoutAuthorInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutAuthorInput, NoteUncheckedUpdateWithoutAuthorInput>
    create: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutAuthorInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutAuthorInput, NoteUncheckedUpdateWithoutAuthorInput>
  }

  export type NoteUpdateManyWithWhereWithoutAuthorInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutAuthorInput>
  }

  export type NoteScalarWhereInput = {
    AND?: NoteScalarWhereInput | NoteScalarWhereInput[]
    OR?: NoteScalarWhereInput[]
    NOT?: NoteScalarWhereInput | NoteScalarWhereInput[]
    id?: StringFilter<"Note"> | string
    content?: StringFilter<"Note"> | string
    clientId?: StringFilter<"Note"> | string
    authorId?: StringFilter<"Note"> | string
    emailSent?: BoolFilter<"Note"> | boolean
    emailSentAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    feedbackToken?: StringNullableFilter<"Note"> | string | null
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
  }

  export type AssignmentUpsertWithWhereUniqueWithoutProfessionalInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutProfessionalInput, AssignmentUncheckedUpdateWithoutProfessionalInput>
    create: XOR<AssignmentCreateWithoutProfessionalInput, AssignmentUncheckedCreateWithoutProfessionalInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutProfessionalInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutProfessionalInput, AssignmentUncheckedUpdateWithoutProfessionalInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutProfessionalInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutProfessionalInput>
  }

  export type AssignmentScalarWhereInput = {
    AND?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    OR?: AssignmentScalarWhereInput[]
    NOT?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    id?: StringFilter<"Assignment"> | string
    clientId?: StringFilter<"Assignment"> | string
    professionalId?: StringFilter<"Assignment"> | string
    assignedAt?: DateTimeFilter<"Assignment"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutProfessionalInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutProfessionalInput, ReviewUncheckedUpdateWithoutProfessionalInput>
    create: XOR<ReviewCreateWithoutProfessionalInput, ReviewUncheckedCreateWithoutProfessionalInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutProfessionalInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutProfessionalInput, ReviewUncheckedUpdateWithoutProfessionalInput>
  }

  export type ReviewUpdateManyWithWhereWithoutProfessionalInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutProfessionalInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    professionalId?: StringFilter<"Review"> | string
    isAnonymous?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutProfessionalInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutProfessionalInput, BookingUncheckedUpdateWithoutProfessionalInput>
    create: XOR<BookingCreateWithoutProfessionalInput, BookingUncheckedCreateWithoutProfessionalInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutProfessionalInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutProfessionalInput, BookingUncheckedUpdateWithoutProfessionalInput>
  }

  export type BookingUpdateManyWithWhereWithoutProfessionalInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutProfessionalInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    bookingNumber?: StringFilter<"Booking"> | string
    type?: EnumBookingTypeFilter<"Booking"> | $Enums.BookingType
    serviceId?: StringNullableFilter<"Booking"> | string | null
    packageId?: StringNullableFilter<"Booking"> | string | null
    clientEmail?: StringFilter<"Booking"> | string
    clientName?: StringFilter<"Booking"> | string
    clientPhone?: StringFilter<"Booking"> | string
    specialNotes?: StringNullableFilter<"Booking"> | string | null
    bookingDate?: DateTimeFilter<"Booking"> | Date | string
    startTime?: StringFilter<"Booking"> | string
    endTime?: StringFilter<"Booking"> | string
    professionalId?: StringNullableFilter<"Booking"> | string | null
    subtotal?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    giftCardId?: StringNullableFilter<"Booking"> | string | null
    giftCardAmount?: DecimalNullableFilter<"Booking"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    paymentId?: StringFilter<"Booking"> | string
    reminderSent?: BoolFilter<"Booking"> | boolean
    googleCalendarEventId?: StringNullableFilter<"Booking"> | string | null
    createdById?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutCreatedByInput, BookingUncheckedUpdateWithoutCreatedByInput>
    create: XOR<BookingCreateWithoutCreatedByInput, BookingUncheckedCreateWithoutCreatedByInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutCreatedByInput, BookingUncheckedUpdateWithoutCreatedByInput>
  }

  export type BookingUpdateManyWithWhereWithoutCreatedByInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AvailabilityUpsertWithWhereUniqueWithoutProfessionalInput = {
    where: AvailabilityWhereUniqueInput
    update: XOR<AvailabilityUpdateWithoutProfessionalInput, AvailabilityUncheckedUpdateWithoutProfessionalInput>
    create: XOR<AvailabilityCreateWithoutProfessionalInput, AvailabilityUncheckedCreateWithoutProfessionalInput>
  }

  export type AvailabilityUpdateWithWhereUniqueWithoutProfessionalInput = {
    where: AvailabilityWhereUniqueInput
    data: XOR<AvailabilityUpdateWithoutProfessionalInput, AvailabilityUncheckedUpdateWithoutProfessionalInput>
  }

  export type AvailabilityUpdateManyWithWhereWithoutProfessionalInput = {
    where: AvailabilityScalarWhereInput
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyWithoutProfessionalInput>
  }

  export type AvailabilityScalarWhereInput = {
    AND?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
    OR?: AvailabilityScalarWhereInput[]
    NOT?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
    id?: StringFilter<"Availability"> | string
    professionalId?: StringFilter<"Availability"> | string
    date?: DateTimeFilter<"Availability"> | Date | string
    startTime?: StringNullableFilter<"Availability"> | string | null
    endTime?: StringNullableFilter<"Availability"> | string | null
    isAvailable?: BoolFilter<"Availability"> | boolean
    reason?: StringNullableFilter<"Availability"> | string | null
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    updatedAt?: DateTimeFilter<"Availability"> | Date | string
  }

  export type WorkingScheduleUpsertWithWhereUniqueWithoutProfessionalInput = {
    where: WorkingScheduleWhereUniqueInput
    update: XOR<WorkingScheduleUpdateWithoutProfessionalInput, WorkingScheduleUncheckedUpdateWithoutProfessionalInput>
    create: XOR<WorkingScheduleCreateWithoutProfessionalInput, WorkingScheduleUncheckedCreateWithoutProfessionalInput>
  }

  export type WorkingScheduleUpdateWithWhereUniqueWithoutProfessionalInput = {
    where: WorkingScheduleWhereUniqueInput
    data: XOR<WorkingScheduleUpdateWithoutProfessionalInput, WorkingScheduleUncheckedUpdateWithoutProfessionalInput>
  }

  export type WorkingScheduleUpdateManyWithWhereWithoutProfessionalInput = {
    where: WorkingScheduleScalarWhereInput
    data: XOR<WorkingScheduleUpdateManyMutationInput, WorkingScheduleUncheckedUpdateManyWithoutProfessionalInput>
  }

  export type WorkingScheduleScalarWhereInput = {
    AND?: WorkingScheduleScalarWhereInput | WorkingScheduleScalarWhereInput[]
    OR?: WorkingScheduleScalarWhereInput[]
    NOT?: WorkingScheduleScalarWhereInput | WorkingScheduleScalarWhereInput[]
    id?: StringFilter<"WorkingSchedule"> | string
    professionalId?: StringFilter<"WorkingSchedule"> | string
    dayOfWeek?: IntFilter<"WorkingSchedule"> | number
    startTime?: StringFilter<"WorkingSchedule"> | string
    endTime?: StringFilter<"WorkingSchedule"> | string
    isActive?: BoolFilter<"WorkingSchedule"> | boolean
    createdAt?: DateTimeFilter<"WorkingSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"WorkingSchedule"> | Date | string
  }

  export type BreakPeriodUpsertWithWhereUniqueWithoutProfessionalInput = {
    where: BreakPeriodWhereUniqueInput
    update: XOR<BreakPeriodUpdateWithoutProfessionalInput, BreakPeriodUncheckedUpdateWithoutProfessionalInput>
    create: XOR<BreakPeriodCreateWithoutProfessionalInput, BreakPeriodUncheckedCreateWithoutProfessionalInput>
  }

  export type BreakPeriodUpdateWithWhereUniqueWithoutProfessionalInput = {
    where: BreakPeriodWhereUniqueInput
    data: XOR<BreakPeriodUpdateWithoutProfessionalInput, BreakPeriodUncheckedUpdateWithoutProfessionalInput>
  }

  export type BreakPeriodUpdateManyWithWhereWithoutProfessionalInput = {
    where: BreakPeriodScalarWhereInput
    data: XOR<BreakPeriodUpdateManyMutationInput, BreakPeriodUncheckedUpdateManyWithoutProfessionalInput>
  }

  export type BreakPeriodScalarWhereInput = {
    AND?: BreakPeriodScalarWhereInput | BreakPeriodScalarWhereInput[]
    OR?: BreakPeriodScalarWhereInput[]
    NOT?: BreakPeriodScalarWhereInput | BreakPeriodScalarWhereInput[]
    id?: StringFilter<"BreakPeriod"> | string
    professionalId?: StringFilter<"BreakPeriod"> | string
    dayOfWeek?: IntNullableFilter<"BreakPeriod"> | number | null
    startTime?: StringFilter<"BreakPeriod"> | string
    endTime?: StringFilter<"BreakPeriod"> | string
    label?: StringNullableFilter<"BreakPeriod"> | string | null
    isActive?: BoolFilter<"BreakPeriod"> | boolean
    createdAt?: DateTimeFilter<"BreakPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"BreakPeriod"> | Date | string
  }

  export type NoteCreateWithoutClientInput = {
    id?: string
    content: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    feedbackToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutNotesCreatedInput
  }

  export type NoteUncheckedCreateWithoutClientInput = {
    id?: string
    content: string
    authorId: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    feedbackToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateOrConnectWithoutClientInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutClientInput, NoteUncheckedCreateWithoutClientInput>
  }

  export type NoteCreateManyClientInputEnvelope = {
    data: NoteCreateManyClientInput | NoteCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutClientInput = {
    id?: string
    assignedAt?: Date | string
    professional: UserCreateNestedOneWithoutAssignedClientsInput
  }

  export type AssignmentUncheckedCreateWithoutClientInput = {
    id?: string
    professionalId: string
    assignedAt?: Date | string
  }

  export type AssignmentCreateOrConnectWithoutClientInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput>
  }

  export type AssignmentCreateManyClientInputEnvelope = {
    data: AssignmentCreateManyClientInput | AssignmentCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type NoteUpsertWithWhereUniqueWithoutClientInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutClientInput, NoteUncheckedUpdateWithoutClientInput>
    create: XOR<NoteCreateWithoutClientInput, NoteUncheckedCreateWithoutClientInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutClientInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutClientInput, NoteUncheckedUpdateWithoutClientInput>
  }

  export type NoteUpdateManyWithWhereWithoutClientInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutClientInput>
  }

  export type AssignmentUpsertWithWhereUniqueWithoutClientInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutClientInput, AssignmentUncheckedUpdateWithoutClientInput>
    create: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutClientInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutClientInput, AssignmentUncheckedUpdateWithoutClientInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutClientInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientProfileCreateWithoutNotesInput = {
    id?: string
    nom: string
    prenom: string
    adresse: string
    ville: string
    codePostal: string
    telMaison?: string | null
    telBureau?: string | null
    telCellulaire: string
    courriel: string
    dateNaissance: Date | string
    occupation?: string | null
    gender: $Enums.Gender
    serviceType: $Enums.ServiceType
    assuranceCouvert: boolean
    autreMaladie?: boolean | null
    autreMaladieDetails?: string | null
    raisonConsultation?: string | null
    diagnosticMedical?: boolean | null
    diagnosticMedicalDetails?: string | null
    medicaments?: boolean | null
    medicamentsDetails?: string | null
    accidents?: boolean | null
    accidentsDetails?: string | null
    operationsChirurgicales?: boolean | null
    operationsChirurgicalesDetails?: string | null
    traitementsActuels?: string | null
    problemesCardiaques?: boolean
    problemesCardiaquesDetails?: string | null
    maladiesGraves?: boolean
    maladiesGravesDetails?: string | null
    ortheses?: boolean
    orthesesDetails?: string | null
    allergies?: boolean
    allergiesDetails?: string | null
    raideurs?: boolean
    arthrose?: boolean
    hernieDiscale?: boolean
    oedeme?: boolean
    tendinite?: boolean
    mauxDeTete?: boolean
    flatulence?: boolean
    troublesCirculatoires?: boolean
    hypothyroidie?: boolean
    diabete?: boolean
    stresse?: boolean
    premenopause?: boolean
    douleurMusculaire?: boolean
    fibromyalgie?: boolean
    rhumatisme?: boolean
    sciatique?: boolean
    bursite?: boolean
    migraine?: boolean
    diarrhee?: boolean
    phlebite?: boolean
    hypertension?: boolean
    hypoglycemie?: boolean
    burnOut?: boolean
    menopause?: boolean
    inflammationAigue?: boolean
    arteriosclerose?: boolean
    osteoporose?: boolean
    mauxDeDos?: boolean
    fatigueDesJambes?: boolean
    troublesDigestifs?: boolean
    constipation?: boolean
    hyperthyroidie?: boolean
    hypotension?: boolean
    insomnie?: boolean
    depressionNerveuse?: boolean
    autres?: string | null
    lastVisitDate?: Date | string | null
    lastEmailSent?: Date | string | null
    feedbackEmailsSent?: number
    promoEmailsSent?: number
    zonesDouleur?: ClientProfileCreatezonesDouleurInput | string[]
    etatPeau?: string | null
    etatPores?: string | null
    coucheCornee?: string | null
    irrigationSanguine?: string | null
    impuretes?: string | null
    sensibiliteCutanee?: string | null
    fumeur?: string | null
    niveauStress?: string | null
    expositionSoleil?: string | null
    protectionSolaire?: string | null
    suffisanceEau?: string | null
    travailExterieur?: string | null
    bainChauds?: string | null
    routineSoins?: string | null
    changementsRecents?: string | null
    preferencePeau?: string | null
    diagnosticVisuelNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutNotesInput = {
    id?: string
    nom: string
    prenom: string
    adresse: string
    ville: string
    codePostal: string
    telMaison?: string | null
    telBureau?: string | null
    telCellulaire: string
    courriel: string
    dateNaissance: Date | string
    occupation?: string | null
    gender: $Enums.Gender
    serviceType: $Enums.ServiceType
    assuranceCouvert: boolean
    autreMaladie?: boolean | null
    autreMaladieDetails?: string | null
    raisonConsultation?: string | null
    diagnosticMedical?: boolean | null
    diagnosticMedicalDetails?: string | null
    medicaments?: boolean | null
    medicamentsDetails?: string | null
    accidents?: boolean | null
    accidentsDetails?: string | null
    operationsChirurgicales?: boolean | null
    operationsChirurgicalesDetails?: string | null
    traitementsActuels?: string | null
    problemesCardiaques?: boolean
    problemesCardiaquesDetails?: string | null
    maladiesGraves?: boolean
    maladiesGravesDetails?: string | null
    ortheses?: boolean
    orthesesDetails?: string | null
    allergies?: boolean
    allergiesDetails?: string | null
    raideurs?: boolean
    arthrose?: boolean
    hernieDiscale?: boolean
    oedeme?: boolean
    tendinite?: boolean
    mauxDeTete?: boolean
    flatulence?: boolean
    troublesCirculatoires?: boolean
    hypothyroidie?: boolean
    diabete?: boolean
    stresse?: boolean
    premenopause?: boolean
    douleurMusculaire?: boolean
    fibromyalgie?: boolean
    rhumatisme?: boolean
    sciatique?: boolean
    bursite?: boolean
    migraine?: boolean
    diarrhee?: boolean
    phlebite?: boolean
    hypertension?: boolean
    hypoglycemie?: boolean
    burnOut?: boolean
    menopause?: boolean
    inflammationAigue?: boolean
    arteriosclerose?: boolean
    osteoporose?: boolean
    mauxDeDos?: boolean
    fatigueDesJambes?: boolean
    troublesDigestifs?: boolean
    constipation?: boolean
    hyperthyroidie?: boolean
    hypotension?: boolean
    insomnie?: boolean
    depressionNerveuse?: boolean
    autres?: string | null
    lastVisitDate?: Date | string | null
    lastEmailSent?: Date | string | null
    feedbackEmailsSent?: number
    promoEmailsSent?: number
    zonesDouleur?: ClientProfileCreatezonesDouleurInput | string[]
    etatPeau?: string | null
    etatPores?: string | null
    coucheCornee?: string | null
    irrigationSanguine?: string | null
    impuretes?: string | null
    sensibiliteCutanee?: string | null
    fumeur?: string | null
    niveauStress?: string | null
    expositionSoleil?: string | null
    protectionSolaire?: string | null
    suffisanceEau?: string | null
    travailExterieur?: string | null
    bainChauds?: string | null
    routineSoins?: string | null
    changementsRecents?: string | null
    preferencePeau?: string | null
    diagnosticVisuelNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutNotesInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutNotesInput, ClientProfileUncheckedCreateWithoutNotesInput>
  }

  export type UserCreateWithoutNotesCreatedInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedClients?: AssignmentCreateNestedManyWithoutProfessionalInput
    reviewsReceived?: ReviewCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingCreateNestedManyWithoutCreatedByInput
    availabilities?: AvailabilityCreateNestedManyWithoutProfessionalInput
    workingSchedules?: WorkingScheduleCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodCreateNestedManyWithoutProfessionalInput
  }

  export type UserUncheckedCreateWithoutNotesCreatedInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedClients?: AssignmentUncheckedCreateNestedManyWithoutProfessionalInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingUncheckedCreateNestedManyWithoutCreatedByInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutProfessionalInput
    workingSchedules?: WorkingScheduleUncheckedCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodUncheckedCreateNestedManyWithoutProfessionalInput
  }

  export type UserCreateOrConnectWithoutNotesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotesCreatedInput, UserUncheckedCreateWithoutNotesCreatedInput>
  }

  export type ClientProfileUpsertWithoutNotesInput = {
    update: XOR<ClientProfileUpdateWithoutNotesInput, ClientProfileUncheckedUpdateWithoutNotesInput>
    create: XOR<ClientProfileCreateWithoutNotesInput, ClientProfileUncheckedCreateWithoutNotesInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutNotesInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutNotesInput, ClientProfileUncheckedUpdateWithoutNotesInput>
  }

  export type ClientProfileUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    telMaison?: NullableStringFieldUpdateOperationsInput | string | null
    telBureau?: NullableStringFieldUpdateOperationsInput | string | null
    telCellulaire?: StringFieldUpdateOperationsInput | string
    courriel?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    assuranceCouvert?: BoolFieldUpdateOperationsInput | boolean
    autreMaladie?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autreMaladieDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raisonConsultation?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticMedical?: NullableBoolFieldUpdateOperationsInput | boolean | null
    diagnosticMedicalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    medicaments?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicamentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    accidents?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accidentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    operationsChirurgicales?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operationsChirurgicalesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    traitementsActuels?: NullableStringFieldUpdateOperationsInput | string | null
    problemesCardiaques?: BoolFieldUpdateOperationsInput | boolean
    problemesCardiaquesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    maladiesGraves?: BoolFieldUpdateOperationsInput | boolean
    maladiesGravesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    ortheses?: BoolFieldUpdateOperationsInput | boolean
    orthesesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: BoolFieldUpdateOperationsInput | boolean
    allergiesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raideurs?: BoolFieldUpdateOperationsInput | boolean
    arthrose?: BoolFieldUpdateOperationsInput | boolean
    hernieDiscale?: BoolFieldUpdateOperationsInput | boolean
    oedeme?: BoolFieldUpdateOperationsInput | boolean
    tendinite?: BoolFieldUpdateOperationsInput | boolean
    mauxDeTete?: BoolFieldUpdateOperationsInput | boolean
    flatulence?: BoolFieldUpdateOperationsInput | boolean
    troublesCirculatoires?: BoolFieldUpdateOperationsInput | boolean
    hypothyroidie?: BoolFieldUpdateOperationsInput | boolean
    diabete?: BoolFieldUpdateOperationsInput | boolean
    stresse?: BoolFieldUpdateOperationsInput | boolean
    premenopause?: BoolFieldUpdateOperationsInput | boolean
    douleurMusculaire?: BoolFieldUpdateOperationsInput | boolean
    fibromyalgie?: BoolFieldUpdateOperationsInput | boolean
    rhumatisme?: BoolFieldUpdateOperationsInput | boolean
    sciatique?: BoolFieldUpdateOperationsInput | boolean
    bursite?: BoolFieldUpdateOperationsInput | boolean
    migraine?: BoolFieldUpdateOperationsInput | boolean
    diarrhee?: BoolFieldUpdateOperationsInput | boolean
    phlebite?: BoolFieldUpdateOperationsInput | boolean
    hypertension?: BoolFieldUpdateOperationsInput | boolean
    hypoglycemie?: BoolFieldUpdateOperationsInput | boolean
    burnOut?: BoolFieldUpdateOperationsInput | boolean
    menopause?: BoolFieldUpdateOperationsInput | boolean
    inflammationAigue?: BoolFieldUpdateOperationsInput | boolean
    arteriosclerose?: BoolFieldUpdateOperationsInput | boolean
    osteoporose?: BoolFieldUpdateOperationsInput | boolean
    mauxDeDos?: BoolFieldUpdateOperationsInput | boolean
    fatigueDesJambes?: BoolFieldUpdateOperationsInput | boolean
    troublesDigestifs?: BoolFieldUpdateOperationsInput | boolean
    constipation?: BoolFieldUpdateOperationsInput | boolean
    hyperthyroidie?: BoolFieldUpdateOperationsInput | boolean
    hypotension?: BoolFieldUpdateOperationsInput | boolean
    insomnie?: BoolFieldUpdateOperationsInput | boolean
    depressionNerveuse?: BoolFieldUpdateOperationsInput | boolean
    autres?: NullableStringFieldUpdateOperationsInput | string | null
    lastVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackEmailsSent?: IntFieldUpdateOperationsInput | number
    promoEmailsSent?: IntFieldUpdateOperationsInput | number
    zonesDouleur?: ClientProfileUpdatezonesDouleurInput | string[]
    etatPeau?: NullableStringFieldUpdateOperationsInput | string | null
    etatPores?: NullableStringFieldUpdateOperationsInput | string | null
    coucheCornee?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationSanguine?: NullableStringFieldUpdateOperationsInput | string | null
    impuretes?: NullableStringFieldUpdateOperationsInput | string | null
    sensibiliteCutanee?: NullableStringFieldUpdateOperationsInput | string | null
    fumeur?: NullableStringFieldUpdateOperationsInput | string | null
    niveauStress?: NullableStringFieldUpdateOperationsInput | string | null
    expositionSoleil?: NullableStringFieldUpdateOperationsInput | string | null
    protectionSolaire?: NullableStringFieldUpdateOperationsInput | string | null
    suffisanceEau?: NullableStringFieldUpdateOperationsInput | string | null
    travailExterieur?: NullableStringFieldUpdateOperationsInput | string | null
    bainChauds?: NullableStringFieldUpdateOperationsInput | string | null
    routineSoins?: NullableStringFieldUpdateOperationsInput | string | null
    changementsRecents?: NullableStringFieldUpdateOperationsInput | string | null
    preferencePeau?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticVisuelNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    telMaison?: NullableStringFieldUpdateOperationsInput | string | null
    telBureau?: NullableStringFieldUpdateOperationsInput | string | null
    telCellulaire?: StringFieldUpdateOperationsInput | string
    courriel?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    assuranceCouvert?: BoolFieldUpdateOperationsInput | boolean
    autreMaladie?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autreMaladieDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raisonConsultation?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticMedical?: NullableBoolFieldUpdateOperationsInput | boolean | null
    diagnosticMedicalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    medicaments?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicamentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    accidents?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accidentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    operationsChirurgicales?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operationsChirurgicalesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    traitementsActuels?: NullableStringFieldUpdateOperationsInput | string | null
    problemesCardiaques?: BoolFieldUpdateOperationsInput | boolean
    problemesCardiaquesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    maladiesGraves?: BoolFieldUpdateOperationsInput | boolean
    maladiesGravesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    ortheses?: BoolFieldUpdateOperationsInput | boolean
    orthesesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: BoolFieldUpdateOperationsInput | boolean
    allergiesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raideurs?: BoolFieldUpdateOperationsInput | boolean
    arthrose?: BoolFieldUpdateOperationsInput | boolean
    hernieDiscale?: BoolFieldUpdateOperationsInput | boolean
    oedeme?: BoolFieldUpdateOperationsInput | boolean
    tendinite?: BoolFieldUpdateOperationsInput | boolean
    mauxDeTete?: BoolFieldUpdateOperationsInput | boolean
    flatulence?: BoolFieldUpdateOperationsInput | boolean
    troublesCirculatoires?: BoolFieldUpdateOperationsInput | boolean
    hypothyroidie?: BoolFieldUpdateOperationsInput | boolean
    diabete?: BoolFieldUpdateOperationsInput | boolean
    stresse?: BoolFieldUpdateOperationsInput | boolean
    premenopause?: BoolFieldUpdateOperationsInput | boolean
    douleurMusculaire?: BoolFieldUpdateOperationsInput | boolean
    fibromyalgie?: BoolFieldUpdateOperationsInput | boolean
    rhumatisme?: BoolFieldUpdateOperationsInput | boolean
    sciatique?: BoolFieldUpdateOperationsInput | boolean
    bursite?: BoolFieldUpdateOperationsInput | boolean
    migraine?: BoolFieldUpdateOperationsInput | boolean
    diarrhee?: BoolFieldUpdateOperationsInput | boolean
    phlebite?: BoolFieldUpdateOperationsInput | boolean
    hypertension?: BoolFieldUpdateOperationsInput | boolean
    hypoglycemie?: BoolFieldUpdateOperationsInput | boolean
    burnOut?: BoolFieldUpdateOperationsInput | boolean
    menopause?: BoolFieldUpdateOperationsInput | boolean
    inflammationAigue?: BoolFieldUpdateOperationsInput | boolean
    arteriosclerose?: BoolFieldUpdateOperationsInput | boolean
    osteoporose?: BoolFieldUpdateOperationsInput | boolean
    mauxDeDos?: BoolFieldUpdateOperationsInput | boolean
    fatigueDesJambes?: BoolFieldUpdateOperationsInput | boolean
    troublesDigestifs?: BoolFieldUpdateOperationsInput | boolean
    constipation?: BoolFieldUpdateOperationsInput | boolean
    hyperthyroidie?: BoolFieldUpdateOperationsInput | boolean
    hypotension?: BoolFieldUpdateOperationsInput | boolean
    insomnie?: BoolFieldUpdateOperationsInput | boolean
    depressionNerveuse?: BoolFieldUpdateOperationsInput | boolean
    autres?: NullableStringFieldUpdateOperationsInput | string | null
    lastVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackEmailsSent?: IntFieldUpdateOperationsInput | number
    promoEmailsSent?: IntFieldUpdateOperationsInput | number
    zonesDouleur?: ClientProfileUpdatezonesDouleurInput | string[]
    etatPeau?: NullableStringFieldUpdateOperationsInput | string | null
    etatPores?: NullableStringFieldUpdateOperationsInput | string | null
    coucheCornee?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationSanguine?: NullableStringFieldUpdateOperationsInput | string | null
    impuretes?: NullableStringFieldUpdateOperationsInput | string | null
    sensibiliteCutanee?: NullableStringFieldUpdateOperationsInput | string | null
    fumeur?: NullableStringFieldUpdateOperationsInput | string | null
    niveauStress?: NullableStringFieldUpdateOperationsInput | string | null
    expositionSoleil?: NullableStringFieldUpdateOperationsInput | string | null
    protectionSolaire?: NullableStringFieldUpdateOperationsInput | string | null
    suffisanceEau?: NullableStringFieldUpdateOperationsInput | string | null
    travailExterieur?: NullableStringFieldUpdateOperationsInput | string | null
    bainChauds?: NullableStringFieldUpdateOperationsInput | string | null
    routineSoins?: NullableStringFieldUpdateOperationsInput | string | null
    changementsRecents?: NullableStringFieldUpdateOperationsInput | string | null
    preferencePeau?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticVisuelNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutNotesCreatedInput = {
    update: XOR<UserUpdateWithoutNotesCreatedInput, UserUncheckedUpdateWithoutNotesCreatedInput>
    create: XOR<UserCreateWithoutNotesCreatedInput, UserUncheckedCreateWithoutNotesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotesCreatedInput, UserUncheckedUpdateWithoutNotesCreatedInput>
  }

  export type UserUpdateWithoutNotesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedClients?: AssignmentUpdateManyWithoutProfessionalNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUpdateManyWithoutCreatedByNestedInput
    availabilities?: AvailabilityUpdateManyWithoutProfessionalNestedInput
    workingSchedules?: WorkingScheduleUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUpdateManyWithoutProfessionalNestedInput
  }

  export type UserUncheckedUpdateWithoutNotesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedClients?: AssignmentUncheckedUpdateManyWithoutProfessionalNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUncheckedUpdateManyWithoutCreatedByNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutProfessionalNestedInput
    workingSchedules?: WorkingScheduleUncheckedUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUncheckedUpdateManyWithoutProfessionalNestedInput
  }

  export type ClientProfileCreateWithoutAssignmentsInput = {
    id?: string
    nom: string
    prenom: string
    adresse: string
    ville: string
    codePostal: string
    telMaison?: string | null
    telBureau?: string | null
    telCellulaire: string
    courriel: string
    dateNaissance: Date | string
    occupation?: string | null
    gender: $Enums.Gender
    serviceType: $Enums.ServiceType
    assuranceCouvert: boolean
    autreMaladie?: boolean | null
    autreMaladieDetails?: string | null
    raisonConsultation?: string | null
    diagnosticMedical?: boolean | null
    diagnosticMedicalDetails?: string | null
    medicaments?: boolean | null
    medicamentsDetails?: string | null
    accidents?: boolean | null
    accidentsDetails?: string | null
    operationsChirurgicales?: boolean | null
    operationsChirurgicalesDetails?: string | null
    traitementsActuels?: string | null
    problemesCardiaques?: boolean
    problemesCardiaquesDetails?: string | null
    maladiesGraves?: boolean
    maladiesGravesDetails?: string | null
    ortheses?: boolean
    orthesesDetails?: string | null
    allergies?: boolean
    allergiesDetails?: string | null
    raideurs?: boolean
    arthrose?: boolean
    hernieDiscale?: boolean
    oedeme?: boolean
    tendinite?: boolean
    mauxDeTete?: boolean
    flatulence?: boolean
    troublesCirculatoires?: boolean
    hypothyroidie?: boolean
    diabete?: boolean
    stresse?: boolean
    premenopause?: boolean
    douleurMusculaire?: boolean
    fibromyalgie?: boolean
    rhumatisme?: boolean
    sciatique?: boolean
    bursite?: boolean
    migraine?: boolean
    diarrhee?: boolean
    phlebite?: boolean
    hypertension?: boolean
    hypoglycemie?: boolean
    burnOut?: boolean
    menopause?: boolean
    inflammationAigue?: boolean
    arteriosclerose?: boolean
    osteoporose?: boolean
    mauxDeDos?: boolean
    fatigueDesJambes?: boolean
    troublesDigestifs?: boolean
    constipation?: boolean
    hyperthyroidie?: boolean
    hypotension?: boolean
    insomnie?: boolean
    depressionNerveuse?: boolean
    autres?: string | null
    lastVisitDate?: Date | string | null
    lastEmailSent?: Date | string | null
    feedbackEmailsSent?: number
    promoEmailsSent?: number
    zonesDouleur?: ClientProfileCreatezonesDouleurInput | string[]
    etatPeau?: string | null
    etatPores?: string | null
    coucheCornee?: string | null
    irrigationSanguine?: string | null
    impuretes?: string | null
    sensibiliteCutanee?: string | null
    fumeur?: string | null
    niveauStress?: string | null
    expositionSoleil?: string | null
    protectionSolaire?: string | null
    suffisanceEau?: string | null
    travailExterieur?: string | null
    bainChauds?: string | null
    routineSoins?: string | null
    changementsRecents?: string | null
    preferencePeau?: string | null
    diagnosticVisuelNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: NoteCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    nom: string
    prenom: string
    adresse: string
    ville: string
    codePostal: string
    telMaison?: string | null
    telBureau?: string | null
    telCellulaire: string
    courriel: string
    dateNaissance: Date | string
    occupation?: string | null
    gender: $Enums.Gender
    serviceType: $Enums.ServiceType
    assuranceCouvert: boolean
    autreMaladie?: boolean | null
    autreMaladieDetails?: string | null
    raisonConsultation?: string | null
    diagnosticMedical?: boolean | null
    diagnosticMedicalDetails?: string | null
    medicaments?: boolean | null
    medicamentsDetails?: string | null
    accidents?: boolean | null
    accidentsDetails?: string | null
    operationsChirurgicales?: boolean | null
    operationsChirurgicalesDetails?: string | null
    traitementsActuels?: string | null
    problemesCardiaques?: boolean
    problemesCardiaquesDetails?: string | null
    maladiesGraves?: boolean
    maladiesGravesDetails?: string | null
    ortheses?: boolean
    orthesesDetails?: string | null
    allergies?: boolean
    allergiesDetails?: string | null
    raideurs?: boolean
    arthrose?: boolean
    hernieDiscale?: boolean
    oedeme?: boolean
    tendinite?: boolean
    mauxDeTete?: boolean
    flatulence?: boolean
    troublesCirculatoires?: boolean
    hypothyroidie?: boolean
    diabete?: boolean
    stresse?: boolean
    premenopause?: boolean
    douleurMusculaire?: boolean
    fibromyalgie?: boolean
    rhumatisme?: boolean
    sciatique?: boolean
    bursite?: boolean
    migraine?: boolean
    diarrhee?: boolean
    phlebite?: boolean
    hypertension?: boolean
    hypoglycemie?: boolean
    burnOut?: boolean
    menopause?: boolean
    inflammationAigue?: boolean
    arteriosclerose?: boolean
    osteoporose?: boolean
    mauxDeDos?: boolean
    fatigueDesJambes?: boolean
    troublesDigestifs?: boolean
    constipation?: boolean
    hyperthyroidie?: boolean
    hypotension?: boolean
    insomnie?: boolean
    depressionNerveuse?: boolean
    autres?: string | null
    lastVisitDate?: Date | string | null
    lastEmailSent?: Date | string | null
    feedbackEmailsSent?: number
    promoEmailsSent?: number
    zonesDouleur?: ClientProfileCreatezonesDouleurInput | string[]
    etatPeau?: string | null
    etatPores?: string | null
    coucheCornee?: string | null
    irrigationSanguine?: string | null
    impuretes?: string | null
    sensibiliteCutanee?: string | null
    fumeur?: string | null
    niveauStress?: string | null
    expositionSoleil?: string | null
    protectionSolaire?: string | null
    suffisanceEau?: string | null
    travailExterieur?: string | null
    bainChauds?: string | null
    routineSoins?: string | null
    changementsRecents?: string | null
    preferencePeau?: string | null
    diagnosticVisuelNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: NoteUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutAssignmentsInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutAssignmentsInput, ClientProfileUncheckedCreateWithoutAssignmentsInput>
  }

  export type UserCreateWithoutAssignedClientsInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingCreateNestedManyWithoutCreatedByInput
    availabilities?: AvailabilityCreateNestedManyWithoutProfessionalInput
    workingSchedules?: WorkingScheduleCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodCreateNestedManyWithoutProfessionalInput
  }

  export type UserUncheckedCreateWithoutAssignedClientsInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingUncheckedCreateNestedManyWithoutCreatedByInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutProfessionalInput
    workingSchedules?: WorkingScheduleUncheckedCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodUncheckedCreateNestedManyWithoutProfessionalInput
  }

  export type UserCreateOrConnectWithoutAssignedClientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedClientsInput, UserUncheckedCreateWithoutAssignedClientsInput>
  }

  export type ClientProfileUpsertWithoutAssignmentsInput = {
    update: XOR<ClientProfileUpdateWithoutAssignmentsInput, ClientProfileUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ClientProfileCreateWithoutAssignmentsInput, ClientProfileUncheckedCreateWithoutAssignmentsInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutAssignmentsInput, ClientProfileUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ClientProfileUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    telMaison?: NullableStringFieldUpdateOperationsInput | string | null
    telBureau?: NullableStringFieldUpdateOperationsInput | string | null
    telCellulaire?: StringFieldUpdateOperationsInput | string
    courriel?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    assuranceCouvert?: BoolFieldUpdateOperationsInput | boolean
    autreMaladie?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autreMaladieDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raisonConsultation?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticMedical?: NullableBoolFieldUpdateOperationsInput | boolean | null
    diagnosticMedicalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    medicaments?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicamentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    accidents?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accidentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    operationsChirurgicales?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operationsChirurgicalesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    traitementsActuels?: NullableStringFieldUpdateOperationsInput | string | null
    problemesCardiaques?: BoolFieldUpdateOperationsInput | boolean
    problemesCardiaquesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    maladiesGraves?: BoolFieldUpdateOperationsInput | boolean
    maladiesGravesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    ortheses?: BoolFieldUpdateOperationsInput | boolean
    orthesesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: BoolFieldUpdateOperationsInput | boolean
    allergiesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raideurs?: BoolFieldUpdateOperationsInput | boolean
    arthrose?: BoolFieldUpdateOperationsInput | boolean
    hernieDiscale?: BoolFieldUpdateOperationsInput | boolean
    oedeme?: BoolFieldUpdateOperationsInput | boolean
    tendinite?: BoolFieldUpdateOperationsInput | boolean
    mauxDeTete?: BoolFieldUpdateOperationsInput | boolean
    flatulence?: BoolFieldUpdateOperationsInput | boolean
    troublesCirculatoires?: BoolFieldUpdateOperationsInput | boolean
    hypothyroidie?: BoolFieldUpdateOperationsInput | boolean
    diabete?: BoolFieldUpdateOperationsInput | boolean
    stresse?: BoolFieldUpdateOperationsInput | boolean
    premenopause?: BoolFieldUpdateOperationsInput | boolean
    douleurMusculaire?: BoolFieldUpdateOperationsInput | boolean
    fibromyalgie?: BoolFieldUpdateOperationsInput | boolean
    rhumatisme?: BoolFieldUpdateOperationsInput | boolean
    sciatique?: BoolFieldUpdateOperationsInput | boolean
    bursite?: BoolFieldUpdateOperationsInput | boolean
    migraine?: BoolFieldUpdateOperationsInput | boolean
    diarrhee?: BoolFieldUpdateOperationsInput | boolean
    phlebite?: BoolFieldUpdateOperationsInput | boolean
    hypertension?: BoolFieldUpdateOperationsInput | boolean
    hypoglycemie?: BoolFieldUpdateOperationsInput | boolean
    burnOut?: BoolFieldUpdateOperationsInput | boolean
    menopause?: BoolFieldUpdateOperationsInput | boolean
    inflammationAigue?: BoolFieldUpdateOperationsInput | boolean
    arteriosclerose?: BoolFieldUpdateOperationsInput | boolean
    osteoporose?: BoolFieldUpdateOperationsInput | boolean
    mauxDeDos?: BoolFieldUpdateOperationsInput | boolean
    fatigueDesJambes?: BoolFieldUpdateOperationsInput | boolean
    troublesDigestifs?: BoolFieldUpdateOperationsInput | boolean
    constipation?: BoolFieldUpdateOperationsInput | boolean
    hyperthyroidie?: BoolFieldUpdateOperationsInput | boolean
    hypotension?: BoolFieldUpdateOperationsInput | boolean
    insomnie?: BoolFieldUpdateOperationsInput | boolean
    depressionNerveuse?: BoolFieldUpdateOperationsInput | boolean
    autres?: NullableStringFieldUpdateOperationsInput | string | null
    lastVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackEmailsSent?: IntFieldUpdateOperationsInput | number
    promoEmailsSent?: IntFieldUpdateOperationsInput | number
    zonesDouleur?: ClientProfileUpdatezonesDouleurInput | string[]
    etatPeau?: NullableStringFieldUpdateOperationsInput | string | null
    etatPores?: NullableStringFieldUpdateOperationsInput | string | null
    coucheCornee?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationSanguine?: NullableStringFieldUpdateOperationsInput | string | null
    impuretes?: NullableStringFieldUpdateOperationsInput | string | null
    sensibiliteCutanee?: NullableStringFieldUpdateOperationsInput | string | null
    fumeur?: NullableStringFieldUpdateOperationsInput | string | null
    niveauStress?: NullableStringFieldUpdateOperationsInput | string | null
    expositionSoleil?: NullableStringFieldUpdateOperationsInput | string | null
    protectionSolaire?: NullableStringFieldUpdateOperationsInput | string | null
    suffisanceEau?: NullableStringFieldUpdateOperationsInput | string | null
    travailExterieur?: NullableStringFieldUpdateOperationsInput | string | null
    bainChauds?: NullableStringFieldUpdateOperationsInput | string | null
    routineSoins?: NullableStringFieldUpdateOperationsInput | string | null
    changementsRecents?: NullableStringFieldUpdateOperationsInput | string | null
    preferencePeau?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticVisuelNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NoteUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    ville?: StringFieldUpdateOperationsInput | string
    codePostal?: StringFieldUpdateOperationsInput | string
    telMaison?: NullableStringFieldUpdateOperationsInput | string | null
    telBureau?: NullableStringFieldUpdateOperationsInput | string | null
    telCellulaire?: StringFieldUpdateOperationsInput | string
    courriel?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    assuranceCouvert?: BoolFieldUpdateOperationsInput | boolean
    autreMaladie?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autreMaladieDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raisonConsultation?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticMedical?: NullableBoolFieldUpdateOperationsInput | boolean | null
    diagnosticMedicalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    medicaments?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicamentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    accidents?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accidentsDetails?: NullableStringFieldUpdateOperationsInput | string | null
    operationsChirurgicales?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operationsChirurgicalesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    traitementsActuels?: NullableStringFieldUpdateOperationsInput | string | null
    problemesCardiaques?: BoolFieldUpdateOperationsInput | boolean
    problemesCardiaquesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    maladiesGraves?: BoolFieldUpdateOperationsInput | boolean
    maladiesGravesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    ortheses?: BoolFieldUpdateOperationsInput | boolean
    orthesesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: BoolFieldUpdateOperationsInput | boolean
    allergiesDetails?: NullableStringFieldUpdateOperationsInput | string | null
    raideurs?: BoolFieldUpdateOperationsInput | boolean
    arthrose?: BoolFieldUpdateOperationsInput | boolean
    hernieDiscale?: BoolFieldUpdateOperationsInput | boolean
    oedeme?: BoolFieldUpdateOperationsInput | boolean
    tendinite?: BoolFieldUpdateOperationsInput | boolean
    mauxDeTete?: BoolFieldUpdateOperationsInput | boolean
    flatulence?: BoolFieldUpdateOperationsInput | boolean
    troublesCirculatoires?: BoolFieldUpdateOperationsInput | boolean
    hypothyroidie?: BoolFieldUpdateOperationsInput | boolean
    diabete?: BoolFieldUpdateOperationsInput | boolean
    stresse?: BoolFieldUpdateOperationsInput | boolean
    premenopause?: BoolFieldUpdateOperationsInput | boolean
    douleurMusculaire?: BoolFieldUpdateOperationsInput | boolean
    fibromyalgie?: BoolFieldUpdateOperationsInput | boolean
    rhumatisme?: BoolFieldUpdateOperationsInput | boolean
    sciatique?: BoolFieldUpdateOperationsInput | boolean
    bursite?: BoolFieldUpdateOperationsInput | boolean
    migraine?: BoolFieldUpdateOperationsInput | boolean
    diarrhee?: BoolFieldUpdateOperationsInput | boolean
    phlebite?: BoolFieldUpdateOperationsInput | boolean
    hypertension?: BoolFieldUpdateOperationsInput | boolean
    hypoglycemie?: BoolFieldUpdateOperationsInput | boolean
    burnOut?: BoolFieldUpdateOperationsInput | boolean
    menopause?: BoolFieldUpdateOperationsInput | boolean
    inflammationAigue?: BoolFieldUpdateOperationsInput | boolean
    arteriosclerose?: BoolFieldUpdateOperationsInput | boolean
    osteoporose?: BoolFieldUpdateOperationsInput | boolean
    mauxDeDos?: BoolFieldUpdateOperationsInput | boolean
    fatigueDesJambes?: BoolFieldUpdateOperationsInput | boolean
    troublesDigestifs?: BoolFieldUpdateOperationsInput | boolean
    constipation?: BoolFieldUpdateOperationsInput | boolean
    hyperthyroidie?: BoolFieldUpdateOperationsInput | boolean
    hypotension?: BoolFieldUpdateOperationsInput | boolean
    insomnie?: BoolFieldUpdateOperationsInput | boolean
    depressionNerveuse?: BoolFieldUpdateOperationsInput | boolean
    autres?: NullableStringFieldUpdateOperationsInput | string | null
    lastVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackEmailsSent?: IntFieldUpdateOperationsInput | number
    promoEmailsSent?: IntFieldUpdateOperationsInput | number
    zonesDouleur?: ClientProfileUpdatezonesDouleurInput | string[]
    etatPeau?: NullableStringFieldUpdateOperationsInput | string | null
    etatPores?: NullableStringFieldUpdateOperationsInput | string | null
    coucheCornee?: NullableStringFieldUpdateOperationsInput | string | null
    irrigationSanguine?: NullableStringFieldUpdateOperationsInput | string | null
    impuretes?: NullableStringFieldUpdateOperationsInput | string | null
    sensibiliteCutanee?: NullableStringFieldUpdateOperationsInput | string | null
    fumeur?: NullableStringFieldUpdateOperationsInput | string | null
    niveauStress?: NullableStringFieldUpdateOperationsInput | string | null
    expositionSoleil?: NullableStringFieldUpdateOperationsInput | string | null
    protectionSolaire?: NullableStringFieldUpdateOperationsInput | string | null
    suffisanceEau?: NullableStringFieldUpdateOperationsInput | string | null
    travailExterieur?: NullableStringFieldUpdateOperationsInput | string | null
    bainChauds?: NullableStringFieldUpdateOperationsInput | string | null
    routineSoins?: NullableStringFieldUpdateOperationsInput | string | null
    changementsRecents?: NullableStringFieldUpdateOperationsInput | string | null
    preferencePeau?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticVisuelNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NoteUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutAssignedClientsInput = {
    update: XOR<UserUpdateWithoutAssignedClientsInput, UserUncheckedUpdateWithoutAssignedClientsInput>
    create: XOR<UserCreateWithoutAssignedClientsInput, UserUncheckedCreateWithoutAssignedClientsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedClientsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedClientsInput, UserUncheckedUpdateWithoutAssignedClientsInput>
  }

  export type UserUpdateWithoutAssignedClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUpdateManyWithoutCreatedByNestedInput
    availabilities?: AvailabilityUpdateManyWithoutProfessionalNestedInput
    workingSchedules?: WorkingScheduleUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUpdateManyWithoutProfessionalNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUncheckedUpdateManyWithoutCreatedByNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutProfessionalNestedInput
    workingSchedules?: WorkingScheduleUncheckedUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUncheckedUpdateManyWithoutProfessionalNestedInput
  }

  export type UserCreateWithoutReviewsReceivedInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteCreateNestedManyWithoutAuthorInput
    assignedClients?: AssignmentCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingCreateNestedManyWithoutCreatedByInput
    availabilities?: AvailabilityCreateNestedManyWithoutProfessionalInput
    workingSchedules?: WorkingScheduleCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodCreateNestedManyWithoutProfessionalInput
  }

  export type UserUncheckedCreateWithoutReviewsReceivedInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedClients?: AssignmentUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingUncheckedCreateNestedManyWithoutCreatedByInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutProfessionalInput
    workingSchedules?: WorkingScheduleUncheckedCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodUncheckedCreateNestedManyWithoutProfessionalInput
  }

  export type UserCreateOrConnectWithoutReviewsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
  }

  export type UserUpsertWithoutReviewsReceivedInput = {
    update: XOR<UserUpdateWithoutReviewsReceivedInput, UserUncheckedUpdateWithoutReviewsReceivedInput>
    create: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsReceivedInput, UserUncheckedUpdateWithoutReviewsReceivedInput>
  }

  export type UserUpdateWithoutReviewsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUpdateManyWithoutAuthorNestedInput
    assignedClients?: AssignmentUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUpdateManyWithoutCreatedByNestedInput
    availabilities?: AvailabilityUpdateManyWithoutProfessionalNestedInput
    workingSchedules?: WorkingScheduleUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUpdateManyWithoutProfessionalNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedClients?: AssignmentUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUncheckedUpdateManyWithoutCreatedByNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutProfessionalNestedInput
    workingSchedules?: WorkingScheduleUncheckedUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUncheckedUpdateManyWithoutProfessionalNestedInput
  }

  export type ServiceCreateWithoutCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    duration: number
    price: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutServiceInput
    packageServices?: PackageServiceCreateNestedManyWithoutServiceInput
    promotions?: ServicePromotionCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    duration: number
    price: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
    packageServices?: PackageServiceUncheckedCreateNestedManyWithoutServiceInput
    promotions?: ServicePromotionUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceCreateManyCategoryInputEnvelope = {
    data: ServiceCreateManyCategoryInput | ServiceCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>
  }

  export type ServiceUpdateManyWithWhereWithoutCategoryInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    slug?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    duration?: IntFilter<"Service"> | number
    price?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    categoryId?: StringFilter<"Service"> | string
    imageUrl?: StringNullableFilter<"Service"> | string | null
    displayOrder?: IntFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    requiresProfessional?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
  }

  export type ServiceCategoryCreateWithoutServicesInput = {
    id?: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCategoryUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCategoryCreateOrConnectWithoutServicesInput = {
    where: ServiceCategoryWhereUniqueInput
    create: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
  }

  export type BookingCreateWithoutServiceInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    package?: PackageCreateNestedOneWithoutBookingsInput
    professional?: UserCreateNestedOneWithoutBookingsAsProfessionalInput
    giftCard?: GiftCardCreateNestedOneWithoutUsedInBookingsInput
    payment: PaymentCreateNestedOneWithoutBookingInput
    createdBy?: UserCreateNestedOneWithoutBookingsCreatedInput
    statusHistory?: BookingStatusHistoryCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutServiceInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    packageId?: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    professionalId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardId?: string | null
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    paymentId: string
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: BookingStatusHistoryUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutServiceInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput>
  }

  export type BookingCreateManyServiceInputEnvelope = {
    data: BookingCreateManyServiceInput | BookingCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type PackageServiceCreateWithoutServiceInput = {
    id?: string
    quantity?: number
    isOptional?: boolean
    extraCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    package: PackageCreateNestedOneWithoutServicesInput
  }

  export type PackageServiceUncheckedCreateWithoutServiceInput = {
    id?: string
    packageId: string
    quantity?: number
    isOptional?: boolean
    extraCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PackageServiceCreateOrConnectWithoutServiceInput = {
    where: PackageServiceWhereUniqueInput
    create: XOR<PackageServiceCreateWithoutServiceInput, PackageServiceUncheckedCreateWithoutServiceInput>
  }

  export type PackageServiceCreateManyServiceInputEnvelope = {
    data: PackageServiceCreateManyServiceInput | PackageServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServicePromotionCreateWithoutServiceInput = {
    id?: string
    createdAt?: Date | string
    promotion: PromotionCreateNestedOneWithoutServicesInput
  }

  export type ServicePromotionUncheckedCreateWithoutServiceInput = {
    id?: string
    promotionId: string
    createdAt?: Date | string
  }

  export type ServicePromotionCreateOrConnectWithoutServiceInput = {
    where: ServicePromotionWhereUniqueInput
    create: XOR<ServicePromotionCreateWithoutServiceInput, ServicePromotionUncheckedCreateWithoutServiceInput>
  }

  export type ServicePromotionCreateManyServiceInputEnvelope = {
    data: ServicePromotionCreateManyServiceInput | ServicePromotionCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCategoryUpsertWithoutServicesInput = {
    update: XOR<ServiceCategoryUpdateWithoutServicesInput, ServiceCategoryUncheckedUpdateWithoutServicesInput>
    create: XOR<ServiceCategoryCreateWithoutServicesInput, ServiceCategoryUncheckedCreateWithoutServicesInput>
    where?: ServiceCategoryWhereInput
  }

  export type ServiceCategoryUpdateToOneWithWhereWithoutServicesInput = {
    where?: ServiceCategoryWhereInput
    data: XOR<ServiceCategoryUpdateWithoutServicesInput, ServiceCategoryUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceCategoryUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCategoryUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutServiceInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutServiceInput, BookingUncheckedUpdateWithoutServiceInput>
    create: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutServiceInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutServiceInput, BookingUncheckedUpdateWithoutServiceInput>
  }

  export type BookingUpdateManyWithWhereWithoutServiceInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutServiceInput>
  }

  export type PackageServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: PackageServiceWhereUniqueInput
    update: XOR<PackageServiceUpdateWithoutServiceInput, PackageServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<PackageServiceCreateWithoutServiceInput, PackageServiceUncheckedCreateWithoutServiceInput>
  }

  export type PackageServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: PackageServiceWhereUniqueInput
    data: XOR<PackageServiceUpdateWithoutServiceInput, PackageServiceUncheckedUpdateWithoutServiceInput>
  }

  export type PackageServiceUpdateManyWithWhereWithoutServiceInput = {
    where: PackageServiceScalarWhereInput
    data: XOR<PackageServiceUpdateManyMutationInput, PackageServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type PackageServiceScalarWhereInput = {
    AND?: PackageServiceScalarWhereInput | PackageServiceScalarWhereInput[]
    OR?: PackageServiceScalarWhereInput[]
    NOT?: PackageServiceScalarWhereInput | PackageServiceScalarWhereInput[]
    id?: StringFilter<"PackageService"> | string
    packageId?: StringFilter<"PackageService"> | string
    serviceId?: StringFilter<"PackageService"> | string
    quantity?: IntFilter<"PackageService"> | number
    isOptional?: BoolFilter<"PackageService"> | boolean
    extraCost?: DecimalNullableFilter<"PackageService"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"PackageService"> | Date | string
  }

  export type ServicePromotionUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServicePromotionWhereUniqueInput
    update: XOR<ServicePromotionUpdateWithoutServiceInput, ServicePromotionUncheckedUpdateWithoutServiceInput>
    create: XOR<ServicePromotionCreateWithoutServiceInput, ServicePromotionUncheckedCreateWithoutServiceInput>
  }

  export type ServicePromotionUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServicePromotionWhereUniqueInput
    data: XOR<ServicePromotionUpdateWithoutServiceInput, ServicePromotionUncheckedUpdateWithoutServiceInput>
  }

  export type ServicePromotionUpdateManyWithWhereWithoutServiceInput = {
    where: ServicePromotionScalarWhereInput
    data: XOR<ServicePromotionUpdateManyMutationInput, ServicePromotionUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServicePromotionScalarWhereInput = {
    AND?: ServicePromotionScalarWhereInput | ServicePromotionScalarWhereInput[]
    OR?: ServicePromotionScalarWhereInput[]
    NOT?: ServicePromotionScalarWhereInput | ServicePromotionScalarWhereInput[]
    id?: StringFilter<"ServicePromotion"> | string
    promotionId?: StringFilter<"ServicePromotion"> | string
    serviceId?: StringFilter<"ServicePromotion"> | string
    createdAt?: DateTimeFilter<"ServicePromotion"> | Date | string
  }

  export type PackageServiceCreateWithoutPackageInput = {
    id?: string
    quantity?: number
    isOptional?: boolean
    extraCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutPackageServicesInput
  }

  export type PackageServiceUncheckedCreateWithoutPackageInput = {
    id?: string
    serviceId: string
    quantity?: number
    isOptional?: boolean
    extraCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PackageServiceCreateOrConnectWithoutPackageInput = {
    where: PackageServiceWhereUniqueInput
    create: XOR<PackageServiceCreateWithoutPackageInput, PackageServiceUncheckedCreateWithoutPackageInput>
  }

  export type PackageServiceCreateManyPackageInputEnvelope = {
    data: PackageServiceCreateManyPackageInput | PackageServiceCreateManyPackageInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutPackageInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutBookingsInput
    professional?: UserCreateNestedOneWithoutBookingsAsProfessionalInput
    giftCard?: GiftCardCreateNestedOneWithoutUsedInBookingsInput
    payment: PaymentCreateNestedOneWithoutBookingInput
    createdBy?: UserCreateNestedOneWithoutBookingsCreatedInput
    statusHistory?: BookingStatusHistoryCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPackageInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    serviceId?: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    professionalId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardId?: string | null
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    paymentId: string
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: BookingStatusHistoryUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPackageInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPackageInput, BookingUncheckedCreateWithoutPackageInput>
  }

  export type BookingCreateManyPackageInputEnvelope = {
    data: BookingCreateManyPackageInput | BookingCreateManyPackageInput[]
    skipDuplicates?: boolean
  }

  export type PackagePromotionCreateWithoutPackageInput = {
    id?: string
    createdAt?: Date | string
    promotion: PromotionCreateNestedOneWithoutPackagesInput
  }

  export type PackagePromotionUncheckedCreateWithoutPackageInput = {
    id?: string
    promotionId: string
    createdAt?: Date | string
  }

  export type PackagePromotionCreateOrConnectWithoutPackageInput = {
    where: PackagePromotionWhereUniqueInput
    create: XOR<PackagePromotionCreateWithoutPackageInput, PackagePromotionUncheckedCreateWithoutPackageInput>
  }

  export type PackagePromotionCreateManyPackageInputEnvelope = {
    data: PackagePromotionCreateManyPackageInput | PackagePromotionCreateManyPackageInput[]
    skipDuplicates?: boolean
  }

  export type PackageServiceUpsertWithWhereUniqueWithoutPackageInput = {
    where: PackageServiceWhereUniqueInput
    update: XOR<PackageServiceUpdateWithoutPackageInput, PackageServiceUncheckedUpdateWithoutPackageInput>
    create: XOR<PackageServiceCreateWithoutPackageInput, PackageServiceUncheckedCreateWithoutPackageInput>
  }

  export type PackageServiceUpdateWithWhereUniqueWithoutPackageInput = {
    where: PackageServiceWhereUniqueInput
    data: XOR<PackageServiceUpdateWithoutPackageInput, PackageServiceUncheckedUpdateWithoutPackageInput>
  }

  export type PackageServiceUpdateManyWithWhereWithoutPackageInput = {
    where: PackageServiceScalarWhereInput
    data: XOR<PackageServiceUpdateManyMutationInput, PackageServiceUncheckedUpdateManyWithoutPackageInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutPackageInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutPackageInput, BookingUncheckedUpdateWithoutPackageInput>
    create: XOR<BookingCreateWithoutPackageInput, BookingUncheckedCreateWithoutPackageInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutPackageInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutPackageInput, BookingUncheckedUpdateWithoutPackageInput>
  }

  export type BookingUpdateManyWithWhereWithoutPackageInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutPackageInput>
  }

  export type PackagePromotionUpsertWithWhereUniqueWithoutPackageInput = {
    where: PackagePromotionWhereUniqueInput
    update: XOR<PackagePromotionUpdateWithoutPackageInput, PackagePromotionUncheckedUpdateWithoutPackageInput>
    create: XOR<PackagePromotionCreateWithoutPackageInput, PackagePromotionUncheckedCreateWithoutPackageInput>
  }

  export type PackagePromotionUpdateWithWhereUniqueWithoutPackageInput = {
    where: PackagePromotionWhereUniqueInput
    data: XOR<PackagePromotionUpdateWithoutPackageInput, PackagePromotionUncheckedUpdateWithoutPackageInput>
  }

  export type PackagePromotionUpdateManyWithWhereWithoutPackageInput = {
    where: PackagePromotionScalarWhereInput
    data: XOR<PackagePromotionUpdateManyMutationInput, PackagePromotionUncheckedUpdateManyWithoutPackageInput>
  }

  export type PackagePromotionScalarWhereInput = {
    AND?: PackagePromotionScalarWhereInput | PackagePromotionScalarWhereInput[]
    OR?: PackagePromotionScalarWhereInput[]
    NOT?: PackagePromotionScalarWhereInput | PackagePromotionScalarWhereInput[]
    id?: StringFilter<"PackagePromotion"> | string
    promotionId?: StringFilter<"PackagePromotion"> | string
    packageId?: StringFilter<"PackagePromotion"> | string
    createdAt?: DateTimeFilter<"PackagePromotion"> | Date | string
  }

  export type PackageCreateWithoutServicesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    variant?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutPackageInput
    promotions?: PackagePromotionCreateNestedManyWithoutPackageInput
  }

  export type PackageUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    variant?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPackageInput
    promotions?: PackagePromotionUncheckedCreateNestedManyWithoutPackageInput
  }

  export type PackageCreateOrConnectWithoutServicesInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutServicesInput, PackageUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutPackageServicesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    duration: number
    price: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
    promotions?: ServicePromotionCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutPackageServicesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    duration: number
    price: Decimal | DecimalJsLike | number | string
    categoryId: string
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
    promotions?: ServicePromotionUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutPackageServicesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutPackageServicesInput, ServiceUncheckedCreateWithoutPackageServicesInput>
  }

  export type PackageUpsertWithoutServicesInput = {
    update: XOR<PackageUpdateWithoutServicesInput, PackageUncheckedUpdateWithoutServicesInput>
    create: XOR<PackageCreateWithoutServicesInput, PackageUncheckedCreateWithoutServicesInput>
    where?: PackageWhereInput
  }

  export type PackageUpdateToOneWithWhereWithoutServicesInput = {
    where?: PackageWhereInput
    data: XOR<PackageUpdateWithoutServicesInput, PackageUncheckedUpdateWithoutServicesInput>
  }

  export type PackageUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutPackageNestedInput
    promotions?: PackagePromotionUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPackageNestedInput
    promotions?: PackagePromotionUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type ServiceUpsertWithoutPackageServicesInput = {
    update: XOR<ServiceUpdateWithoutPackageServicesInput, ServiceUncheckedUpdateWithoutPackageServicesInput>
    create: XOR<ServiceCreateWithoutPackageServicesInput, ServiceUncheckedCreateWithoutPackageServicesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutPackageServicesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutPackageServicesInput, ServiceUncheckedUpdateWithoutPackageServicesInput>
  }

  export type ServiceUpdateWithoutPackageServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresProfessional?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
    promotions?: ServicePromotionUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutPackageServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresProfessional?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
    promotions?: ServicePromotionUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type BookingCreateWithoutPaymentInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutBookingsInput
    package?: PackageCreateNestedOneWithoutBookingsInput
    professional?: UserCreateNestedOneWithoutBookingsAsProfessionalInput
    giftCard?: GiftCardCreateNestedOneWithoutUsedInBookingsInput
    createdBy?: UserCreateNestedOneWithoutBookingsCreatedInput
    statusHistory?: BookingStatusHistoryCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPaymentInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    serviceId?: string | null
    packageId?: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    professionalId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardId?: string | null
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: BookingStatusHistoryUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPaymentInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
  }

  export type OrderCreateWithoutPaymentInput = {
    id?: string
    orderNumber: string
    clientEmail: string
    clientName: string
    clientPhone: string
    shippingAddress?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentInput = {
    id?: string
    orderNumber: string
    clientEmail: string
    clientName: string
    clientPhone: string
    shippingAddress?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
  }

  export type GiftCardCreateWithoutPaymentInput = {
    id?: string
    code: string
    amount: Decimal | DecimalJsLike | number | string
    balance: Decimal | DecimalJsLike | number | string
    purchasedBy?: string | null
    recipientName?: string | null
    recipientEmail?: string | null
    message?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usedInBookings?: BookingCreateNestedManyWithoutGiftCardInput
  }

  export type GiftCardUncheckedCreateWithoutPaymentInput = {
    id?: string
    code: string
    amount: Decimal | DecimalJsLike | number | string
    balance: Decimal | DecimalJsLike | number | string
    purchasedBy?: string | null
    recipientName?: string | null
    recipientEmail?: string | null
    message?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usedInBookings?: BookingUncheckedCreateNestedManyWithoutGiftCardInput
  }

  export type GiftCardCreateOrConnectWithoutPaymentInput = {
    where: GiftCardWhereUniqueInput
    create: XOR<GiftCardCreateWithoutPaymentInput, GiftCardUncheckedCreateWithoutPaymentInput>
  }

  export type GymSubscriptionCreateWithoutPaymentInput = {
    id?: string
    clientEmail: string
    clientName: string
    clientPhone: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    membership: GymMembershipCreateNestedOneWithoutSubscriptionsInput
  }

  export type GymSubscriptionUncheckedCreateWithoutPaymentInput = {
    id?: string
    membershipId: string
    clientEmail: string
    clientName: string
    clientPhone: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymSubscriptionCreateOrConnectWithoutPaymentInput = {
    where: GymSubscriptionWhereUniqueInput
    create: XOR<GymSubscriptionCreateWithoutPaymentInput, GymSubscriptionUncheckedCreateWithoutPaymentInput>
  }

  export type BookingUpsertWithoutPaymentInput = {
    update: XOR<BookingUpdateWithoutPaymentInput, BookingUncheckedUpdateWithoutPaymentInput>
    create: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentInput, BookingUncheckedUpdateWithoutPaymentInput>
  }

  export type BookingUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutBookingsNestedInput
    package?: PackageUpdateOneWithoutBookingsNestedInput
    professional?: UserUpdateOneWithoutBookingsAsProfessionalNestedInput
    giftCard?: GiftCardUpdateOneWithoutUsedInBookingsNestedInput
    createdBy?: UserUpdateOneWithoutBookingsCreatedNestedInput
    statusHistory?: BookingStatusHistoryUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    professionalId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardId?: NullableStringFieldUpdateOperationsInput | string | null
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: BookingStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type OrderUpsertWithoutPaymentInput = {
    update: XOR<OrderUpdateWithoutPaymentInput, OrderUncheckedUpdateWithoutPaymentInput>
    create: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentInput, OrderUncheckedUpdateWithoutPaymentInput>
  }

  export type OrderUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type GiftCardUpsertWithoutPaymentInput = {
    update: XOR<GiftCardUpdateWithoutPaymentInput, GiftCardUncheckedUpdateWithoutPaymentInput>
    create: XOR<GiftCardCreateWithoutPaymentInput, GiftCardUncheckedCreateWithoutPaymentInput>
    where?: GiftCardWhereInput
  }

  export type GiftCardUpdateToOneWithWhereWithoutPaymentInput = {
    where?: GiftCardWhereInput
    data: XOR<GiftCardUpdateWithoutPaymentInput, GiftCardUncheckedUpdateWithoutPaymentInput>
  }

  export type GiftCardUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchasedBy?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedInBookings?: BookingUpdateManyWithoutGiftCardNestedInput
  }

  export type GiftCardUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchasedBy?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedInBookings?: BookingUncheckedUpdateManyWithoutGiftCardNestedInput
  }

  export type GymSubscriptionUpsertWithoutPaymentInput = {
    update: XOR<GymSubscriptionUpdateWithoutPaymentInput, GymSubscriptionUncheckedUpdateWithoutPaymentInput>
    create: XOR<GymSubscriptionCreateWithoutPaymentInput, GymSubscriptionUncheckedCreateWithoutPaymentInput>
    where?: GymSubscriptionWhereInput
  }

  export type GymSubscriptionUpdateToOneWithWhereWithoutPaymentInput = {
    where?: GymSubscriptionWhereInput
    data: XOR<GymSubscriptionUpdateWithoutPaymentInput, GymSubscriptionUncheckedUpdateWithoutPaymentInput>
  }

  export type GymSubscriptionUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: GymMembershipUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type GymSubscriptionUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    membershipId?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateWithoutBookingsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    duration: number
    price: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    packageServices?: PackageServiceCreateNestedManyWithoutServiceInput
    promotions?: ServicePromotionCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    duration: number
    price: Decimal | DecimalJsLike | number | string
    categoryId: string
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    packageServices?: PackageServiceUncheckedCreateNestedManyWithoutServiceInput
    promotions?: ServicePromotionUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutBookingsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
  }

  export type PackageCreateWithoutBookingsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    variant?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: PackageServiceCreateNestedManyWithoutPackageInput
    promotions?: PackagePromotionCreateNestedManyWithoutPackageInput
  }

  export type PackageUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    variant?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: PackageServiceUncheckedCreateNestedManyWithoutPackageInput
    promotions?: PackagePromotionUncheckedCreateNestedManyWithoutPackageInput
  }

  export type PackageCreateOrConnectWithoutBookingsInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutBookingsInput, PackageUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutBookingsAsProfessionalInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteCreateNestedManyWithoutAuthorInput
    assignedClients?: AssignmentCreateNestedManyWithoutProfessionalInput
    reviewsReceived?: ReviewCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingCreateNestedManyWithoutCreatedByInput
    availabilities?: AvailabilityCreateNestedManyWithoutProfessionalInput
    workingSchedules?: WorkingScheduleCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodCreateNestedManyWithoutProfessionalInput
  }

  export type UserUncheckedCreateWithoutBookingsAsProfessionalInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedClients?: AssignmentUncheckedCreateNestedManyWithoutProfessionalInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingUncheckedCreateNestedManyWithoutCreatedByInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutProfessionalInput
    workingSchedules?: WorkingScheduleUncheckedCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodUncheckedCreateNestedManyWithoutProfessionalInput
  }

  export type UserCreateOrConnectWithoutBookingsAsProfessionalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsAsProfessionalInput, UserUncheckedCreateWithoutBookingsAsProfessionalInput>
  }

  export type GiftCardCreateWithoutUsedInBookingsInput = {
    id?: string
    code: string
    amount: Decimal | DecimalJsLike | number | string
    balance: Decimal | DecimalJsLike | number | string
    purchasedBy?: string | null
    recipientName?: string | null
    recipientEmail?: string | null
    message?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment: PaymentCreateNestedOneWithoutGiftCardInput
  }

  export type GiftCardUncheckedCreateWithoutUsedInBookingsInput = {
    id?: string
    code: string
    amount: Decimal | DecimalJsLike | number | string
    balance: Decimal | DecimalJsLike | number | string
    purchasedBy?: string | null
    recipientName?: string | null
    recipientEmail?: string | null
    message?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    paymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GiftCardCreateOrConnectWithoutUsedInBookingsInput = {
    where: GiftCardWhereUniqueInput
    create: XOR<GiftCardCreateWithoutUsedInBookingsInput, GiftCardUncheckedCreateWithoutUsedInBookingsInput>
  }

  export type PaymentCreateWithoutBookingInput = {
    id?: string
    stripePaymentId?: string | null
    stripeCustomerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    receiptUrl?: string | null
    receiptPdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutPaymentInput
    giftCard?: GiftCardCreateNestedOneWithoutPaymentInput
    gymSubscription?: GymSubscriptionCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    id?: string
    stripePaymentId?: string | null
    stripeCustomerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    receiptUrl?: string | null
    receiptPdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderUncheckedCreateNestedOneWithoutPaymentInput
    giftCard?: GiftCardUncheckedCreateNestedOneWithoutPaymentInput
    gymSubscription?: GymSubscriptionUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type UserCreateWithoutBookingsCreatedInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteCreateNestedManyWithoutAuthorInput
    assignedClients?: AssignmentCreateNestedManyWithoutProfessionalInput
    reviewsReceived?: ReviewCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingCreateNestedManyWithoutProfessionalInput
    availabilities?: AvailabilityCreateNestedManyWithoutProfessionalInput
    workingSchedules?: WorkingScheduleCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodCreateNestedManyWithoutProfessionalInput
  }

  export type UserUncheckedCreateWithoutBookingsCreatedInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedClients?: AssignmentUncheckedCreateNestedManyWithoutProfessionalInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingUncheckedCreateNestedManyWithoutProfessionalInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutProfessionalInput
    workingSchedules?: WorkingScheduleUncheckedCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodUncheckedCreateNestedManyWithoutProfessionalInput
  }

  export type UserCreateOrConnectWithoutBookingsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsCreatedInput, UserUncheckedCreateWithoutBookingsCreatedInput>
  }

  export type BookingStatusHistoryCreateWithoutBookingInput = {
    id?: string
    oldStatus?: $Enums.BookingStatus | null
    newStatus: $Enums.BookingStatus
    changedById: string
    changedBy: string
    changedByRole: string
    reason?: string | null
    notes?: string | null
    oldDate?: Date | string | null
    newDate?: Date | string | null
    oldStartTime?: string | null
    newStartTime?: string | null
    oldEndTime?: string | null
    newEndTime?: string | null
    oldProfessionalId?: string | null
    newProfessionalId?: string | null
    changedAt?: Date | string
  }

  export type BookingStatusHistoryUncheckedCreateWithoutBookingInput = {
    id?: string
    oldStatus?: $Enums.BookingStatus | null
    newStatus: $Enums.BookingStatus
    changedById: string
    changedBy: string
    changedByRole: string
    reason?: string | null
    notes?: string | null
    oldDate?: Date | string | null
    newDate?: Date | string | null
    oldStartTime?: string | null
    newStartTime?: string | null
    oldEndTime?: string | null
    newEndTime?: string | null
    oldProfessionalId?: string | null
    newProfessionalId?: string | null
    changedAt?: Date | string
  }

  export type BookingStatusHistoryCreateOrConnectWithoutBookingInput = {
    where: BookingStatusHistoryWhereUniqueInput
    create: XOR<BookingStatusHistoryCreateWithoutBookingInput, BookingStatusHistoryUncheckedCreateWithoutBookingInput>
  }

  export type BookingStatusHistoryCreateManyBookingInputEnvelope = {
    data: BookingStatusHistoryCreateManyBookingInput | BookingStatusHistoryCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithoutBookingsInput = {
    update: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresProfessional?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    packageServices?: PackageServiceUpdateManyWithoutServiceNestedInput
    promotions?: ServicePromotionUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresProfessional?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    packageServices?: PackageServiceUncheckedUpdateManyWithoutServiceNestedInput
    promotions?: ServicePromotionUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type PackageUpsertWithoutBookingsInput = {
    update: XOR<PackageUpdateWithoutBookingsInput, PackageUncheckedUpdateWithoutBookingsInput>
    create: XOR<PackageCreateWithoutBookingsInput, PackageUncheckedCreateWithoutBookingsInput>
    where?: PackageWhereInput
  }

  export type PackageUpdateToOneWithWhereWithoutBookingsInput = {
    where?: PackageWhereInput
    data: XOR<PackageUpdateWithoutBookingsInput, PackageUncheckedUpdateWithoutBookingsInput>
  }

  export type PackageUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: PackageServiceUpdateManyWithoutPackageNestedInput
    promotions?: PackagePromotionUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: PackageServiceUncheckedUpdateManyWithoutPackageNestedInput
    promotions?: PackagePromotionUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type UserUpsertWithoutBookingsAsProfessionalInput = {
    update: XOR<UserUpdateWithoutBookingsAsProfessionalInput, UserUncheckedUpdateWithoutBookingsAsProfessionalInput>
    create: XOR<UserCreateWithoutBookingsAsProfessionalInput, UserUncheckedCreateWithoutBookingsAsProfessionalInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsAsProfessionalInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsAsProfessionalInput, UserUncheckedUpdateWithoutBookingsAsProfessionalInput>
  }

  export type UserUpdateWithoutBookingsAsProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUpdateManyWithoutAuthorNestedInput
    assignedClients?: AssignmentUpdateManyWithoutProfessionalNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUpdateManyWithoutCreatedByNestedInput
    availabilities?: AvailabilityUpdateManyWithoutProfessionalNestedInput
    workingSchedules?: WorkingScheduleUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUpdateManyWithoutProfessionalNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsAsProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedClients?: AssignmentUncheckedUpdateManyWithoutProfessionalNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUncheckedUpdateManyWithoutCreatedByNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutProfessionalNestedInput
    workingSchedules?: WorkingScheduleUncheckedUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUncheckedUpdateManyWithoutProfessionalNestedInput
  }

  export type GiftCardUpsertWithoutUsedInBookingsInput = {
    update: XOR<GiftCardUpdateWithoutUsedInBookingsInput, GiftCardUncheckedUpdateWithoutUsedInBookingsInput>
    create: XOR<GiftCardCreateWithoutUsedInBookingsInput, GiftCardUncheckedCreateWithoutUsedInBookingsInput>
    where?: GiftCardWhereInput
  }

  export type GiftCardUpdateToOneWithWhereWithoutUsedInBookingsInput = {
    where?: GiftCardWhereInput
    data: XOR<GiftCardUpdateWithoutUsedInBookingsInput, GiftCardUncheckedUpdateWithoutUsedInBookingsInput>
  }

  export type GiftCardUpdateWithoutUsedInBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchasedBy?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutGiftCardNestedInput
  }

  export type GiftCardUncheckedUpdateWithoutUsedInBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchasedBy?: NullableStringFieldUpdateOperationsInput | string | null
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithoutBookingInput = {
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutBookingInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutPaymentNestedInput
    giftCard?: GiftCardUpdateOneWithoutPaymentNestedInput
    gymSubscription?: GymSubscriptionUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUncheckedUpdateOneWithoutPaymentNestedInput
    giftCard?: GiftCardUncheckedUpdateOneWithoutPaymentNestedInput
    gymSubscription?: GymSubscriptionUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type UserUpsertWithoutBookingsCreatedInput = {
    update: XOR<UserUpdateWithoutBookingsCreatedInput, UserUncheckedUpdateWithoutBookingsCreatedInput>
    create: XOR<UserCreateWithoutBookingsCreatedInput, UserUncheckedCreateWithoutBookingsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsCreatedInput, UserUncheckedUpdateWithoutBookingsCreatedInput>
  }

  export type UserUpdateWithoutBookingsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUpdateManyWithoutAuthorNestedInput
    assignedClients?: AssignmentUpdateManyWithoutProfessionalNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUpdateManyWithoutProfessionalNestedInput
    availabilities?: AvailabilityUpdateManyWithoutProfessionalNestedInput
    workingSchedules?: WorkingScheduleUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUpdateManyWithoutProfessionalNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedClients?: AssignmentUncheckedUpdateManyWithoutProfessionalNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUncheckedUpdateManyWithoutProfessionalNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutProfessionalNestedInput
    workingSchedules?: WorkingScheduleUncheckedUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUncheckedUpdateManyWithoutProfessionalNestedInput
  }

  export type BookingStatusHistoryUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingStatusHistoryWhereUniqueInput
    update: XOR<BookingStatusHistoryUpdateWithoutBookingInput, BookingStatusHistoryUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingStatusHistoryCreateWithoutBookingInput, BookingStatusHistoryUncheckedCreateWithoutBookingInput>
  }

  export type BookingStatusHistoryUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingStatusHistoryWhereUniqueInput
    data: XOR<BookingStatusHistoryUpdateWithoutBookingInput, BookingStatusHistoryUncheckedUpdateWithoutBookingInput>
  }

  export type BookingStatusHistoryUpdateManyWithWhereWithoutBookingInput = {
    where: BookingStatusHistoryScalarWhereInput
    data: XOR<BookingStatusHistoryUpdateManyMutationInput, BookingStatusHistoryUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingStatusHistoryScalarWhereInput = {
    AND?: BookingStatusHistoryScalarWhereInput | BookingStatusHistoryScalarWhereInput[]
    OR?: BookingStatusHistoryScalarWhereInput[]
    NOT?: BookingStatusHistoryScalarWhereInput | BookingStatusHistoryScalarWhereInput[]
    id?: StringFilter<"BookingStatusHistory"> | string
    bookingId?: StringFilter<"BookingStatusHistory"> | string
    oldStatus?: EnumBookingStatusNullableFilter<"BookingStatusHistory"> | $Enums.BookingStatus | null
    newStatus?: EnumBookingStatusFilter<"BookingStatusHistory"> | $Enums.BookingStatus
    changedById?: StringFilter<"BookingStatusHistory"> | string
    changedBy?: StringFilter<"BookingStatusHistory"> | string
    changedByRole?: StringFilter<"BookingStatusHistory"> | string
    reason?: StringNullableFilter<"BookingStatusHistory"> | string | null
    notes?: StringNullableFilter<"BookingStatusHistory"> | string | null
    oldDate?: DateTimeNullableFilter<"BookingStatusHistory"> | Date | string | null
    newDate?: DateTimeNullableFilter<"BookingStatusHistory"> | Date | string | null
    oldStartTime?: StringNullableFilter<"BookingStatusHistory"> | string | null
    newStartTime?: StringNullableFilter<"BookingStatusHistory"> | string | null
    oldEndTime?: StringNullableFilter<"BookingStatusHistory"> | string | null
    newEndTime?: StringNullableFilter<"BookingStatusHistory"> | string | null
    oldProfessionalId?: StringNullableFilter<"BookingStatusHistory"> | string | null
    newProfessionalId?: StringNullableFilter<"BookingStatusHistory"> | string | null
    changedAt?: DateTimeFilter<"BookingStatusHistory"> | Date | string
  }

  export type UserCreateWithoutAvailabilitiesInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteCreateNestedManyWithoutAuthorInput
    assignedClients?: AssignmentCreateNestedManyWithoutProfessionalInput
    reviewsReceived?: ReviewCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingCreateNestedManyWithoutCreatedByInput
    workingSchedules?: WorkingScheduleCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodCreateNestedManyWithoutProfessionalInput
  }

  export type UserUncheckedCreateWithoutAvailabilitiesInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedClients?: AssignmentUncheckedCreateNestedManyWithoutProfessionalInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingUncheckedCreateNestedManyWithoutCreatedByInput
    workingSchedules?: WorkingScheduleUncheckedCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodUncheckedCreateNestedManyWithoutProfessionalInput
  }

  export type UserCreateOrConnectWithoutAvailabilitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAvailabilitiesInput, UserUncheckedCreateWithoutAvailabilitiesInput>
  }

  export type UserUpsertWithoutAvailabilitiesInput = {
    update: XOR<UserUpdateWithoutAvailabilitiesInput, UserUncheckedUpdateWithoutAvailabilitiesInput>
    create: XOR<UserCreateWithoutAvailabilitiesInput, UserUncheckedCreateWithoutAvailabilitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAvailabilitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAvailabilitiesInput, UserUncheckedUpdateWithoutAvailabilitiesInput>
  }

  export type UserUpdateWithoutAvailabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUpdateManyWithoutAuthorNestedInput
    assignedClients?: AssignmentUpdateManyWithoutProfessionalNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUpdateManyWithoutCreatedByNestedInput
    workingSchedules?: WorkingScheduleUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUpdateManyWithoutProfessionalNestedInput
  }

  export type UserUncheckedUpdateWithoutAvailabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedClients?: AssignmentUncheckedUpdateManyWithoutProfessionalNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUncheckedUpdateManyWithoutCreatedByNestedInput
    workingSchedules?: WorkingScheduleUncheckedUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUncheckedUpdateManyWithoutProfessionalNestedInput
  }

  export type PaymentCreateWithoutGiftCardInput = {
    id?: string
    stripePaymentId?: string | null
    stripeCustomerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    receiptUrl?: string | null
    receiptPdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedOneWithoutPaymentInput
    order?: OrderCreateNestedOneWithoutPaymentInput
    gymSubscription?: GymSubscriptionCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutGiftCardInput = {
    id?: string
    stripePaymentId?: string | null
    stripeCustomerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    receiptUrl?: string | null
    receiptPdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedOneWithoutPaymentInput
    order?: OrderUncheckedCreateNestedOneWithoutPaymentInput
    gymSubscription?: GymSubscriptionUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutGiftCardInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutGiftCardInput, PaymentUncheckedCreateWithoutGiftCardInput>
  }

  export type BookingCreateWithoutGiftCardInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutBookingsInput
    package?: PackageCreateNestedOneWithoutBookingsInput
    professional?: UserCreateNestedOneWithoutBookingsAsProfessionalInput
    payment: PaymentCreateNestedOneWithoutBookingInput
    createdBy?: UserCreateNestedOneWithoutBookingsCreatedInput
    statusHistory?: BookingStatusHistoryCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutGiftCardInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    serviceId?: string | null
    packageId?: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    professionalId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    paymentId: string
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: BookingStatusHistoryUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutGiftCardInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutGiftCardInput, BookingUncheckedCreateWithoutGiftCardInput>
  }

  export type BookingCreateManyGiftCardInputEnvelope = {
    data: BookingCreateManyGiftCardInput | BookingCreateManyGiftCardInput[]
    skipDuplicates?: boolean
  }

  export type PaymentUpsertWithoutGiftCardInput = {
    update: XOR<PaymentUpdateWithoutGiftCardInput, PaymentUncheckedUpdateWithoutGiftCardInput>
    create: XOR<PaymentCreateWithoutGiftCardInput, PaymentUncheckedCreateWithoutGiftCardInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutGiftCardInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutGiftCardInput, PaymentUncheckedUpdateWithoutGiftCardInput>
  }

  export type PaymentUpdateWithoutGiftCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutPaymentNestedInput
    order?: OrderUpdateOneWithoutPaymentNestedInput
    gymSubscription?: GymSubscriptionUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutGiftCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateOneWithoutPaymentNestedInput
    order?: OrderUncheckedUpdateOneWithoutPaymentNestedInput
    gymSubscription?: GymSubscriptionUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutGiftCardInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutGiftCardInput, BookingUncheckedUpdateWithoutGiftCardInput>
    create: XOR<BookingCreateWithoutGiftCardInput, BookingUncheckedCreateWithoutGiftCardInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutGiftCardInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutGiftCardInput, BookingUncheckedUpdateWithoutGiftCardInput>
  }

  export type BookingUpdateManyWithWhereWithoutGiftCardInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutGiftCardInput>
  }

  export type GymSubscriptionCreateWithoutMembershipInput = {
    id?: string
    clientEmail: string
    clientName: string
    clientPhone: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    payment: PaymentCreateNestedOneWithoutGymSubscriptionInput
  }

  export type GymSubscriptionUncheckedCreateWithoutMembershipInput = {
    id?: string
    clientEmail: string
    clientName: string
    clientPhone: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    paymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymSubscriptionCreateOrConnectWithoutMembershipInput = {
    where: GymSubscriptionWhereUniqueInput
    create: XOR<GymSubscriptionCreateWithoutMembershipInput, GymSubscriptionUncheckedCreateWithoutMembershipInput>
  }

  export type GymSubscriptionCreateManyMembershipInputEnvelope = {
    data: GymSubscriptionCreateManyMembershipInput | GymSubscriptionCreateManyMembershipInput[]
    skipDuplicates?: boolean
  }

  export type GymSubscriptionUpsertWithWhereUniqueWithoutMembershipInput = {
    where: GymSubscriptionWhereUniqueInput
    update: XOR<GymSubscriptionUpdateWithoutMembershipInput, GymSubscriptionUncheckedUpdateWithoutMembershipInput>
    create: XOR<GymSubscriptionCreateWithoutMembershipInput, GymSubscriptionUncheckedCreateWithoutMembershipInput>
  }

  export type GymSubscriptionUpdateWithWhereUniqueWithoutMembershipInput = {
    where: GymSubscriptionWhereUniqueInput
    data: XOR<GymSubscriptionUpdateWithoutMembershipInput, GymSubscriptionUncheckedUpdateWithoutMembershipInput>
  }

  export type GymSubscriptionUpdateManyWithWhereWithoutMembershipInput = {
    where: GymSubscriptionScalarWhereInput
    data: XOR<GymSubscriptionUpdateManyMutationInput, GymSubscriptionUncheckedUpdateManyWithoutMembershipInput>
  }

  export type GymSubscriptionScalarWhereInput = {
    AND?: GymSubscriptionScalarWhereInput | GymSubscriptionScalarWhereInput[]
    OR?: GymSubscriptionScalarWhereInput[]
    NOT?: GymSubscriptionScalarWhereInput | GymSubscriptionScalarWhereInput[]
    id?: StringFilter<"GymSubscription"> | string
    membershipId?: StringFilter<"GymSubscription"> | string
    clientEmail?: StringFilter<"GymSubscription"> | string
    clientName?: StringFilter<"GymSubscription"> | string
    clientPhone?: StringFilter<"GymSubscription"> | string
    startDate?: DateTimeFilter<"GymSubscription"> | Date | string
    endDate?: DateTimeFilter<"GymSubscription"> | Date | string
    isActive?: BoolFilter<"GymSubscription"> | boolean
    paymentId?: StringFilter<"GymSubscription"> | string
    createdAt?: DateTimeFilter<"GymSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"GymSubscription"> | Date | string
  }

  export type GymMembershipCreateWithoutSubscriptionsInput = {
    id?: string
    type: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration: number
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymMembershipUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    type: string
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration: number
    description?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymMembershipCreateOrConnectWithoutSubscriptionsInput = {
    where: GymMembershipWhereUniqueInput
    create: XOR<GymMembershipCreateWithoutSubscriptionsInput, GymMembershipUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PaymentCreateWithoutGymSubscriptionInput = {
    id?: string
    stripePaymentId?: string | null
    stripeCustomerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    receiptUrl?: string | null
    receiptPdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedOneWithoutPaymentInput
    order?: OrderCreateNestedOneWithoutPaymentInput
    giftCard?: GiftCardCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutGymSubscriptionInput = {
    id?: string
    stripePaymentId?: string | null
    stripeCustomerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    receiptUrl?: string | null
    receiptPdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedOneWithoutPaymentInput
    order?: OrderUncheckedCreateNestedOneWithoutPaymentInput
    giftCard?: GiftCardUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutGymSubscriptionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutGymSubscriptionInput, PaymentUncheckedCreateWithoutGymSubscriptionInput>
  }

  export type GymMembershipUpsertWithoutSubscriptionsInput = {
    update: XOR<GymMembershipUpdateWithoutSubscriptionsInput, GymMembershipUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<GymMembershipCreateWithoutSubscriptionsInput, GymMembershipUncheckedCreateWithoutSubscriptionsInput>
    where?: GymMembershipWhereInput
  }

  export type GymMembershipUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: GymMembershipWhereInput
    data: XOR<GymMembershipUpdateWithoutSubscriptionsInput, GymMembershipUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type GymMembershipUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymMembershipUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithoutGymSubscriptionInput = {
    update: XOR<PaymentUpdateWithoutGymSubscriptionInput, PaymentUncheckedUpdateWithoutGymSubscriptionInput>
    create: XOR<PaymentCreateWithoutGymSubscriptionInput, PaymentUncheckedCreateWithoutGymSubscriptionInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutGymSubscriptionInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutGymSubscriptionInput, PaymentUncheckedUpdateWithoutGymSubscriptionInput>
  }

  export type PaymentUpdateWithoutGymSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutPaymentNestedInput
    order?: OrderUpdateOneWithoutPaymentNestedInput
    giftCard?: GiftCardUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutGymSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateOneWithoutPaymentNestedInput
    order?: OrderUncheckedUpdateOneWithoutPaymentNestedInput
    giftCard?: GiftCardUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    orderId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductPromotionCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    promotion: PromotionCreateNestedOneWithoutProductsInput
  }

  export type ProductPromotionUncheckedCreateWithoutProductInput = {
    id?: string
    promotionId: string
    createdAt?: Date | string
  }

  export type ProductPromotionCreateOrConnectWithoutProductInput = {
    where: ProductPromotionWhereUniqueInput
    create: XOR<ProductPromotionCreateWithoutProductInput, ProductPromotionUncheckedCreateWithoutProductInput>
  }

  export type ProductPromotionCreateManyProductInputEnvelope = {
    data: ProductPromotionCreateManyProductInput | ProductPromotionCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type ProductPromotionUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductPromotionWhereUniqueInput
    update: XOR<ProductPromotionUpdateWithoutProductInput, ProductPromotionUncheckedUpdateWithoutProductInput>
    create: XOR<ProductPromotionCreateWithoutProductInput, ProductPromotionUncheckedCreateWithoutProductInput>
  }

  export type ProductPromotionUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductPromotionWhereUniqueInput
    data: XOR<ProductPromotionUpdateWithoutProductInput, ProductPromotionUncheckedUpdateWithoutProductInput>
  }

  export type ProductPromotionUpdateManyWithWhereWithoutProductInput = {
    where: ProductPromotionScalarWhereInput
    data: XOR<ProductPromotionUpdateManyMutationInput, ProductPromotionUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductPromotionScalarWhereInput = {
    AND?: ProductPromotionScalarWhereInput | ProductPromotionScalarWhereInput[]
    OR?: ProductPromotionScalarWhereInput[]
    NOT?: ProductPromotionScalarWhereInput | ProductPromotionScalarWhereInput[]
    id?: StringFilter<"ProductPromotion"> | string
    promotionId?: StringFilter<"ProductPromotion"> | string
    productId?: StringFilter<"ProductPromotion"> | string
    createdAt?: DateTimeFilter<"ProductPromotion"> | Date | string
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    stripePaymentId?: string | null
    stripeCustomerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    receiptUrl?: string | null
    receiptPdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedOneWithoutPaymentInput
    giftCard?: GiftCardCreateNestedOneWithoutPaymentInput
    gymSubscription?: GymSubscriptionCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    stripePaymentId?: string | null
    stripeCustomerId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    receiptUrl?: string | null
    receiptPdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedOneWithoutPaymentInput
    giftCard?: GiftCardUncheckedCreateNestedOneWithoutPaymentInput
    gymSubscription?: GymSubscriptionUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    productId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentUpsertWithoutOrderInput = {
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutOrderInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutPaymentNestedInput
    giftCard?: GiftCardUpdateOneWithoutPaymentNestedInput
    gymSubscription?: GymSubscriptionUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateOneWithoutPaymentNestedInput
    giftCard?: GiftCardUncheckedUpdateOneWithoutPaymentNestedInput
    gymSubscription?: GymSubscriptionUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    clientEmail: string
    clientName: string
    clientPhone: string
    shippingAddress?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payment: PaymentCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    clientEmail: string
    clientName: string
    clientPhone: string
    shippingAddress?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    paymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    stock?: number
    category?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    promotions?: ProductPromotionCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    stock?: number
    category?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    promotions?: ProductPromotionUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotions?: ProductPromotionUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotions?: ProductPromotionUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ServicePromotionCreateWithoutPromotionInput = {
    id?: string
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutPromotionsInput
  }

  export type ServicePromotionUncheckedCreateWithoutPromotionInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
  }

  export type ServicePromotionCreateOrConnectWithoutPromotionInput = {
    where: ServicePromotionWhereUniqueInput
    create: XOR<ServicePromotionCreateWithoutPromotionInput, ServicePromotionUncheckedCreateWithoutPromotionInput>
  }

  export type ServicePromotionCreateManyPromotionInputEnvelope = {
    data: ServicePromotionCreateManyPromotionInput | ServicePromotionCreateManyPromotionInput[]
    skipDuplicates?: boolean
  }

  export type PackagePromotionCreateWithoutPromotionInput = {
    id?: string
    createdAt?: Date | string
    package: PackageCreateNestedOneWithoutPromotionsInput
  }

  export type PackagePromotionUncheckedCreateWithoutPromotionInput = {
    id?: string
    packageId: string
    createdAt?: Date | string
  }

  export type PackagePromotionCreateOrConnectWithoutPromotionInput = {
    where: PackagePromotionWhereUniqueInput
    create: XOR<PackagePromotionCreateWithoutPromotionInput, PackagePromotionUncheckedCreateWithoutPromotionInput>
  }

  export type PackagePromotionCreateManyPromotionInputEnvelope = {
    data: PackagePromotionCreateManyPromotionInput | PackagePromotionCreateManyPromotionInput[]
    skipDuplicates?: boolean
  }

  export type ProductPromotionCreateWithoutPromotionInput = {
    id?: string
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutPromotionsInput
  }

  export type ProductPromotionUncheckedCreateWithoutPromotionInput = {
    id?: string
    productId: string
    createdAt?: Date | string
  }

  export type ProductPromotionCreateOrConnectWithoutPromotionInput = {
    where: ProductPromotionWhereUniqueInput
    create: XOR<ProductPromotionCreateWithoutPromotionInput, ProductPromotionUncheckedCreateWithoutPromotionInput>
  }

  export type ProductPromotionCreateManyPromotionInputEnvelope = {
    data: ProductPromotionCreateManyPromotionInput | ProductPromotionCreateManyPromotionInput[]
    skipDuplicates?: boolean
  }

  export type ServicePromotionUpsertWithWhereUniqueWithoutPromotionInput = {
    where: ServicePromotionWhereUniqueInput
    update: XOR<ServicePromotionUpdateWithoutPromotionInput, ServicePromotionUncheckedUpdateWithoutPromotionInput>
    create: XOR<ServicePromotionCreateWithoutPromotionInput, ServicePromotionUncheckedCreateWithoutPromotionInput>
  }

  export type ServicePromotionUpdateWithWhereUniqueWithoutPromotionInput = {
    where: ServicePromotionWhereUniqueInput
    data: XOR<ServicePromotionUpdateWithoutPromotionInput, ServicePromotionUncheckedUpdateWithoutPromotionInput>
  }

  export type ServicePromotionUpdateManyWithWhereWithoutPromotionInput = {
    where: ServicePromotionScalarWhereInput
    data: XOR<ServicePromotionUpdateManyMutationInput, ServicePromotionUncheckedUpdateManyWithoutPromotionInput>
  }

  export type PackagePromotionUpsertWithWhereUniqueWithoutPromotionInput = {
    where: PackagePromotionWhereUniqueInput
    update: XOR<PackagePromotionUpdateWithoutPromotionInput, PackagePromotionUncheckedUpdateWithoutPromotionInput>
    create: XOR<PackagePromotionCreateWithoutPromotionInput, PackagePromotionUncheckedCreateWithoutPromotionInput>
  }

  export type PackagePromotionUpdateWithWhereUniqueWithoutPromotionInput = {
    where: PackagePromotionWhereUniqueInput
    data: XOR<PackagePromotionUpdateWithoutPromotionInput, PackagePromotionUncheckedUpdateWithoutPromotionInput>
  }

  export type PackagePromotionUpdateManyWithWhereWithoutPromotionInput = {
    where: PackagePromotionScalarWhereInput
    data: XOR<PackagePromotionUpdateManyMutationInput, PackagePromotionUncheckedUpdateManyWithoutPromotionInput>
  }

  export type ProductPromotionUpsertWithWhereUniqueWithoutPromotionInput = {
    where: ProductPromotionWhereUniqueInput
    update: XOR<ProductPromotionUpdateWithoutPromotionInput, ProductPromotionUncheckedUpdateWithoutPromotionInput>
    create: XOR<ProductPromotionCreateWithoutPromotionInput, ProductPromotionUncheckedCreateWithoutPromotionInput>
  }

  export type ProductPromotionUpdateWithWhereUniqueWithoutPromotionInput = {
    where: ProductPromotionWhereUniqueInput
    data: XOR<ProductPromotionUpdateWithoutPromotionInput, ProductPromotionUncheckedUpdateWithoutPromotionInput>
  }

  export type ProductPromotionUpdateManyWithWhereWithoutPromotionInput = {
    where: ProductPromotionScalarWhereInput
    data: XOR<ProductPromotionUpdateManyMutationInput, ProductPromotionUncheckedUpdateManyWithoutPromotionInput>
  }

  export type PromotionCreateWithoutServicesInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    discountType: $Enums.DiscountType
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    packages?: PackagePromotionCreateNestedManyWithoutPromotionInput
    products?: ProductPromotionCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    discountType: $Enums.DiscountType
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    packages?: PackagePromotionUncheckedCreateNestedManyWithoutPromotionInput
    products?: ProductPromotionUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionCreateOrConnectWithoutServicesInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutServicesInput, PromotionUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutPromotionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    duration: number
    price: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ServiceCategoryCreateNestedOneWithoutServicesInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
    packageServices?: PackageServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutPromotionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    duration: number
    price: Decimal | DecimalJsLike | number | string
    categoryId: string
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
    packageServices?: PackageServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutPromotionsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutPromotionsInput, ServiceUncheckedCreateWithoutPromotionsInput>
  }

  export type PromotionUpsertWithoutServicesInput = {
    update: XOR<PromotionUpdateWithoutServicesInput, PromotionUncheckedUpdateWithoutServicesInput>
    create: XOR<PromotionCreateWithoutServicesInput, PromotionUncheckedCreateWithoutServicesInput>
    where?: PromotionWhereInput
  }

  export type PromotionUpdateToOneWithWhereWithoutServicesInput = {
    where?: PromotionWhereInput
    data: XOR<PromotionUpdateWithoutServicesInput, PromotionUncheckedUpdateWithoutServicesInput>
  }

  export type PromotionUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    packages?: PackagePromotionUpdateManyWithoutPromotionNestedInput
    products?: ProductPromotionUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    packages?: PackagePromotionUncheckedUpdateManyWithoutPromotionNestedInput
    products?: ProductPromotionUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type ServiceUpsertWithoutPromotionsInput = {
    update: XOR<ServiceUpdateWithoutPromotionsInput, ServiceUncheckedUpdateWithoutPromotionsInput>
    create: XOR<ServiceCreateWithoutPromotionsInput, ServiceUncheckedCreateWithoutPromotionsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutPromotionsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutPromotionsInput, ServiceUncheckedUpdateWithoutPromotionsInput>
  }

  export type ServiceUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresProfessional?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ServiceCategoryUpdateOneRequiredWithoutServicesNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
    packageServices?: PackageServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresProfessional?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
    packageServices?: PackageServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type PromotionCreateWithoutPackagesInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    discountType: $Enums.DiscountType
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServicePromotionCreateNestedManyWithoutPromotionInput
    products?: ProductPromotionCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateWithoutPackagesInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    discountType: $Enums.DiscountType
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServicePromotionUncheckedCreateNestedManyWithoutPromotionInput
    products?: ProductPromotionUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionCreateOrConnectWithoutPackagesInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutPackagesInput, PromotionUncheckedCreateWithoutPackagesInput>
  }

  export type PackageCreateWithoutPromotionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    variant?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: PackageServiceCreateNestedManyWithoutPackageInput
    bookings?: BookingCreateNestedManyWithoutPackageInput
  }

  export type PackageUncheckedCreateWithoutPromotionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    variant?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: PackageServiceUncheckedCreateNestedManyWithoutPackageInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPackageInput
  }

  export type PackageCreateOrConnectWithoutPromotionsInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutPromotionsInput, PackageUncheckedCreateWithoutPromotionsInput>
  }

  export type PromotionUpsertWithoutPackagesInput = {
    update: XOR<PromotionUpdateWithoutPackagesInput, PromotionUncheckedUpdateWithoutPackagesInput>
    create: XOR<PromotionCreateWithoutPackagesInput, PromotionUncheckedCreateWithoutPackagesInput>
    where?: PromotionWhereInput
  }

  export type PromotionUpdateToOneWithWhereWithoutPackagesInput = {
    where?: PromotionWhereInput
    data: XOR<PromotionUpdateWithoutPackagesInput, PromotionUncheckedUpdateWithoutPackagesInput>
  }

  export type PromotionUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServicePromotionUpdateManyWithoutPromotionNestedInput
    products?: ProductPromotionUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServicePromotionUncheckedUpdateManyWithoutPromotionNestedInput
    products?: ProductPromotionUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type PackageUpsertWithoutPromotionsInput = {
    update: XOR<PackageUpdateWithoutPromotionsInput, PackageUncheckedUpdateWithoutPromotionsInput>
    create: XOR<PackageCreateWithoutPromotionsInput, PackageUncheckedCreateWithoutPromotionsInput>
    where?: PackageWhereInput
  }

  export type PackageUpdateToOneWithWhereWithoutPromotionsInput = {
    where?: PackageWhereInput
    data: XOR<PackageUpdateWithoutPromotionsInput, PackageUncheckedUpdateWithoutPromotionsInput>
  }

  export type PackageUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: PackageServiceUpdateManyWithoutPackageNestedInput
    bookings?: BookingUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: PackageServiceUncheckedUpdateManyWithoutPackageNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type PromotionCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    discountType: $Enums.DiscountType
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServicePromotionCreateNestedManyWithoutPromotionInput
    packages?: PackagePromotionCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    code?: string | null
    discountType: $Enums.DiscountType
    discountValue: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServicePromotionUncheckedCreateNestedManyWithoutPromotionInput
    packages?: PackagePromotionUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionCreateOrConnectWithoutProductsInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutPromotionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    stock?: number
    category?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPromotionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    stock?: number
    category?: string | null
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPromotionsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPromotionsInput, ProductUncheckedCreateWithoutPromotionsInput>
  }

  export type PromotionUpsertWithoutProductsInput = {
    update: XOR<PromotionUpdateWithoutProductsInput, PromotionUncheckedUpdateWithoutProductsInput>
    create: XOR<PromotionCreateWithoutProductsInput, PromotionUncheckedCreateWithoutProductsInput>
    where?: PromotionWhereInput
  }

  export type PromotionUpdateToOneWithWhereWithoutProductsInput = {
    where?: PromotionWhereInput
    data: XOR<PromotionUpdateWithoutProductsInput, PromotionUncheckedUpdateWithoutProductsInput>
  }

  export type PromotionUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServicePromotionUpdateManyWithoutPromotionNestedInput
    packages?: PackagePromotionUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServicePromotionUncheckedUpdateManyWithoutPromotionNestedInput
    packages?: PackagePromotionUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type ProductUpsertWithoutPromotionsInput = {
    update: XOR<ProductUpdateWithoutPromotionsInput, ProductUncheckedUpdateWithoutPromotionsInput>
    create: XOR<ProductCreateWithoutPromotionsInput, ProductUncheckedCreateWithoutPromotionsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPromotionsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPromotionsInput, ProductUncheckedUpdateWithoutPromotionsInput>
  }

  export type ProductUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BookingCreateWithoutStatusHistoryInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutBookingsInput
    package?: PackageCreateNestedOneWithoutBookingsInput
    professional?: UserCreateNestedOneWithoutBookingsAsProfessionalInput
    giftCard?: GiftCardCreateNestedOneWithoutUsedInBookingsInput
    payment: PaymentCreateNestedOneWithoutBookingInput
    createdBy?: UserCreateNestedOneWithoutBookingsCreatedInput
  }

  export type BookingUncheckedCreateWithoutStatusHistoryInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    serviceId?: string | null
    packageId?: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    professionalId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardId?: string | null
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    paymentId: string
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutStatusHistoryInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutStatusHistoryInput, BookingUncheckedCreateWithoutStatusHistoryInput>
  }

  export type BookingUpsertWithoutStatusHistoryInput = {
    update: XOR<BookingUpdateWithoutStatusHistoryInput, BookingUncheckedUpdateWithoutStatusHistoryInput>
    create: XOR<BookingCreateWithoutStatusHistoryInput, BookingUncheckedCreateWithoutStatusHistoryInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutStatusHistoryInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutStatusHistoryInput, BookingUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type BookingUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutBookingsNestedInput
    package?: PackageUpdateOneWithoutBookingsNestedInput
    professional?: UserUpdateOneWithoutBookingsAsProfessionalNestedInput
    giftCard?: GiftCardUpdateOneWithoutUsedInBookingsNestedInput
    payment?: PaymentUpdateOneRequiredWithoutBookingNestedInput
    createdBy?: UserUpdateOneWithoutBookingsCreatedNestedInput
  }

  export type BookingUncheckedUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    professionalId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardId?: NullableStringFieldUpdateOperationsInput | string | null
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutWorkingSchedulesInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteCreateNestedManyWithoutAuthorInput
    assignedClients?: AssignmentCreateNestedManyWithoutProfessionalInput
    reviewsReceived?: ReviewCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingCreateNestedManyWithoutCreatedByInput
    availabilities?: AvailabilityCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodCreateNestedManyWithoutProfessionalInput
  }

  export type UserUncheckedCreateWithoutWorkingSchedulesInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedClients?: AssignmentUncheckedCreateNestedManyWithoutProfessionalInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingUncheckedCreateNestedManyWithoutCreatedByInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutProfessionalInput
    breaks?: BreakPeriodUncheckedCreateNestedManyWithoutProfessionalInput
  }

  export type UserCreateOrConnectWithoutWorkingSchedulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkingSchedulesInput, UserUncheckedCreateWithoutWorkingSchedulesInput>
  }

  export type UserUpsertWithoutWorkingSchedulesInput = {
    update: XOR<UserUpdateWithoutWorkingSchedulesInput, UserUncheckedUpdateWithoutWorkingSchedulesInput>
    create: XOR<UserCreateWithoutWorkingSchedulesInput, UserUncheckedCreateWithoutWorkingSchedulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkingSchedulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkingSchedulesInput, UserUncheckedUpdateWithoutWorkingSchedulesInput>
  }

  export type UserUpdateWithoutWorkingSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUpdateManyWithoutAuthorNestedInput
    assignedClients?: AssignmentUpdateManyWithoutProfessionalNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUpdateManyWithoutCreatedByNestedInput
    availabilities?: AvailabilityUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUpdateManyWithoutProfessionalNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkingSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedClients?: AssignmentUncheckedUpdateManyWithoutProfessionalNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUncheckedUpdateManyWithoutCreatedByNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutProfessionalNestedInput
    breaks?: BreakPeriodUncheckedUpdateManyWithoutProfessionalNestedInput
  }

  export type UserCreateWithoutBreaksInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteCreateNestedManyWithoutAuthorInput
    assignedClients?: AssignmentCreateNestedManyWithoutProfessionalInput
    reviewsReceived?: ReviewCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingCreateNestedManyWithoutCreatedByInput
    availabilities?: AvailabilityCreateNestedManyWithoutProfessionalInput
    workingSchedules?: WorkingScheduleCreateNestedManyWithoutProfessionalInput
  }

  export type UserUncheckedCreateWithoutBreaksInput = {
    id?: string
    email: string
    telephone: string
    password: string
    role: $Enums.UserRole
    nom?: string | null
    prenom?: string | null
    photoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notesCreated?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedClients?: AssignmentUncheckedCreateNestedManyWithoutProfessionalInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsAsProfessional?: BookingUncheckedCreateNestedManyWithoutProfessionalInput
    bookingsCreated?: BookingUncheckedCreateNestedManyWithoutCreatedByInput
    availabilities?: AvailabilityUncheckedCreateNestedManyWithoutProfessionalInput
    workingSchedules?: WorkingScheduleUncheckedCreateNestedManyWithoutProfessionalInput
  }

  export type UserCreateOrConnectWithoutBreaksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBreaksInput, UserUncheckedCreateWithoutBreaksInput>
  }

  export type UserUpsertWithoutBreaksInput = {
    update: XOR<UserUpdateWithoutBreaksInput, UserUncheckedUpdateWithoutBreaksInput>
    create: XOR<UserCreateWithoutBreaksInput, UserUncheckedCreateWithoutBreaksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBreaksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBreaksInput, UserUncheckedUpdateWithoutBreaksInput>
  }

  export type UserUpdateWithoutBreaksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUpdateManyWithoutAuthorNestedInput
    assignedClients?: AssignmentUpdateManyWithoutProfessionalNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUpdateManyWithoutCreatedByNestedInput
    availabilities?: AvailabilityUpdateManyWithoutProfessionalNestedInput
    workingSchedules?: WorkingScheduleUpdateManyWithoutProfessionalNestedInput
  }

  export type UserUncheckedUpdateWithoutBreaksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesCreated?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedClients?: AssignmentUncheckedUpdateManyWithoutProfessionalNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsAsProfessional?: BookingUncheckedUpdateManyWithoutProfessionalNestedInput
    bookingsCreated?: BookingUncheckedUpdateManyWithoutCreatedByNestedInput
    availabilities?: AvailabilityUncheckedUpdateManyWithoutProfessionalNestedInput
    workingSchedules?: WorkingScheduleUncheckedUpdateManyWithoutProfessionalNestedInput
  }

  export type NoteCreateManyAuthorInput = {
    id?: string
    content: string
    clientId: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    feedbackToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateManyProfessionalInput = {
    id?: string
    clientId: string
    assignedAt?: Date | string
  }

  export type ReviewCreateManyProfessionalInput = {
    id?: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    createdAt?: Date | string
  }

  export type BookingCreateManyProfessionalInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    serviceId?: string | null
    packageId?: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardId?: string | null
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    paymentId: string
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyCreatedByInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    serviceId?: string | null
    packageId?: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    professionalId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardId?: string | null
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    paymentId: string
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityCreateManyProfessionalInput = {
    id?: string
    date: Date | string
    startTime?: string | null
    endTime?: string | null
    isAvailable?: boolean
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkingScheduleCreateManyProfessionalInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreakPeriodCreateManyProfessionalInput = {
    id?: string
    dayOfWeek?: number | null
    startTime: string
    endTime: string
    label?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUpdateWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutBookingsNestedInput
    package?: PackageUpdateOneWithoutBookingsNestedInput
    giftCard?: GiftCardUpdateOneWithoutUsedInBookingsNestedInput
    payment?: PaymentUpdateOneRequiredWithoutBookingNestedInput
    createdBy?: UserUpdateOneWithoutBookingsCreatedNestedInput
    statusHistory?: BookingStatusHistoryUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardId?: NullableStringFieldUpdateOperationsInput | string | null
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: BookingStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardId?: NullableStringFieldUpdateOperationsInput | string | null
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutBookingsNestedInput
    package?: PackageUpdateOneWithoutBookingsNestedInput
    professional?: UserUpdateOneWithoutBookingsAsProfessionalNestedInput
    giftCard?: GiftCardUpdateOneWithoutUsedInBookingsNestedInput
    payment?: PaymentUpdateOneRequiredWithoutBookingNestedInput
    statusHistory?: BookingStatusHistoryUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    professionalId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardId?: NullableStringFieldUpdateOperationsInput | string | null
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: BookingStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    professionalId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardId?: NullableStringFieldUpdateOperationsInput | string | null
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUpdateWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateManyWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingScheduleUpdateWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingScheduleUncheckedUpdateWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingScheduleUncheckedUpdateManyWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakPeriodUpdateWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakPeriodUncheckedUpdateWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakPeriodUncheckedUpdateManyWithoutProfessionalInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteCreateManyClientInput = {
    id?: string
    content: string
    authorId: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    feedbackToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateManyClientInput = {
    id?: string
    professionalId: string
    assignedAt?: Date | string
  }

  export type NoteUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutNotesCreatedNestedInput
  }

  export type NoteUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedbackToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    professional?: UserUpdateOneRequiredWithoutAssignedClientsNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    professionalId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    professionalId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    duration: number
    price: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    displayOrder?: number
    isActive?: boolean
    requiresProfessional?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresProfessional?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutServiceNestedInput
    packageServices?: PackageServiceUpdateManyWithoutServiceNestedInput
    promotions?: ServicePromotionUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresProfessional?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
    packageServices?: PackageServiceUncheckedUpdateManyWithoutServiceNestedInput
    promotions?: ServicePromotionUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresProfessional?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyServiceInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    packageId?: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    professionalId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardId?: string | null
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    paymentId: string
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageServiceCreateManyServiceInput = {
    id?: string
    packageId: string
    quantity?: number
    isOptional?: boolean
    extraCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type ServicePromotionCreateManyServiceInput = {
    id?: string
    promotionId: string
    createdAt?: Date | string
  }

  export type BookingUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    package?: PackageUpdateOneWithoutBookingsNestedInput
    professional?: UserUpdateOneWithoutBookingsAsProfessionalNestedInput
    giftCard?: GiftCardUpdateOneWithoutUsedInBookingsNestedInput
    payment?: PaymentUpdateOneRequiredWithoutBookingNestedInput
    createdBy?: UserUpdateOneWithoutBookingsCreatedNestedInput
    statusHistory?: BookingStatusHistoryUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    professionalId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardId?: NullableStringFieldUpdateOperationsInput | string | null
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: BookingStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    professionalId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardId?: NullableStringFieldUpdateOperationsInput | string | null
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageServiceUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    extraCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    package?: PackageUpdateOneRequiredWithoutServicesNestedInput
  }

  export type PackageServiceUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    extraCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    extraCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePromotionUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotion?: PromotionUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServicePromotionUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePromotionUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageServiceCreateManyPackageInput = {
    id?: string
    serviceId: string
    quantity?: number
    isOptional?: boolean
    extraCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type BookingCreateManyPackageInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    serviceId?: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    professionalId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardId?: string | null
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    paymentId: string
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackagePromotionCreateManyPackageInput = {
    id?: string
    promotionId: string
    createdAt?: Date | string
  }

  export type PackageServiceUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    extraCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutPackageServicesNestedInput
  }

  export type PackageServiceUncheckedUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    extraCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageServiceUncheckedUpdateManyWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    isOptional?: BoolFieldUpdateOperationsInput | boolean
    extraCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutBookingsNestedInput
    professional?: UserUpdateOneWithoutBookingsAsProfessionalNestedInput
    giftCard?: GiftCardUpdateOneWithoutUsedInBookingsNestedInput
    payment?: PaymentUpdateOneRequiredWithoutBookingNestedInput
    createdBy?: UserUpdateOneWithoutBookingsCreatedNestedInput
    statusHistory?: BookingStatusHistoryUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    professionalId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardId?: NullableStringFieldUpdateOperationsInput | string | null
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: BookingStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    professionalId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardId?: NullableStringFieldUpdateOperationsInput | string | null
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagePromotionUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotion?: PromotionUpdateOneRequiredWithoutPackagesNestedInput
  }

  export type PackagePromotionUncheckedUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagePromotionUncheckedUpdateManyWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingStatusHistoryCreateManyBookingInput = {
    id?: string
    oldStatus?: $Enums.BookingStatus | null
    newStatus: $Enums.BookingStatus
    changedById: string
    changedBy: string
    changedByRole: string
    reason?: string | null
    notes?: string | null
    oldDate?: Date | string | null
    newDate?: Date | string | null
    oldStartTime?: string | null
    newStartTime?: string | null
    oldEndTime?: string | null
    newEndTime?: string | null
    oldProfessionalId?: string | null
    newProfessionalId?: string | null
    changedAt?: Date | string
  }

  export type BookingStatusHistoryUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    newStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    changedById?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changedByRole?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    oldDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oldStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    newStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    oldEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    newEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    oldProfessionalId?: NullableStringFieldUpdateOperationsInput | string | null
    newProfessionalId?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingStatusHistoryUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    newStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    changedById?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changedByRole?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    oldDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oldStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    newStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    oldEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    newEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    oldProfessionalId?: NullableStringFieldUpdateOperationsInput | string | null
    newProfessionalId?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingStatusHistoryUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    newStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    changedById?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changedByRole?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    oldDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oldStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    newStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    oldEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    newEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    oldProfessionalId?: NullableStringFieldUpdateOperationsInput | string | null
    newProfessionalId?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyGiftCardInput = {
    id?: string
    bookingNumber: string
    type: $Enums.BookingType
    serviceId?: string | null
    packageId?: string | null
    clientEmail: string
    clientName: string
    clientPhone: string
    specialNotes?: string | null
    bookingDate: Date | string
    startTime: string
    endTime: string
    professionalId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxTPS: Decimal | DecimalJsLike | number | string
    taxTVQ: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    giftCardAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.BookingStatus
    paymentId: string
    reminderSent?: boolean
    googleCalendarEventId?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutGiftCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutBookingsNestedInput
    package?: PackageUpdateOneWithoutBookingsNestedInput
    professional?: UserUpdateOneWithoutBookingsAsProfessionalNestedInput
    payment?: PaymentUpdateOneRequiredWithoutBookingNestedInput
    createdBy?: UserUpdateOneWithoutBookingsCreatedNestedInput
    statusHistory?: BookingStatusHistoryUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutGiftCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    professionalId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: BookingStatusHistoryUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutGiftCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    specialNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    professionalId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTPS?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTVQ?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    giftCardAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: StringFieldUpdateOperationsInput | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymSubscriptionCreateManyMembershipInput = {
    id?: string
    clientEmail: string
    clientName: string
    clientPhone: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    paymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GymSubscriptionUpdateWithoutMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutGymSubscriptionNestedInput
  }

  export type GymSubscriptionUncheckedUpdateWithoutMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GymSubscriptionUncheckedUpdateManyWithoutMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEmail?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    clientPhone?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    orderId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ProductPromotionCreateManyProductInput = {
    id?: string
    promotionId: string
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPromotionUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotion?: PromotionUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductPromotionUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPromotionUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    productId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePromotionCreateManyPromotionInput = {
    id?: string
    serviceId: string
    createdAt?: Date | string
  }

  export type PackagePromotionCreateManyPromotionInput = {
    id?: string
    packageId: string
    createdAt?: Date | string
  }

  export type ProductPromotionCreateManyPromotionInput = {
    id?: string
    productId: string
    createdAt?: Date | string
  }

  export type ServicePromotionUpdateWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutPromotionsNestedInput
  }

  export type ServicePromotionUncheckedUpdateWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePromotionUncheckedUpdateManyWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagePromotionUpdateWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    package?: PackageUpdateOneRequiredWithoutPromotionsNestedInput
  }

  export type PackagePromotionUncheckedUpdateWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagePromotionUncheckedUpdateManyWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPromotionUpdateWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPromotionsNestedInput
  }

  export type ProductPromotionUncheckedUpdateWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPromotionUncheckedUpdateManyWithoutPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientProfileCountOutputTypeDefaultArgs instead
     */
    export type ClientProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCategoryCountOutputTypeDefaultArgs instead
     */
    export type ServiceCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PackageCountOutputTypeDefaultArgs instead
     */
    export type PackageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PackageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingCountOutputTypeDefaultArgs instead
     */
    export type BookingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GiftCardCountOutputTypeDefaultArgs instead
     */
    export type GiftCardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GiftCardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GymMembershipCountOutputTypeDefaultArgs instead
     */
    export type GymMembershipCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GymMembershipCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromotionCountOutputTypeDefaultArgs instead
     */
    export type PromotionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromotionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientProfileDefaultArgs instead
     */
    export type ClientProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientFeedbackDefaultArgs instead
     */
    export type ClientFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientFeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailLogDefaultArgs instead
     */
    export type EmailLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NoteDefaultArgs instead
     */
    export type NoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssignmentDefaultArgs instead
     */
    export type AssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewDefaultArgs instead
     */
    export type ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCategoryDefaultArgs instead
     */
    export type ServiceCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PackageDefaultArgs instead
     */
    export type PackageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PackageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PackageServiceDefaultArgs instead
     */
    export type PackageServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PackageServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AvailabilityDefaultArgs instead
     */
    export type AvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AvailabilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GiftCardDefaultArgs instead
     */
    export type GiftCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GiftCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GymMembershipDefaultArgs instead
     */
    export type GymMembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GymMembershipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GymSubscriptionDefaultArgs instead
     */
    export type GymSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GymSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderItemDefaultArgs instead
     */
    export type OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromotionDefaultArgs instead
     */
    export type PromotionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromotionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServicePromotionDefaultArgs instead
     */
    export type ServicePromotionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServicePromotionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PackagePromotionDefaultArgs instead
     */
    export type PackagePromotionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PackagePromotionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductPromotionDefaultArgs instead
     */
    export type ProductPromotionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductPromotionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingStatusHistoryDefaultArgs instead
     */
    export type BookingStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingStatusHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkingScheduleDefaultArgs instead
     */
    export type WorkingScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkingScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BreakPeriodDefaultArgs instead
     */
    export type BreakPeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BreakPeriodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemSettingsDefaultArgs instead
     */
    export type SystemSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemSettingsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}